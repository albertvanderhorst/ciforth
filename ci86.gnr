_C{         ciforth : a generic I86 ISO FORTH by HCC FIG}
_C{ $Id: ci86.gnr,v 5.157 2018/02/15 23:01:33 albert Exp $}
_C{ Copyright (2012):} M4_SUPPLIER {by GNU Public License}
_C
_C{HCC FIG Holland : Hobby Computer Club, Forth Interest Group  Holland}
        PAGE  66,106
 TITLE   ciforth $Revision: 5.157 $
_C
_C{ For the generic system (to generate ciforth in an other configuration than this one):}
_C{     http://home.hccnet.nl/a.w.m.van.der.horst/ci86gnr.html}
_C
_C{ The following configuration information should agree with the configuration}
_C{ on the frontpage of your docmentation (texinfo, ps, pdf.)}
_C{ WITHOUT FITTING DOCUMENTATION YOU MIGHT AS WELL GIVE UP! }
_C
_C{ Configuration of this particular version:}
_C _BITS_{}-bits _REAL_({real mode })_PROTECTED_({protected mode })
_C _BOOTED_({standalone })_HOSTED_({running under _OS_ })dnl
_HOSTED_DPMI_({running under DPMI (OS/2 or MS-Windows)
_C _CLASSIC_({with classic figforth I/O })_MODERN_({with modern MSDOS I/O })_USEBIOS_({Using the BIOS for I/O })
})dnl
_HOSTED_MSDOS_({running under MSDOS
_C _CLASSIC_({with classic figforth I/O })_MODERN_({with modern MSDOS I/O })_USEBIOS_({Using the BIOS for I/O })
}) _LINUX_C_({_C  with c-routines for I/O})_LINUX_N_({_C  with native forth I/O})
_DLL_({_C  with calls to shared libraries in MS-Windows})
_C Normally ciforth doesn't observe ISO >IN{}_ISO_IN_({{, but this one does}}).
_C{ Contains :}
_C{ (there may be no items here.)}
_SECURITY_({_C{        Security words}
})dnl
_LOAD_({_C{         Loadable words, i.e. all of ISO CORE, more than is needed}
_C{           for a self contained kernel.}
})dnl
_SOURCEFIELD_({_C{ A field in the header to point to source}
})dnl
_EXTRAFIELD_({_C{ An extra field in the header for double links or free use.}
})dnl
_FEWBLOCKS_({_C{ number of blocks limited to 256}
})dnl
_C
dnl It doesn't make sense to have duplicate code for 16/32/64 bits
dnl where m4 can handle it this easily.
dnl 16 bits was default for the startup code, now overrule.
dnl 16 bits is default for the boot code.
_BITS16_({include(width16.m4)})
_BITS32_({include(width32.m4)},{dnl})
_BITS64_({include(width64.m4)},{dnl})
_HEADER_ASM
_COMMENTED({
        A generic version of ISO FORTH for IBM type standard PC's by
                M4_SUPPLIER

                in cooperation with
                HCC Forth user group
                The Netherlands
                www.forth.hccnet.nl

                with
        direct contributions for OSX from Robert Spykerman.

              based on
              FIG-FORTH
   implemented by:  Charlie Krajewski
                    205 ( BIG ) Blue Rd.
                    Middletown, CT  06457

  The listing has been made possible by the
  prior work of:
               Thomas Newman, Hayward, Ca.

 : other_acknowledgements
         John_Cassidy
         Kim_Harris
         George_Flammer
         Robert_D._Villwock ;

 : for tools
         Richard M. Stallman
         Linus Torvalds

No one who programs with FORTH can afford to be without:
  "Starting Forth  by Leo Brodie" and "Thinking Forth by Leo Brodie".
   Both out of print.

This Forth is a descendant in the 300+ (RCS)- generations from fig-Forth.

For nostalgic reasons the following comment has never been removed:
   Although there is much to be said for typing in your own
   listing and getting it running, there is much to be said
   not typing in your own listing.  If you feel that 100+
   pages of plinking is nutty, contact me for availability
   of a disc with source & executable files.  Obtainable at
   a bargain basement price, prepare yourself for bargain
   basement support.

All publications of the FORTH Interest Group are public domain.
They may be further distributed by the inclusion of this
credit notice:
               This publication has been made available by:

               FORTH Interest Group
               P.O. Box 1105
               San Carlos, Ca.  94070
[I feel obliged to keep this last one in (AH). Note that although it is
based on fig-Forth no stone is left unturned.]
})

        PAGE
_C{ ########################################################################################}
_C{                       PREPARATION (no code)}
_C{ ########################################################################################}

FIGREL  EQU     5       _C{ FIG RELEASE #}
FIGREV  EQU     0       _C{ FIG REVISION #}
USRVER  EQU     0      _C{ USER VERSION NUMBER, a digit now}
_C
_C{      VERY ELEMENTARY .}
CW      EQU     M4_CELLWIDTH    _C{ Size of a cell in Forth, not in the bootcode.}
ERRORSCREEN EQU     M4_ERRORSCREEN    _C{ Screen where the error messages start.}
_C
_C{      MEMORY LAYOUT.}
_C{ Normally this is specified at the m4 configuration level.}
_C{ For a configured system these values can be changed at this single place. }
NBUF    EQU     M4_NBUF   _C{ No. of buffers, or screens }
KBBUF   EQU     1024      _C{ Data bytes per disk buffer}
US      EQU     M4_US*CW  _C{ User variable space, eats into next data stack, if any.}
EM      EQU     M4_EM     _C{ Where the memory ends w.r.t. ORIG. 1) }
EMP     EQU     (EM-1)/0x1000+1 _C{ Number of pages.}
TAS     EQU     M4_RTS    _C{Size of unitialised area per task.}
STACKSIZE   EQU TAS/4  _C{For both stacks. } but for now
_DLL_(
{TIBSIZE     EQU 4000H },
{TIBSIZE     EQU TAS/4  _C{TIB size. }
})dnl
_C
_C{ NOTE 1:}
_BITS64_({_C{Nothing tricky on 64 bits systems}},
{
_C{This trick to not have a round memory allocated convinces loaders}
_C{ on Linux 1.24 and following to load the elf header in memory}
_C{ in front of the executable, and not in some other place.}
_C{ ciforth relies on modifying the elf header in behalf of SAVE-SYSTEM.}
_C{This is more convenient than creating it from scratch. It also leaves}
_C{ alone the load address generated by ``ld'', and all other things we}
_C{ are not aware of.}
})

_FEWBLOCKS_({PMASK   EQU     0x0FF    _C{ Allow to access only 256 blocks from OFFSET}})
_C
_C{      ASCII CHARACTER EQUIVALENTS}
_C
ABL     EQU     ' '     _C{ SPACE}
ACR     EQU     {0x0D}     _C{ CR}
AMS     EQU     '-'          _C{ MINUS SIGN }
ASO     EQU     '['          _C{ SQUARE BRACKET OPEN }
ASC     EQU     ']'          _C{ SQUARE BRACKET CLOSE }
ADOT    EQU     '.'          _C{ PERIOD}
ALF      EQU     {0x0A}     _C{ LINE FEED, USED INTERNALLY AS}
                        _C{ LINE ENDER}
AFF      EQU     {0x0C}     _C{ FORM FEED}
BELL    EQU     0x07     _C{ ^G}
BSIN    EQU     0x08     _C{ INPUT DELETE CHARACTER}
BSOUT   EQU     0x08     _C{ OUTPUT BACKSPACE ( ^H )}
_C
_C{      HEADER RELATED EQUATES}
B_DUMMY   EQU     0x01     _C{ dea is dummy, from namespace link}
B_INVIS   EQU     0x02     _C{ dea is invisible, "smudged".}
B_IMMED   EQU     0x04     _C{ dea is a immediate.}
B_DENOT   EQU     0x08     _C{ dea is a denotation.}
C_HOFFSET EQU     0       _C{ Offsets of code field in cells, w.r.t. dea}
D_HOFFSET EQU     1       _C{ Same for data field}
F_HOFFSET EQU     2       _C{ Same for flag field}
L_HOFFSET EQU     3       _C{ Same for link field}
N_HOFFSET EQU     4       _C{ Same for name field}
_SOURCEFIELD_({S_HOFFSET EQU     5       _C{ Same for source field}}, {dnl})
_EXTRAFIELD_({X_HOFFSET EQU     _SOURCEFIELD_(S_HOFFSET,N_HOFFSET)+1_C{ Same for extra field}}, {dnl})
PH_OFFSET EQU     M4_HS   _C{ Past header field: Start of data area. }
BD_OFFSET EQU     M4_HS+1 _C{ Start of BODY for CREATEd word.}
HEADSIZE  EQU     _CELLS(PH_OFFSET)  _C{In cells, only to clean up source.}
_C
_EQULAYOUT_({
_HIGH_BUF_({
BUF1    EQU     EM-(KBBUF+2*M4_CELLWIDTH)*NBUF      _C{ FIRST DISK BUFFER}
TASKEND  EQU     BUF1         _C{ User area}
})_C{}_END_({ _HIGH_BUF_})
_LOW_BUF_({
TASKEND  EQU     EM         _C{ User area at end }
_C
})_C{}_END_({ _LOW_BUF_})

STRUSA  EQU     TASKEND - US    _C{ User area}
INITR0  EQU     TASKEND - US    _C{ Return stack, grows down}
TASKSTART EQU   TASKEND - TAS
STRTIB  EQU     TASKSTART+STACKSIZE     _C{ Start terminal input buffer}
INITS0  EQU     TASKSTART+STACKSIZE     _C{ Grows down,possibly out of task area}
_C
})_C{}_END_({ _EQULAYOUT_})
_CLASSIC_({
DRIVE   EQU     0       _C{ Use floppy A for blocks.}
_C
})_C{}_END_({_CLASSIC_})
_USEBIOS_({
DRIVE   EQU     0       _C{ Use floppy A for blocks.}
_COMMENTED({
DRIVE   EQU     0x80     _C{ Use drive C for blocks.}
})
_C
})_C{}_END_({_USEBIOS_})
BPS     EQU     512             _C{Bytes/sector, common to all of MSDOS}
SPB     EQU     KBBUF/BPS
_C
_RWLBA_({
_C{ PHYSICAL DISK PARAMETERS}
_C{Most of this makes no sense but it is required in a bootsector,}
NFAT    EQU     0     _C{ Number of FATS}
SECROOT EQU     0x0   _C{ Sectors for root directory entry.}
MEDIA   EQU    0x0F8      _C{ Descriptor byte. Anachronism.}
SECFAT  EQU     0       _C{ Sectors per FAT}
SPT     EQU     0     _C{Sectors/track}
HEADS   EQU     0     _C{Number of heads }
TRKS    EQU     0    _C{Number of tracks}
SPDRV   EQU     HEADS*TRKS*SPT    _C{ sectors/drive}
_C
})_C{}_END_({_RWLBA_})
_RWSECTRK_({
_C{ PHYSICAL DISK PARAMETERS}
_C
_C{ Disk parameters: }
_C{ FD drive 3" }
TRKS    EQU     80    _C{Number of tracks}
SPT     EQU     18    _C{Sectors/track}
HEADS   EQU     2     _C{Number of heads }
NFAT    EQU     2     _C{ Number of FATS}
SECROOT EQU     0x0E   _C{ Sectors for root directory entry.}
SECFAT  EQU     9     _C{ Sectors per FAT}
MEDIA   EQU    0x0F0   _C{ Descriptor byte. Used for selecting between A: and C:.}

_COMMENTED({
_C{ FD drive 5" }
TRKS    EQU     80      _C{Number of tracks}
SPT     EQU     15      _C{Sectors/track}
HEADS   EQU     2       _C{Number of heads }
NFAT    EQU     2       _C{ Number of FATS}
SECROOT EQU     ?       _C{ Sectors for root directory entry.}
SECFAT  EQU     7       _C{ Sectors per FAT}
MEDIA   EQU    0x0F0     _C{ Descriptor byte. Used for selecting between A: and C:.}
})

_COMMENTED({
_C{ Hard drive }
_C{This works supposedly with all reasonably modern drives. }
TRKS    EQU     1       _C{Number of tracks, dummy}
SPT     EQU     63      _C{Sectors/track}
HEADS   EQU     255     _C{Number of heads }
NFAT    EQU     2       _C{ Number of FATS}
SECROOT EQU     0       _C{ Sectors for root directory entry, dummy.}
SECFAT  EQU     0       _C{ Sectors per FAT, dummy}
MEDIA   EQU    0x0F8     _C{ Descriptor byte. Used for selecting between A: and C:.}
})

_C{ Bios specific equates.}
BOOTADDRESS     EQU     M4_BIOSBOOT _C{ PC jumps to 0:7C00 to boot}
        _C{ Skip boot sector,fats and root dir and first sector of file.}
_RESPECTDOS_({
SECSTRT EQU     1+NFAT*SECFAT + SECROOT + 1
})_C{}_END_({_RESPECTDOS_})
_NO_RESPECTDOS_({
_C{ The disk needs not to be recognized by MSDOS}
_C{ Usable for generating a bootable floppy simple.}
_C{ Always used for hard disk.}
SECSTRT EQU     1
})_C{}_END_({_NO_RESPECTDOS_})
_C{ END  OF PHYSICAL DISK PARAMETERS}
})_C{}_END_({_RWSECTRK_})
_BOOTLBA_({
_C{ The first gigabyte of the disk is divided into chunks, }
_C{ the size of the core memory to alternately boot from, as a backup.}
CHUNKSIZE       EQU     0x80 * 0x100000 _C{ 128 Mb. }
_C{Size in sectors. }
MAXCHUNK        EQU    1024 *0x100000 /CHUNKSIZE
_C
})_C{}_END_({_BOOTLBA_})
_HOSTED_DPMI_({
_C{DPMI segment defines.}
_C{We can't aim for better than level privilege level 3.}
BITS32_TOGGLE EQU 0x040   _C{ The Big (and Granularity, not yet) bits are complemented}
                            _C{ on switching to 32 bits mode in 6th byte.}
CODE_TOGGLE EQU 0x08   _C{ Toggle between code and data, in the 5th byte.}
})_C{}_END_({_HOSTED_DPMI_})
_SWITCH_({
_C{ Segments   * Valid in real mode % Valid in protected mode }
_C{ Names starting in A_ are linear, physical (32 bit), absolute addresses }
RSTSIZE     EQU     0x10000  _C{ For real mode stack. }
GDTSIZE         EQU     0x8000   _C{ For GDT-table.}
IDTSIZE         EQU     0x0800   _C{ For IDT-table. Not yet used. }
A_FORTH0     EQU     M4_LOADADDRESS - M4_ORG _C{  Physical address of Forth's CS:0 = SS:0 = ES:0 . }

A_SWITCH        EQU     M4_SWITCHORG
A_RST       EQU     A_SWITCH + 0x10000
A_GDT             EQU     A_RST + RSTSIZE
A_IDT             EQU     A_GDT + GDTSIZE  _C{  reserved but not yet used. }
A_LOWDP         EQU     A_IDT + IDTSIZE _C{  Must become this. }

_C{ * Real mode place for the stack.}
_C{ This is such that after switching to real mode an isolated }
_C{ Stack is available }
SS_RST      EQU     A_RST/0x10 _C
SWITCHSEGMENT     EQU     A_SWITCH/0x10 _C{ * DS and CS for real code }
_C{ Add this to go from GDT_CS addresses to GDT_SWITCH addresses.}
M4_SWITCHOFFSET EQU  ( A_FORTH0 - M4_SWITCHORG)

_C{ The GDT_.. are offsets in the GDT table. They can be arbitrarily chosen }
_C{ as far as the GDT goes as long as they are a multiple of 0x08 }
_C{ Switching sometimes restricts these to a particular value.}
GDT_SWITCH       EQU    SWITCHSEGMENT  _C{ % Switching segment, must be same for switching to work! }
GDT_CS EQU 0x10  _C{ % The protected mode code segment }
GDT_SS         EQU     SS_RST _C{ % The protected mode data segment}
GDT_DS         EQU     SS_RST _C{ % The protected mode data segment}
GDT_SEGMENT    EQU     A_GDT/0x10       _C{ * General descriptor table.}

IDENTIFY_16 EQU 0x008F   _C{ Identification of 16 bit data/code segment, byte 6}
IDENTIFY_32 EQU 0x00CF   _C{ Identification of 32 bit data/code segment, byte 6}
IDENTIFY_INT EQU 0x8E00  _C{ Identification of an interrupt descriptor, byte 5}
IDENTIFY_XR  EQU 0x9A00  _C{ Identification of a code segment, execute read, byte 5}
IDENTIFY_RW  EQU 0x9200  _C{ Identification of a data segment, read write, byte 5}

GDTLEN EQU GDTSIZE-1      _C{ Intel peculiarity.}
BOOTOFFSET EQU 0
})_C{}_END_({ _SWITCH_})

_HOSTED_LINUX_({
_BITS16_({include(constant.m4) })
_BITS32_({include(constant.m4) })
_BITS64_({include(constant_64.m4) })
RAWIO           EQU     (ECHO _OR_ ICANON)
_LINUX_C_({Called from c. Remainder c-routines to be called from here.
        extern  c_type,c_expec,c_key,c_qterm
        extern  c_rslw, c_block_exit, c_block_init, c_debug
        GLOBAL  ciforth})
})_C{}_END_({ _HOSTED_LINUX_})
_HOSTED_OSX_({
include(constant_osx.m4)
RAWIO           EQU     (ECHO _OR_ ICANON)
})_C{}_END_({ _HOSTED_OSX_})
_PC_({
create  EQU     0x3C00
open    EQU     0x3D00
close   EQU     0x3E00
read    EQU     0x3F00
write   EQU     0x4000
delete  EQU     0x4100
lseek   EQU     0x4200
EPIPE   EQU     38
})_C{}_END_({ _PC_})

_HOSTED_X_({
        _TEXT_
        PAGE
        GLOBAL  _start       _C Entry point.
        GLOBAL  start        _C Entry point.
_ORIG:
_start:      _C Entry point.
})_C{}_END_({ _HOSTED_X_})
_DLL_({
EPIPE   EQU     109     _C{ " broken pipe " }
_C
        section '.idata' import data readable writeable
        dd 0,0,0,rva kernel_name,rva kernel_table
        dd 0,0,0,0,0

kernel_table:
 _ExitProcess@4     DC rva _ExitProcess
 CreateFile     DC rva _CreateFileA
 _CreateProcessA@40     DC rva _CreateProcess
 _ReadFile@20     DC rva _ReadFile
 _WriteFile@20     DC rva _WriteFile
 CloseHandle     DC rva _CloseHandle
 SetFilePointer     DC rva _SetFilePointer
 _GetCommandLineA@0     DC rva _GetCommandLineA
 GetEnvironmentVariable     DC rva _GetEnvironmentVariable
 _DeleteFileA@4     DC rva _DeleteFileA
 _GetConsoleMode@8     DC rva _GetConsoleMode
 _GetProcAddress@8     DC rva _GetProcAddress
 _GetStdHandle@4         DC rva _GetStdHandle
 _LoadLibraryA@4     DC rva _LoadLibraryA
 _GetLastError@0     DC rva _GetLastError
 _PeekConsoleInputA@16     DC rva _PeekConsoleInputA
 _ReadConsoleA@20     DC rva _ReadConsoleA
 GetTickCount     DC rva _GetTickCount
 GetSystemTime     DC rva _GetSystemTime
 GlobalMemoryStatus     DC rva _GlobalMemoryStatus
 _SetConsoleMode@8     DC rva _SetConsoleMode
 _Sleep@4     DC rva _Sleep
            DC 0

    kernel_name db _BITS64_({'KERNEL32.DLL'})_BITS32_({'KERNEL32.DLL'}),0

 _ExitProcess dw 0
          db 'ExitProcess',0
 _CreateFileA dw 0
          db 'CreateFileA',0
 _CreateProcess dw 0
          db 'CreateProcessA',0
 _ReadFile dw 0
          db 'ReadFile',0
 _WriteFile dw 0
          db 'WriteFile',0
 _CloseHandle dw 0
          db 'CloseHandle',0
 _SetFilePointer dw 0
          db 'SetFilePointer',0
 _GetCommandLineA dw 0
          db 'GetCommandLineA',0
 _GetEnvironmentVariable dw 0
          db 'GetEnvironmentVariableA',0
 _DeleteFileA dw 0
          db 'DeleteFileA',0
 _GetConsoleMode dw 0
          db 'GetConsoleMode',0
 _GetProcAddress dw 0
          db 'GetProcAddress',0
 _GetStdHandle dw 0
          db 'GetStdHandle',0
 _LoadLibraryA dw 0
          db 'LoadLibraryA',0
 _GetLastError dw 0
          db 'GetLastError',0
 _PeekConsoleInputA dw 0
          db 'PeekConsoleInputA'
 _ReadConsoleA dw 0
          db 'ReadConsoleA'
 _GetTickCount dw 0
          db 'GetTickCount',0
 _GetSystemTime dw 0
          db 'GetSystemTime',0
 _GlobalMemoryStatus dw 0
          db 'GlobalMemoryStatus',0
 _SetConsoleMode dw 0
          db 'SetConsoleMode',0
_Sleep dw 0
       db 'Sleep', 0
       _TEXT_
_main:
_ORIG:
})_C{}_END_({ _DLL_})

dnl
_BOOTED_({ dnl
_C{ ########################################################################################}
_C{                      BOOTCODE    (optional, always real mode)}
_C{ ########################################################################################}

_C{ All bootcode must be relocatable and its memory references absolute.}
_C{ Not for the sake of booting, but to allow MSDOS to start the program too. }
        CSEG    SEGMENT PARA PUBLIC 'CODE'
        ASSUME CS:CSEG,DS:CSEG,SS:CSEG,ES:CSEG
})_C{}_END_({ _BOOTED_})
dnl
    _ABSOLUTELOAD_({ ORG     M4_ORG})
    _BOOTED_(_REAL_({ORG     0x100
                              _C{ Accommodate also .exe files} }))

_BOOTSECTRK_({
_ORIG:
        JMP     SHORT BOOT
        NOP
        _C{ MSDOS programmers reference (thru 6, 3.9)}
        DB    "{DFW}--EXP"
BBPS    DW         BPS
        DB         1
RESSECTORS  DW     0x01
        DB         NFAT
        DW BPS*SECROOT/32
        DW         HEADS*TRKS*SPT    _C{ sectors/drive}
BDRIVE                               _C{ True meaning. BIOS drive id.}
BMEDIA  DB         MEDIA             _C{ Temporary meaning, nS after booting.}
        DB         SECFAT, 0x0
BSPT    DW         SPT
BHEADS  DW       HEADS
HIDDENSECS    DD        0x0
HUGESECS      DD         0x000
      _C{ BIOS parameter block ends here}
        DB 0x000, 0x000, 0x029                  _C{ Required magic.}
        DB         0x004, 0x01C, 0x040,  0x00B
        DB    "           "
        DB    "FAT12   "

_C{       Read the sector with number in CX (Counting from 0) to ES:BX.}
_C{       Keep BX, CX  }
READSECTOR:
        PUSH    CX
        PUSH    BX
        MOV     AX,CX
        MOV     CL,[BSPT]
        DIV     CL
        MOV     CL,AH
        INC     CL      _C{ Sectors counting from 1!}
        XOR     AH,AH   _C{ Get rid of remainder}
        MOV     CH,[BHEADS]
        DIV     CH
        MOV     DH,AH   _C{ Head number}
        MOV     CH,AL   _C{ Only small disks <256 cylinders}
        MOV     DL,[BDRIVE]
        MOV     AX,0x0201   _C{ Read absolute one sector}
        INT(0x13)                 _C{BIOS disk access.}
        POP     BX
        POP     CX
        RET

RETRY:
        CALL    DISPLAYW
        XOR     AX,AX   _C{ Reset}
        MOV     DL,[BDRIVE]
        INT(0x13)                 _C{BIOS disk access.}
        CALL    DISPLAYW
        MOV     AL,' '
        CALL DISPLAY
        MOV     AX,CX
        CALL    DISPLAYW
        MOV     AL,' '
        CALL DISPLAY
BOOT:
_C{ Start with replacing braindamaged media byte drive id.}
        MOV     DL, 0x80          _C{ Hard disk, default.}
        MOV     AL, [BMEDIA]
        CMP     AL, 0x0F8        _C{ Fixed disk.}
        JZ     ENDIF1A
        MOV     DL, 0x0          _C{ Floppy.}
ENDIF1A:
        MOV     [BDRIVE],DL
        MOV     AL,'D'
        CALL    DISPLAY
        MOV AX,CS
        AND AX,AX       _C{ Z = BOOTING ?}
        JZ   ENDIF1B
        JMP  NOBOOT
ENDIF1B:
        MOV     AL,'F'
        CALL    DISPLAY
        MOV     AH,00   _C{ Reset}
        MOV     DL,[BDRIVE]
        INT(0x13)                 _C{BIOS disk access.}
        JB      RETRY

        _C{ The first file copied to a freshly formatted floppy will}
        _C{ be at SECSTRT (See also genboot.bat)}
        MOV     CX,SECSTRT      _C{ Counting from zero}
        MOV     AX,BOOTADDRESS/0x10 _C{ Bootsegment}
        MOV     ES,AX
        MOV     BX,BPS
BEGIN1: CALL    READSECTOR
        INC     CX
        ADD     BX,BPS
        JB      RETRY
        CMP     BX,RELATIVE_WRT_ORIG(TEXTEND)
        JB      BEGIN1

        MOV     AL,'{W}'
        CALL    DISPLAY
        CALL    DISPLAYCR

        MOV     AL, [BHEADS]     _C{Copy from boot sector to Forth.}
        MOV     [LFHEADS],AL
        MOV     AL, [BSPT]
        MOV     [LFSPT],AL
        MOV     AL, [BDRIVE]
        MOV     [LFDRIVE], AL

        JMP     ENDBOOT
})_C{}_END_({ _BOOTSECTRK_})

_BOOTLBA_({
_ORIG:
        JMP     SHORT BOOT
        NOP
        _C{ MSDOS programmers reference (thru 6, 3.9)}
        DB    "{DFW}---HD"
BBPS    DW         BPS
        DB         1
RESSECTORS  DW     0x01
        DB         NFAT
        DW BPS*SECROOT/32
        DW         SPDRV
        DB         MEDIA
        DB         SECFAT, 0x0
        DW         SPT
        DW       HEADS
HIDDENSECS    DD        0x0
HUGESECS      DD         0x000
      _C{ BIOS parameter block ends here}
        DB 0x000, 0x000, 0x029                  _C{ Required magic.}
        DB         0x004, 0x01C, 0x040,  0x00B
        DB    "           "
        DB    "RAW     "

BOOTLBA:  DB      0x10, 0
_C{ Rounds down, we already have 1 sector. For HD always load 64K.}
_C{ Bootstrap for ci has to reside in this first part.}
        DW      0x0FFFF/BPS
        DW      BPS             _C{ OFFSET AND SEGMENT}
        DW      SWITCHSEGMENT
STARTSECTOR: _C{ HD Start sector, do be chosen by key press.}
        DD      1       _C{ Start}
        DD      0       _C{ M.S. 32 BITS}

HDREAD:
        MOV     AX,SWITCHSEGMENT
        MOV     DS,AX
        MOV     SI,RELATIVE_WRT_ORIG(BOOTLBA) _C{ DS:SI absolute address of lba.}
        MOV     AX,0x4200  _C{   Read extended                                }
        MOV     DX,0x0080  _C{   Disk C                                 }
        INT     0x13
        RET
RETRY:
        CALL    DISPLAYW
        MOV     AL,' '
        MOV     AH,00   _C{ Reset}
        MOV     DL,80            _C{Drive 80 (hd C:)}
        INT(0x13)                 _C{BIOS disk read function}
        CALL    DISPLAYW
        MOV     AL,' '
        CALL DISPLAY
        MOV     AX,CX
        CALL    DISPLAYW
        MOV     AL,' '
        CALL DISPLAY
BOOT:
        MOV     AL,'D'
        CALL    DISPLAY
        MOV AX,CS
        AND AX,AX       _C{ Z = BOOTING ?}
        JNZ  NOBOOT
        MOV     AL,'F'
        CALL    DISPLAY
        MOV     AH,00   _C{ Reset}
        MOV     DL,80            _C{Drive 80 (hd C:)}
        INT(0x13)                 _C{BIOS disk read function}
        JB      RETRY
        CALL    GETKEY
        JNB     ENDIF
        PUSH    AX
        CALL    DISPLAY
        POP    AX
        SUB     AL, '0'
        JB     ENDIF
        CMP     AL, MAXCHUNK
        JNB     ENDIF
        AND     EAX, 0x0FF
        MOV     ECX, CHUNKSIZE/BPS
        MUL     ECX
        INC     EAX
        MOV     [STARTSECTOR],EAX
ENDIF:  CALL    HDREAD
        JB      RETRY
        MOV     AL,'{W}'
        CALL    DISPLAY
        CALL    DISPLAYCR
        JMP     ENDBOOT

})_C{}_END_({ _BOOTLBA_})
_BOOTED_({
_C{ Debug code, could be dispensed with in an ideal world.}
DISPLAYCR:
        MOV     AL,ACR
        CALL    DISPLAY
        MOV     AL,ALF
        JMP DISPLAY

DISPLAYPC:      POP     AX
        PUSH    AX
DISPLAYW:       PUSH    AX              _C{ Display AX in hex }
        MOV     AL,AH
        CALL    DISPLAYHEX
        POP     AX
        _C{ CALL DISPLAYHEX _C{ RET}}
DISPLAYHEX:     PUSH    AX              _C{ Display AL in hex }
        MOV     CL,4
        SAR     AL,CL
        CALL    DISPLAYHD
        POP     AX
        _C{ CALL DISPLAYHD _C{ RET}}
DISPLAYHD:      AND     AL,0x0F          _C{ Display AL as one hex digit}
        DAA
        MOV     AH,AL
        MOV     CL,5
        SHR     AH,CL
        ADC     AL,0x30
        _C{ CALL DISPLAY _C{ RET}}
DISPLAY:XOR     BH,BH           _C{ Display AL as an ASCII char}
        MOV     AH,0x0E
        INT(0x10)
        RET
GETKEY: MOV     AH, 0x01       _C{ If CARRY, a key sits in AL. }
        INT(0x16)
        JNB     ENDIF1
        MOV     AH, 0x00       _C{ Consume the key. }
        INT(0x16)
ENDIF1:  RET
})_C{}_END_({ _BOOTED_})
NOBOOT:         _C{ Skip till here if not booting.}

_ABSOLUTELOAD_({
_C{ Apparently we may have to move the code, e.g. if started from MSDOS.}
_C{ Prepare return to MSDOS using the original code segment.}
        MOV     AX,CS
        MOV     DS,AX
        CALL    HERE1
HERE1:  POP     BX
        MOV     CX,BX
        ADD     BX,RETDOSV-HERE1+1        _C{ Independant of load address.}
        ADD     CX,RETDOS-HERE1
        MOV     [BX],CX
        INC     BX
        INC     BX
        MOV     [BX],AX
        JMP ENDBOOT     _C

_C{ Returns to DOS, provided we started from dos as a .COM.}
_C{ Use far jump restoring CS to .COM value. }
RETDOS:
        MOV     AX,CS
        MOV     DS,AX
        MOV     ES,AX
        MOV     SS,AX
        MOV     AH,0x4C
        INT     0x21    _C{ Only works if cs is the same as while starting.}

})_C{}_END_({ _ABSOLUTELOAD_})
ENDBOOT:

_HOSTED_MSDOS_({
_C{ ########################################################################################}
_C{                       ADJUST CODE SEGMENT REGISTER (still real mode)}
_C{ ########################################################################################}
_C{ Required start of .COM program.}
_REAL_(
{           ORG     0x100
_ORIG:                         _C{ Accommodate also .exe files} })
_MODERN_(
{       MOV     BX, (EM-1)/0x10+1
        MOV     AH,0x4A              _C{Modify memory allocation}
        INT     0x21})
})
_ABSOLUTELOAD_({
_C{ ########################################################################################}
_C{                       MOVE CODE TO ITS PLACE (still real mode)}
_C{ ########################################################################################}
_C{   Take care of the situation where booting code is actually started up by  }
_C{   MSDOS. This is no problem as long as the code is moved to where it would }
_C{   be if booted. If the code is at its place, nothing really happens here.  }
_C{   Furthermore all protected code started by MSDOS must be at an absolute address.}
        STD     _C{ Start at the end going back.}
        MOV     CX,TEXTEND-HERE5 _C{ Amount to move}
        CALL  HERE6
HERE6:  POP     AX                 _C{  Calculate address of the first byte to move}
        ADD     AX,TEXTEND-HERE6-1
        MOV     SI,AX           _C{ Relocatable address, w.r.t code segment.}
        MOV     AX,CS
        MOV     DS,AX
        MOV     AX, A_FORTH0/0x10 _C{ Destination segment}
        MOV     ES, AX
        MOV     DI, TEXTEND-1
        REPNZ
        MOVSB
        PUSH    ES    _C{ Corrected code segment}
        MOV BX, HERE5
        PUSH BX     _C{ Correct program counter}
        RETF        _C{ Returning to here5 now}
HERE5:
        MOV     AX,CS
        MOV     DS,AX
        MOV     ES,AX
        MOV     SS,AX
        CLD     _C{ Reset direction to going up.}

})_C{}_END_({_ABSOLUTELOAD_})
_SWITCH_({
_C{ ########################################################################################}
_C{                       FILL GDT AND SWITCH TO PROTECTED MODE/32 BITS (optional)}
_C{ ########################################################################################}
        JMP    PROTECT
GDTLOAD DW     GDTLEN
        DD     A_GDT
PROTECT:
_C{Prepare. Remember STOSW uses ES:DI                              }
        MOV     AX,GDT_SEGMENT _C{ GDT segment}
        MOV     ES,AX
        MOV     DI,0
        MOV     AX,GDTLEN
        STOSW
_C{ The switch segment.         }
_C{ Switch between real and (16-bit) protected mode is done,}
_C{ while using this segment (Relocatable code only).}
_C{ GDT_SWITCH can to an extent be chosen arbitrarily,}
_C{ as long as here we ensure that the real mode address  }
_C{ is equal to the protected mode address. }
_C{ You can only switch while staying at the same physical address}
_C{ when you are currently executing in the range GDT_SWITCH:[0:FFFFH] }
        MOV     BX,GDT_SWITCH
        MOV     DI,BX
        MOV     AX,0x0FFFF
        STOSW
        SHL     BX,4     _C{  Turn segment register into IP}
        MOV     AX,BX
        STOSW
        MOV     AX,IDENTIFY_XR
        STOSW
        MOV     AX,IDENTIFY_16
        STOSW
_C
_C{ GDT_DS/GDT_SS to an extent be chosen arbitrarily,}
_C{ The real mode view of GDT_SS is valid, isolated and reserved for real stack.}
_C{ DS is reset after switching anyway.}
_C{ Accommodate a 24 bit start address, a maximal limit, large pages. }
        MOV     DI,GDT_SS _C{Identical to GDT_DS}
        MOV     AX,0x0FFFF
        STOSW
        MOV     EAX,A_FORTH0
        STOSW           _C{ Only 16 bits}
        SHR     EAX,8
        ADD     AX,IDENTIFY_RW
        STOSW
        MOV     AX,IDENTIFY_PROT
        STOSW
_C{ PREPARE-CS 16/32 BITS                                                   }
        MOV     DI,GDT_CS
        MOV     AX,0x0FFFF
        STOSW
        MOV     EAX,A_FORTH0
        STOSW           _C{ Only 16 bits}
        SHR     EAX,8
        ADD     AX,IDENTIFY_XR
        STOSW
        MOV     AX,IDENTIFY_PROT
        STOSW
        LEA     BX,[GDTLOAD]
        LGDT    [BX]
})_C{}_END_({ _SWITCH_})

_HOSTED_MSDOS_({
        PUSH    DS
        MOV     AX,0
        MOV     DS,AX
        LEA     AX,[WARM_ENTRY]
        LEA     BX,[4*0x23]
        MOV     [BX],AX         _C{Jump to WARM_ENTRY on <CTRL-BREAK>}
        INC     BX
        INC     BX
        MOV     AX,CS
        MOV     _CELL_PTR[BX], AX
        POP     DS
ENDREADJUST:
})_C{}_END_({ _HOSTED_MSDOS_})
_BOOTED_({
        JMP     ENDREADJUST
        _NEW_ORG(0x01FE)
        _C{ Signature. Last piece of boot sector. }
        DB         0x055, 0x0AA
ENDREADJUST:
})_C{}_END_({ _BOOTED_})

_SWITCH_({
_C{ Remember: we are now in the real mode for a protected model.}
_C{ Make sure we are in the switch segment, such that we can switch.}
        MOV   BX,CS      _C{ Reality.}
        MOV AX, GDT_SWITCH _C{ Dream.}
        PUSH AX     _C{ Correct code segment}
        SUB AX,BX      _C{ Discrepancy between dream and reality}
        MOV CX,0x10     _C{ How much units would that be for the IP?}
        CWD
        MUL CX
        CALL  HERE3
HERE3:  POP   BX         _C{ Reality.}
        SUB BX,AX    _C
        ADD BX,THERE4-HERE3
        PUSH BX     _C{ Corrected program counter}
        RETF        _C{ Returning to THERE4 now}

_BITS16_({THERE4:})

_BITS32_({
_C{ 32 bit protected mode is no good unless the A20 address line works.}
_C{ The following tedious code is copied from the nuni startup code}
_C{ for linux. }
KB_WAIT:
        IN AL,0x64
        AND AL,2
        JNZ KB_WAIT
        RET
THERE4:
        CALL KB_WAIT
        MOV AL,0x0D1
        OUT 0x064,AL            _C{ Enable a20}
        CALL KB_WAIT
        MOV AL,0x0DF
        OUT 0x060,AL
})_C{}_END_({ _BITS32_})
})_C{}_END_({ _SWITCH_})
dnl
_HOSTED_DPMI_({
_C{ ########################################################################################}
_C{                       PREPARE FOR USING DPMI (OPTIONAL)}
_C{ ########################################################################################}

_C{ Required start of .COM program.}
        ORG     0x100          _C{ Accommodate also .exe files}
_ORIG:
_C{ These are real mode descriptors !}
        MOV     WORD[SaveCS],CS           _C{ Once and for all}
        MOV     WORD[SaveDS],DS
        MOV     WORD[SaveES],ES           _C{ Still pointing to PSP (!?)}
})_C{}_END_({_HOSTED_DPMI_})
_MODERN_({
        MOV     [LOADEXEC+4], DS
        MOV     [LOADEXEC+8], DS
        MOV     [LOADEXEC+12], DS

_C{Must be done before switching to protected mode.}
        MOV     AX, [ES:0x2C]
        MOV     [USINI+_CELLS(31)],AX   _C{Remember ENV pointer.}
        MOV     [LOADEXEC], AX
})_C{}_END_({_MODERN_})

_HOSTED_DPMI_({
_C{ Do a double precision shift to find number of paragraphs. }
    MOV     BX, [DPA]
    MOV     CL,4
    SHR     BX,CL
    MOV     AX, [DPA+2]
    MOV     CL,12
    SHL     AX,CL
    OR      BX,AX
    OR      BX, 0x0FFF   _C{Minimum is 64 K for RW-BUFFER .}.
    INC     BX
    MOV     AH,0x4A  _C{Modify memory allocation to what is needed.}
    INT     0x21
_C
_C{ Check to see if DPMI is available, and make the switch if it is}
_C{ If one is, the stat info is stored.}
            MOV     BL,1
            MOV     AX,0x1687            _C{Get DPMI host address}
            INT     0x2F                 _C{Multiplex interrupt}

            CMP     AX,0                _C{Was it there?}
            JNE     ERRMSG              _C{Nope, so exit}

            AND     BL,1                _C{Test bit 1 (32-bit OK?)}
            MOV     [DPMIentry+0],DI
            MOV     [DPMIentry+2],ES
            PUSH    SI                  _C{Allocation.}

            MOV     AX,0                _C{In case no memory needed}
            POP     BX                  _C{Get number of paragraphs needed by host}
            CMP     BL,0                _C{Any allocation needed?}
            JE      Plunge              _C{No, so continue}
            MOV     AH,0x48              _C{Allocate memory}
            INT     21h
            MOV     BL,2
            JC      ERRMSG              _C{Could not allocate}

Plunge:     MOV     ES,AX
_C{Setting this bit, doesn't mean you arrive in a 32 bit segment!}
            MOV     AX, _BITS16_(0) _BITS32_(1)
            _CALL_FAR_INDIRECT(DPMIentry) _C{Switch to protected mode}
_C{ From here to where the assembler switches to protected mode,}
_C{ code must be 16/32 bit independant.}
            MOV     BL,3
            JC      ERRMSG      _C{still in real mode}

            JMP     SHORT DPMISUCCESS

_C{ Data used by DPMI.}
DPMIentry   DW      0000,0000

_C{Error-- called from diverse places.}
ERRMSG:
           MOV     AL, BL _C{ Use the infamous errorlevel.}
           MOV     AH,0x4C
           INT     0x21

_C{ If we reach this point, we are operating in protected mode}
DPMISUCCESS:
_C{ -------------- First and for all: save --------}
            MOV     WORD[Save_CS_PR],CS
            MOV     WORD[Save_DS_PR],DS
            MOV     WORD[Save_ES_PR],ES
_C{ -------------- Get a new segment for our Forth to ES --------}
            MOV     AX,0x0000            _C{A new selector.}
            MOV     CX,1
            INT     0x31
            MOV     BL,4
            MOV     ES,AX
            JC      ERRMSG

            MOV     AX,0x0501            _C{Allocate memory}
            MOV     BX, WORD[LEM+_CELLS(D_HOFFSET)+2] _C{Split into two words}
            MOV     CX, WORD[LEM+_CELLS(D_HOFFSET)]
            INT     0x31
            PUSH    CX
            PUSH    BX
            MOV     BL,4
            MOV     CX,AX
            JC      ERRMSG

            MOV     AX,0x0007            _C{Set base address.}
            MOV     BX,ES
            POP     CX
            POP     DX
            INT     0x31
            MOV     BL,6
ERRMSG2:    JC      ERRMSG

            MOV     AX,0x0008            _C{Set segment limit.}
            MOV     BX,ES
            MOV     CX, WORD[LEM+_CELLS(D_HOFFSET)+2] _C{Split into two words}
            MOV     DX, WORD[LEM+_CELLS(D_HOFFSET)]
            SUB     DX,1
            SBB     CX,0
            INT     0x31
            MOV     BL,7
            JC      ERRMSG2

            MOV     AX,0x0009            _C{Set access rights.}
            MOV     BX,ES
            MOV     CX, 0x80F2 _C{ %1000 0000 1111 0010 Wyatt pg.618}
            INT     0x31
            MOV     BL,7
            JC      ERRMSG2

_C{ -------------- Fill in the vector at BYE ----------------------}
_C{This must be done before copying!}
        LEA     ECX,[RETDOS]
        LEA     EBX,[RETDOSV+1]
        MOV     [EBX],ECX               _C{For 16 bit, half is overwritten}
        LEA     EBX, [EBX+CW]
        MOV     AX,CS
        MOV     [EBX],AX

_C{ -------------- Get an 32-bit alias for the data segment into DX  --------}
            MOV     AX,0x000A            _C{Alias for LDT descriptor.}
            MOV     BX,DS
            INT     0x31
            MOV     DX,AX
            MOV     BL,7
            JC      ERRMSG2             _C{Could not allocate.}

            MOV     AX,0x0009            _C{Set access rights.}
            MOV     BX,DX
            _C{ %1000 0000 1111 1010  %1100 0000 1111 1010}
            MOV     CX, 0x80F2  _OR_ 0x4000
            INT     0x31
            MOV     BL,7
            JC      ERRMSG2             _C{Could not allocate.}

_C{ --------------  Now copy -------------------------------------------}
            PUSH    DS
            MOV     DS, DX
            MOV     ECX, [DPA]
            XOR     EDI, EDI      _C{SRC}
            XOR     ESI, ESI      _C{dest }
            A32  REP     MOVSB
            POP     DS


_C{ -------------- Release the 32-bit alias -------------------------------}
_C{           ????}

_C{We are now in a position to release the original memory.}
_C{           MOV     BX, 0x1000          _C{BX=paragraphs needed (64K)}}
_C{           MOV     AH,0x4A             _C{Modify memory allocation}}
_C{           INT     0x21}

_C{ -------------- Alias descriptors for ES --------}
_C{ After this section : ES is an alias for CS , DX for DS.}

            MOV     AX,0x000A            _C{Alias for LDT descriptor.}
            MOV     BX,ES
            INT     0x31
            MOV     BL,5
            MOV     DX,AX
ERRMSG3:    JC      ERRMSG2             _C{Could not allocate.}

_C{ -------------- Fill in the alias descriptors, possibly 32 bits --------}

            MOV     AX,0x0009            _C{Set access rights.}
            MOV     BX,ES
            _C{ %1000 0000 1111 1010  %1100 0000 1111 1010}
            MOV     CX, 0x80FA _BITS32_({ _OR_ 0x4000 })
            INT     0x31
            MOV     BL,7
            JC      ERRMSG3

            MOV     AX,0x0009            _C{Set access rights.}
            MOV     BX,DX
            _C{ %1000 0000 1111 1010  %1100 0000 1111 1010}
            MOV     CX, 0x80F2 _BITS32_({ _OR_ 0x4000 })
            INT     0x31
            MOV     BL,7
            JC      ERRMSG3

_C{ -------------- Use the alias descriptors for CS and DS --------}
            PUSH    ES    _C{ Corrected code segment}
            MOV     BX, ENDDPMI _C{ Correct program counter}
            PUSH    BX
            MOV     DS,_DX16
            MOV     ES,_DX16
            RETF        _C{ Returning to ENDDPMI}

_C{ ######################### DPMI CLEAN UP CODE #####################################################}

RETDOS:
_C{       JMP     SHORT $}
_C{ BY jumping back here from BYE CS is restored.}
_C{ Restore also the DS ES and SS.}
        MOV     AX, [Save_DS_PR] _C{Aliased.}
        MOV     DS,AX
        MOV     ES,AX

_C{ FIXME   the real cleanup code comes here}
_C{ It turns out that no cleanup code is required to prevent}
_C{ memory leaks.}

        MOV     AL,BL
        MOV     AH,0x4C
        INT     0x21    _C{ Only works if cs is the same as while starting.}

ENDDPMI:
_C{ ######################### DPMI END ###############################################################}
})_C{}_END_({_HOSTED_DPMI_})


_SWITCH_({
        CLI     _C{ Wait for stacks to be setup.}
        JMPHERE_FROM_REAL
        MOV     AX,GDT_SS
        MOV     SS,{AX}
REP1:
_BITS32_({
        INC AX                  _C{ Wait until a20 works(!)}
        MOV [TESTVALUE],AX
        CMP AX,[0x100000 + TESTVALUE] _C{  2^20 beyond}
        JE REP1
        JMP PASTTEST
TESTVALUE: DD   0
PASTTEST:
})_C{}_END_({ _BITS32_})
})_C{}_END_({ _SWITCH_})
dnl
_LINUX_C_({
_C{ ########################################################################################}
_C{                       FORTH GLUE CODE (optional, except for the jump)}
_C{ ########################################################################################}
SAVE_LINUX:     DD      0,0,0,0,0 _C{ SP, BP, SI, DI, BX}
RETURN_LINUX:
        MOV     ESP,_CELL_PTR[SAVE_LINUX+_CELLS(0)]
        MOV     EBP,_CELL_PTR[SAVE_LINUX+_CELLS(1)]
        MOV     ESI,_CELL_PTR[SAVE_LINUX+_CELLS(2)]
        MOV     EDI,_CELL_PTR[SAVE_LINUX+_CELLS(3)]
        MOV     EBX,_CELL_PTR[SAVE_LINUX+_CELLS(4)]
        RET     _C{ Assuming the old stack has not been disturbed.It shouldn't.}
ciforth:
        MOV     _CELL_PTR[SAVE_LINUX+_CELLS(0)],ESP
        MOV     _CELL_PTR[SAVE_LINUX+_CELLS(1)],EBP
        MOV     _CELL_PTR[SAVE_LINUX+_CELLS(2)],ESI
        MOV     _CELL_PTR[SAVE_LINUX+_CELLS(3)],EDI
        MOV     _CELL_PTR[SAVE_LINUX+_CELLS(4)],EBX
        LEA     ECX,[ESP+_CELLS(1)]
        XOR     EAX,EAX
        CMP     EAX,_CELL_PTR[ECX]
        JZ     ENDIF1
        JMP     WARM_ENTRY         _C{ Warm start}
ENDIF1:

})_C{}_END_({_LINUX_C_})

_HOSTED_X_({
_C{ 4.15.3.2}
dnl ciforth:
_main:
start:
})_C{}_END_({_HOSTED_X_})
COLD_ENTRY:
        CLD                     _C{ DIR = INC}
_THREADS_({
        MOV     AX, _CELL_PTR[USINI+_CELLS(1)]
        MOV     BX, AX
        DEC     BX
        OR      BX, _OFFSET STACKSIZE-1    _C{Requires it is power of 2.}
        INC     BX
        SUB     BX,AX
        ADD     _CELL_PTR[USINI+(CW*(0))], BX
        ADD     _CELL_PTR[USINI+(CW*(1))], BX
        ADD     _CELL_PTR[USINI+(CW*(2))], BX
        ADD     _CELL_PTR[USINI+(CW*(3))], BX
        ADD     _CELL_PTR[USINI+(CW*(4))], BX

})_C{}_END_({_THREADS_})
_HOSTED_X_(
{       MOV     _CELL_PTR[USINI+_CELLS(31)],SPO _C{Remember ARGS.}
})dnl
_BITS64_(,
{        MOV     _DX16,DS
        MOV     SS,_DX16           _C{Atomic with next instruction.}
})_C{}_END_({_BITS64_})
        MOV     SP,_CELL_PTR[USINI+_CELLS(2)]    _C{Parameter stack}
        MOV     RPO,_CELL_PTR[USINI+_CELLS(3)]    _C{Return stack}
        MOV     HIP,_OFFSET COLD+_CELLS(PH_OFFSET) _C{Interpreter pointer}
        _NEXT
_C
_C
_C{ ########################################################################################}
_C{                       FORTH ITSELF}
_C{ ########################################################################################}
_C
dnl fasm has no multiline comments, which is appropiate for an assembler.
dnl So the following is suppressed from the assembler file.
_COMMENTED({
   FORTH REGISTERS
   The names under FORTH are used in the generic source.

   FORTH   Intel    FORTH PRESERVATION RULES
   -----   ----     ----- ------------ -----
dnl Note how the following is to pass through m4
   {HIP}   HIP      High level Interpreter Pointer.  Must be preserved
                    across FORTH words.

   {WOR}   WOR      Working register.  When entering a word
                    via its code field the forthdefi({dea}) is passed in {WOR}.

   {SPO}   SPO      Parameter stack pointer.  Must be preserved
                    across FORTH words.

   {RPO}   RPO      Return stack pointer.  Must be preserved across
                    FORTH words.

            AX      General register.  Used to pass data from
                    FORTH words, see label APUSH or macro {_APUSH}

            DX      General register.  Used to pass more data from
                    FORTH words, see label DPUSH or macro {_DPUSH}

            BX      General purpose register.

            CX      General purpose register.

            CS      Segment register. Must be preserved
                    across FORTH words.

            DS      ditto

            SS      ibid

            ES      Temporary segment register only used by
                    a few words. However it MUST remain equal to
                    DS, such that string primitives can be used
                    with impunity.
            The remaining registers are free to use.
            Within assembler words WOR can be used too,
            as it has served its purpose.

            Here are some  useful code sequences.
            For next:
                    _NEXT
            For push single and next:
                    _PUSH
            For push double and next:
                    _2PUSH


----------------------------------------------------------
})
        PAGE
_COMMENTED({
---------------------------------------------

   COMMENT CONVENTIONS
   ------- -----------

   =       IS EQUAL TO
   <-      ASSIGNMENT

  NAME        =  Address of name
  (NAME)      =  Contents of name
  DEA         =  DICTIONARY ENTRY ADDRESS
                 fields have fixed offsets from DEA
  CFA         =  CODE FIELD ADDRESS : a pointer to executable code
  DFA         =  DATA FIELD ADDRESS : a pointer to
                        data/high level code/ DOES> pointer
  FFA         =  FLAG FIELD ADDRESS: contains flags
  LFA         =  LINK FIELD ADDRESS: a pointer to the next DEA
  NFA         =  NAME FIELD ADDRESS: a pointer to a name buffer
  _SOURCEFIELD_({SFA         =  SOURCE FIELD ADDRESS: a pointer into source code})
  PHA         =  POST HEADER ADDRESS: Afterall fields

  S1          =  Parameter stack - 1st cell
  S2          =  Parameter stack - 2nd cell
  R1          =  Return stack    - 1st cell
  R2          =  Return stack    - 2nd cell

  LSB         =  Least significant bit
  MSB         =  Most  significant bit
  LB          =  Low byte
  HB          =  High byte
  LC          =  Low  cell
  HC          =  High cell

------------------------------------------------------------
})
_OLDDEBUG_({
        PAGE
_COMMENTED({
             DEBUG SUPPORT

THIS ROUTINE WILL ALLOW YOU TO STEP THRU FORTH PROGRAMS
EVERY TIME 'NEXT' IS EXECUTED.

In order to use the step feature you must do the following:

        1.  patch the instruction in 'next' with a jump
            to 'TNEXT'

        2.  patch your breakpoint routine at
            label   'BREAK'

        3.  set variables, `BIP' & `BIPE' to the
            addresses you want to step thru.

THE CONTENTS OF THE 2 VARIABLES 'BIP` AND `BIPE'
ARE INTERPRETED AS FOLLOWS:

BIP     BIPE    DEBUG-CONDITION
---     ----    ---------------

  0        X    OFF
 -1        X    TRACE ALL `NEXT' CALLS
ADDR1      0    TRACE `ADDR1' ONLY
ADDR1  ADDR2    TRACE `ADDR1' TO `ADDR1'

NOTE:   THE ABOVE ADDRESSES CAN'T POINT TO A
        `CODE FIELD ADDRESS'.
        X = DON'T CARE

-----------------------------------------------------
})

BIP     DC      0       _C{ BREAKPOINT START ADDRESS}
BIPE    DC      0       _C{ BREAKPOINT END ADDR}
        PAGE
_C{      THIS IS THE `NEXT' WITH DEBUG SUPPORT}

TNEXT:  PUSHF           _C{SAVE REGISTER}
        PUSH    AX
        MOV     AX,[BIP]  _C{ BREAKPOINT START ADDR}
        OR      AX,AX   _C{ ZERO?}
        JZ      TNEXT2  _C{ NO BREAKPOINT}
        CMP     AX,-1
        JZ      TNEXT1  _C{ STEP ALL POINTS}
        CMP     AX,HIP   _C{ IN BREAKPOINT RANGE?}
        JZ      TNEXT1  _C{ STEP THIS LOCATION}
        JA      TNEXT2  _C{ NO}
        MOV     AX,[BIPE] _C{ BREAKPOINT END ADDR}
        OR      AX,AX   _C{ ZERO?}
        JZ      TNEXT2  _C{ ONLY 1 LOCATION}
        CMP     AX,HIP   _C{ IN RANGE STILL?}
        JB      TNEXT2  _C{ NO}

_C{      PAUSE ON ADDRESS}
_C
TNEXT1: POPF
_C
_C{********  ADD YOUR BREAKPOINT HERE  **********}
_C
BREAK:  JMP     SHORT   TNEXT3  _C{CONT WITH PROGRAM}
_C
_C{      NO BREAKPOINT PAUSE - RESTORE REGISTERS}
_C
TNEXT2: POP     AX
        POPF
TNEXT3: LODS           _C{ AX <- (IP)}
        MOV     WOR,AX
        JMP     SHORT   NEXT1
})_C{}_END_({_OLDDEBUG_ })
        PAGE
_PC_({
_NEWDEBUG_({
DISPLAYSI:
        _SWITCH_({JMPHERE_FROM_FORTH})
        PUSH    HIP
        PUSH    RPO
        PUSH    WOR
        MOV     AX,WOR
        CALL    DISPLAYW
        MOV     AX,' '
        CALL    DISPLAY
        MOV     AX,HIP
        CALL    DISPLAYW
        CALL    DISPLAYCR
_C{        MOV     AH,0x10}
_C{        INT     0x16}
        POP    WOR
        POP    RPO
        POP    HIP
        _SWITCH_({JMPHERE_FROM_OS})
        RET
_C
})_C{}_END_({_NEWDEBUG_ })
})_C{}_END_({_PC_ })
_C
_OLDDEBUG_({ _COMMENTED({
    Patch the code from NEXT:  ( using a debugger ) with a
    `JMP TNEXT' for tracing through high level FORTH words.
}) })_C{}_END_({_OLDDEBUG_ })
_C{ In 32 bit versions there may be no jumps to NEXT at all }
_C{ The label NEXT1 is rarely relevant (for _OLDDEBUG_) }
DPUSH:  PUSH    DX      _C{ Fall through.}
APUSH:  PUSH    AX
NEXT:
_LINUX_C_({
_NEWDEBUG_({
         PUSH    HIP
         CALL    c_debug
         POP     HIP
})_C{}_END_({_NEWDEBUG_ })
})_C{}_END_({_LINUX_C_})
        LODS           _C{AX <- (IP)}
NEXT1:  MOV     WOR,AX   _C{ (WOR) <- (IP)}
_PC_({_NEWDEBUG_({ CALL    DISPLAYSI})})
        JMP     _CELL_PTR[WOR]    _C{ TO `CFA'}
_C
_C{       Dictionary starts here.}

DP0:
_C{ End of ONLY namespace. Namespaces all end in a link to 0.}
define({_LINKOLD},0)dnl
worddocsafe( {DENOTATIONS},{Prefix_TICK}, {tick_denotation},{--- addr},{I,P},
{Used in the form: forthexample({'nnnn})
In interpret mode it
leaves the forthdefi({execution token})
(equivalent to the forthdefi({dea}) dictionary entry address)
of dictionary word forthsamp({nnnn}).
If the word is not found after a search of the search order
an appropriate error message is given.
In compile mode it finds the same address,
then compiles it as a literal.
It is recommended that one never compiles or postpones it.
(Use a
combination of forthcode({NAME}) and forthcode({FOUND}) _VERBOSE_({{or
any form of explicit parsing and searching }})
instead.)
Furthermore it is recommended
that for non-portable code forthcode({'}) is used in its
forthdefi({denotation}) form without the space.
_VERBOSE_({ Note that if you separate forthcode({'}) by a space{,}
the ISO-conforming version of forthcode({'}) is found}).
},
{{HEADER},{CONTEXT},{'},{[']},{PRESENT},{>CFA},{>DFA},{>FFA},{>LFA},{>NFA},
{>SFA},{>XFA},{EXECUTE}},
dnl Make sure to use the ONLY ' not the FORTH '
{{ : X EXECUTE ; : || '' HIDDEN ; },{},
{ || : QPE 1 2 ; ' QPE X  ' QPE ID. . . 'QPE ID. ||},{QPE 2 1 QPE},
{ || : QQ  ' QPE X ' QPE ID. . . 'QPE ID. ; QQ || },{QPE 2 1 QPE},
{|| 'QPEEE },{|| 'QPEEE ?  ciforth ERROR # 11 : WORD IS NOT FOUND},
{||},{}
},
enddoc)
_HEADER({'},{TICK},{DOCOL}, , B_IMMED + B_DENOT)
        DC      ITICK
        DC      LITER
        DC      SEMIS
_C
worddoc( {DENOTATIONS},{Prefix_&},{char_follows}, {--- c},{I,P},
{Leave forthvar({c}) the non blank char that follows.
Skip another blank character.
_VERBOSE_({This is a denotation: during compilation this behaviour is compiled.})
},
{{^}},
{{&H .},{48 },
{&X  .},{58 },
{: GS1 &H ; GS1 .},{48 },
{: GS2 &X ; GS2 .},{58 }}, enddoc)
_HEADER({&},{DCHAR},{DOCOL}, , B_IMMED + B_DENOT)
        DC      PPFET
        DC      NIP
        DC      LDUP, QBL
        DC      LIT, 10, QERR
        DC      LITER
        _SECURITY_({DC      QDELIM})
        DC      SEMIS

_C
worddoc( {DENOTATIONS},{Prefix_^},{control_follows}, {--- b},{I,P},
{Leave forthvar({b}) the control character value of the char that follows
_VERBOSE_({{i.e. }forthsamp({^A}){ results in 1 and so on}}).
Skip another blank character.
_VERBOSE_({This is a denotation: during compilation this behaviour is compiled.})
},
{{&}},
{{^C .},{3 },
{^I  .},{9 },
{: GS1 ^C ; GS1 .},{3 },
{: GS2 ^I ; GS2 .},{9 }}, enddoc)
_HEADER({^},{DCTL},{DOCOL}, , B_IMMED + B_DENOT)
        DC      PPFET
        DC      NIP
        DC      LDUP, QBL
        DC      LIT, 10, QERR
        DC      LIT, '@', LSUB
        DC      LITER
        _SECURITY_({DC      QDELIM})
        DC      SEMIS
_C
worddocsafe( {DENOTATIONS},{Prefix_0},{den_zero}, {--- s/d},{I,P},
{A prefix that handles numbers that start with
forthkey({0}) .
Similar words are present for all decimal and hex digits.
_VERBOSE_({{ ISO compatibility ony requires that denotators for
decimal digits are present,
one can always use a leading zero.}})
},
{{NUMBER},{B},{7}},
{
{048 .},{48 },
{: GS1 058 ; GS1 .},{58 }},
{{0000,0048 .},{48 },
{: GS1 0000,058 ; GS1 .},{58 }},
{{10048. D.},{10048 }},
enddoc)
_HEADER({0},{DEN0},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
_HEADER({1},{DEN1},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
_HEADER({2},{DEN2},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
_HEADER({3},{DEN3},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
_HEADER({4},{DEN4},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
_HEADER({5},{DEN5},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
_HEADER({6},{DEN6},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
worddocsafe( {DENOTATIONS},{Prefix_7},{den_seven}, {--- s/d},{I,P},
{A prefix that handles numbers that start with
forthkey({7}) . Similar words are present for all decimal and hex digits.
},
{{NUMBER},{0},{B}},
{
{13 . 23 . 33 . 43 . 53 . }, {13 23 33 43 53 },
{53 . 63 . 73 . 83 . 93 . }, {53 63 73 83 93 },
{: GS1 13 . 23 . 33 . 43 . 53 . ; GS1 }, {13 23 33 43 53 },
{: GS2 53 . 63 . 73 . 83 . 93 . ; GS2 }, {53 63 73 83 93 }
},
enddoc)
_HEADER({7},{DEN7},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
_HEADER({8},{DEN8},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
_HEADER({9},{DEN9},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
_HEADER({A},{DENA},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
_HEADER({B},{DENB},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
worddocsafe( {DENOTATIONS},{Prefix_B},{den_b}, {--- s/d},{I,P},
{A prefix that handles numbers that start with
forthkey({B}) . Similar words are present for all decimal and hex digits.
},
{{NUMBER},{0},{7}},
{
{A3 . B3 . C3 . D3 . E3 . F3 . }, {A3 B3 C3 D3 E3 F3 },
{: GS1 A3 . B3 . C3 . D3 . E3 . F3 . ; GS1 }, {A3 B3 C3 D3 E3 F3 }
},
enddoc)
_HEADER({C},{DENC},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
_HEADER({D},{DEND},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
_HEADER({E},{DENE},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
_HEADER({F},{DENF},{DOCOL}, LNUMB, B_IMMED + B_DENOT)
_C
worddoc( {DENOTATIONS},{Prefix_-},{den_minus}, {--- s/d},{I,P},
{A prefix that handles numbers that start with
forthkey({-}) .},
{{NUMBER},{7},{B}},
{{-48 .},{-48 },
{: GS1 -58 ; GS1 .},{-58 }}, enddoc)
_HEADER({-},{DENM},{DOCOL}, , B_IMMED + B_DENOT)
        DC      PNUMB, DNEGA, SDLITE
        DC      SEMIS
_C
worddoc({DENOTATIONS},{Prefix_+},{den_plus}, {--- s/d},{I,P},
{A prefix that handles numbers that start with
forthkey({+}) .},
{{NUMBER},{7},{B}},
{{+48 .},{48 },
{: GS1 +58 ; GS1 .},{58 }}, enddoc)
_HEADER({+},{DENP},{DOCOL}, , B_IMMED + B_DENOT)
        DC      PNUMB, SDLITE
        DC      SEMIS
_C
worddocsafe( {DENOTATIONS},{Prefix_"},{den_quote}, {--- sc},{I,P},
{Parse a forthkey({"}) delimited string and leave it on the stack.
A forthkey({"}) can be embedded in a string by doubling it.
The string is permanent and takes dictionary space.
_VERBOSE_({This is a denotation: during compilation this behaviour is compiled.})
},
{},
{{"APE" TYPE},{APE},
{: GS1 "NOOT" ; GS1 TYPE},{NOOT}},
enddoc)
_HEADER({"},{DENQ},{DOCOL}, , B_IMMED + B_DENOT)
        DC      LIT, SKIP, COMMA        _C{  'SKIP , HERE >R 0 ,}
        DC      HERE, TOR, ZERO, COMMA
DENQ1:
        DC      LIT, '"', PARSE         _C{           BEGIN &" PARSE}
        DC      PPFET, LDUP, LIT, '"', EQUAL _C{           PP@@ DUP &" =}
        _0BRANCH(DENQ2)                 _C{           WHILE}
        DC      TDROP, ONEP             _C{           2DROP 1+ R@ $+!}
        DC      LDUP, ALLOT, RR, SADD
        _BRANCH(DENQ1)                  _C{           REPEAT}
DENQ2:
        DC      QBL, ZEQU
        DC      LIT, 10, QERR           _C{           ?BLANK 0= 10 ?ERROR}
        DC      DROP                    _C{                DROP }
        DC      LDUP, ALLOT, RR, SADD     _C{         DUP ALLOT R@ $+!}
_DLL_({    DC      ZERO, HERE, STOR })    _C{          0 HERE ! }
_ALIGNED_({    DC LALIGN}, {dnl})
        DC      FROMR, SFET, DLITE      _C{           R> $@ POSTPONE DLITERAL ;}
        DC      SEMIS
_C
worddoc( {WORDLISTS},{FORTH},{forth},{},{NISO,FIG},
{The name of the primary namespace.
Execution pushes the forthcode({FORTH}) forthdefi({WID})
to the top of the forthdefi({search order}) .
(For ISO-compliance it would replace the top, however the phrase
forthsamp({ONLY FORTH}) has the effect required by ISO.)
Until additional user forthdefi({word list}) 's are created, new user definitions
become a part of forthcode({FORTH}) .
},
{{CONTEXT},{NAMESPACE}},
{ { NAMESPACE JOHN JOHN ' FORTH >WID CONTEXT @ = .},{0},
  { FORTH ' FORTH >WID CONTEXT @ = .},{_T_} },
enddoc)
_C{ The FORTH word is the only non-denotation in the ONLY namespace.}
_HEADER({FORTH},{FORTH},{DODOE}, , )
        DC      DOVOC
        DC      0       _C{ END OF NAMESPACE LIST}
_HEADER( , , ,0, B_DUMMY,_DEA(TASK))
_C
dnl Remember the top of the ONLY namespace.
define({_STARTOFONLY_},_LINKOLD)dnl
_C
dnl Reset the link chain at this to start the ENVIRONMENT wordlist.
define({_LINKOLD},0)dnl
_C
worddoc({ENVIRONMENTS},{CORE},{core}, {--- ff},{ISO},
{An environment query whether the CORE wordset is present.},
{{ENVIRONMENT?}},
{{"CORE" ENVIRONMENT? . .},{_T_ 0}},
enddoc)
_HEADER({CORE},{CORE},{DOCOL})
        DC      ZERO    _C{ Not (fully) present.}
        DC      SEMIS
_C
worddoc({ENVIRONMENTS},{CPU},{cpu}, {--- d},{CI},
{An environment query returning the cpu-type to be printed as a
base-36 number. },
{{ENVIRONMENT?}},
_BITS64_({{{"CPU" ENVIRONMENT? . 24 BASE ! D. },{_T_ AMDX86}},})
_BITS32_({{{"CPU" ENVIRONMENT? . 24 BASE ! D. },{_T_ 80386}},})
_BITS16_({{{"CPU" ENVIRONMENT? . 24 BASE ! D. },{_T_ 8088}},})
enddoc)
_HEADER({CPU},{LCPU},{DOCOL})
_PROTECTED_({
       _BITS64_({DC      LIT, 0x26482776, ZERO})     _C{ 'AMDX86'}
       _BITS32_({DC      LIT, 0x0CD1856, ZERO})      _C{ '80386'}
       _BITS16_({DC      LIT, 0x1856, LIT, 0x0CD})    _C{ '80386'}
})_C{}_END_({ _PROTECTED_})
_REAL_({
       DC      LIT, 0x0B328, LIT, 0x5      _C{ '8088'     }
})
        DC      SEMIS
_C
_C{       If M4_VERSION exists and contains a . it is an official release}
define({M4_VERSION2}, ifelse( index(M4_VERSION,.), -1,
{beta M4_VERSION},
M4_VERSION))dnl
_C
worddoc({ENVIRONMENTS},{VERSION},{version}, {--- sc},{CI},
{An environment query giving the version }"M4_VERSION2"{ of this Forth as a forthdefin({string constant}).
},
{{ENVIRONMENT?}},
dnl Expect nothing to be typed, because the testing filters out RCS stuff.
{{"VERSION" ENVIRONMENT? . CR TYPE },{_T_ }},
enddoc)
_HEADER({VERSION},{LVERSION},{DOCOL})
_COMMENTED({
_C{       If this is there it is an official release}
        DC      SKIP
        DC      22
IBMPC:  DB      'IBM-PC ciforth'
        DB      FIGREL+0x40,ADOT,FIGREV+0x30,ADOT,USRVER+0x30
        DC      LIT, IBMPC, LIT, 22
})
        _STRINGINLINE( M4_VERSION2)
        DC      SEMIS
undefine({M4_VERSION2})dnl
_C
worddoc({ENVIRONMENTS},{NAME},{name}, {--- sc},{CI},
{An environment query giving the name of this Forth as a forthdefin({string constant}).
},
{{ENVIRONMENT?}},
{{"NAME" ENVIRONMENT? . TYPE },{_T_ ciforth}},
enddoc)
_HEADER({NAME},{LENAME},{DOCOL})
        _STRINGINLINE({ciforth})
        DC      SEMIS
_C
worddoc({ENVIRONMENTS},{SUPPLIER},{supplier}, {--- sc},{CI},
{An environment query giving the SUPPLIER of this Forth as a forthdefin({string constant}).
},
{{ENVIRONMENT?}},
dnl Cannot test against the actual M4_SUPPLIER here, it is not expanded.
{{"SUPPLIER" ENVIRONMENT? . TYPE },{_T_ Albert van der Horst}},
enddoc)
_HEADER({SUPPLIER},{SUPPLIER},{DOCOL})
        _STRINGINLINE(M4_SUPPLIER)
        DC      SEMIS
_C
dnl Remember the top of the environment chain.
define({_STARTOFENVIRONMENT_},_LINKOLD)dnl
dnl The following words belong to the FORTH wordlist.
dnl Reset the link chain.
define({_LINKOLD},0)dnl
_C
worddoc( {WORDLISTS},{ONLY},{ONLY},{},{NISO},
{Set the minimum search order, such that only
forthdefi({denotation})'s (numbers etc.) can be found
plus the word forthcode({FORTH}).
By using forthcode({FORTH}) one can regain control towards a
startup search order.

forthcode({ONLY}) is actually a regular forthcode({NAMESPACE}).
The associated forthdefi({word list}) contains mainly prefix words,
that scan denotations and are described in the chapter
forthcode({DENOTATIONS}).
_VERBOSE_({ If you want to add a denotation{,}
add it to the forthcode({ONLY}) wordlist preferably.
This prevents masking regular words that start with the prefix.})
},
{{PREFIX},{PP},{>WID}},
{
},
enddoc)
_HEADER({ONLY},{ONLY},{DODOE}, , )
        DC      DOVOC
        DC      _DEA(FORTH)     _C{ NEXT NAMESPACE }
ONLYBODY:
_HEADER( , , ,0, B_DUMMY, _STARTOFONLY_)
_C
worddoc( {WORDLISTS},{ENVIRONMENT},{environment},{},{},
{The name of the forthcode({ENVIRONMENT}) namespace. The
associated forthdefi({word list}) contains environment queries.
The names of words present in forthcode({ENVIRONMENT}) are
recognized by
forthcode({ENVIRONMENT?}). This word list is not intended to
be used as a forthcode({CONTEXT}) word list; and only as a
forthcode({CURRENT}) whenever you want to add an environment
query.},
{{NAMESPACE}},
{{: GS1 [COMPILE] ENVIRONMENT DEFINITIONS LATEST ID. [COMPILE] dnl
FORTH DEFINITIONS ; GS1},{SUPPLIER}},
enddoc)
_HEADER({ENVIRONMENT},{ENV},{DODOE}, , )
        DC      DOVOC
        DC      _DEA({ONLY})       _C{ NEXT NAMESPACE }
_HEADER( , , ,0, B_DUMMY, _STARTOFENVIRONMENT_)
_C
worddoc( {MISC},{NOOP},{no_operation},{},{},
{Do nothing. Primarily useful as a placeholder.
},{},
{{NOOP},{}}, enddoc)
CODE_HEADER({NOOP},{NOOP})
       _NEXT
_C
_OLDDEBUG_({ _C{ Rather unclear what this is supposed to.}
NOP0:   DC      $+_CELLS(1)
        JMP NEXT
NOP1:   DC      $+_CELLS(1)
        JMP NEXT
NOP2:   DC      $+_CELLS(1)
        JMP NEXT
})_C{}_END_({_OLDDEBUG_ })
_C
worddoc( {COMPILING~},{LIT},{lit},{--- n},{FIG,C},
{Within a colon-definition, forthcode({LIT}) is compiled followed by a
_BITS_ bit literal number given during compilation.
Later execution of forthcode({LIT}) causes the contents of this
next dictionary cell to be pushed to the stack.
This word is compiled by forthcode({LITERAL}) . },
{{LITERAL}},
{{: TL LIT [ 123 , ] ; TL .},{123}}, enddoc)
CODE_HEADER({LIT},{LIT})
        LODS           _C{ AX <- LITERAL}
        _PUSH          _C{ TO TOP OF STACK}
_C
worddoc( {MISC},{EXECUTE},{execute},{xt ---},{ISO,FIG},
{Execute the definition whose forthdefi({execution token}) is
given by forthvar({xt}) . _VERBOSE_({{The
}forthdefi({code field address}){ serves as an execution token.
(It even has offset 0, but one should not assume that a
}forthdefi({dea}){ is an execution token in portable code.)}})},
{{'},{>CFA}},
{{ ' BL >CFA EXECUTE .},{20},
{ ' BL EXECUTE .},{20}}, enddoc)
CODE_HEADER({EXECUTE},{EXEC})
        POP     WOR      _C{ GET XT}
        JMP     _CELL_PTR[WOR]  _C{(IP) <- (PFA)}
_C
_LOAD_({
worddoc( {CONTROL},{RECURSE},,{(varies)},{ISO},
{Do a recursive call of the definition being compiled.},
{{:}},
{
{: GI6 DUP IF DUP >R 1 - RECURSE R> . THEN ;},{},
{3 GI6 .}, {1 2 3 0},
},
enddoc)
_HEADER({RECURSE}, {RECURSE}, {DOCOL}, ,{B_IMMED})
        DC      LATEST, COMMA
        DC      SEMIS
_C
})_C{}_END_({_LOAD_})
worddoc( {CONTROL~},{BRANCH},{branch},{},{FIG,C},
{The run-time proceedure to unconditionally branch. An in-line
offset is added to the interpretive pointer forthvar({HIP}) to
branch ahead or back. forthcode({BRANCH}) is compiled by
forthcode({ELSE}) forthcode({AGAIN}) forthcode({REPEAT}) .},
{{0BRANCH},{(FORWARD},{(BACK} },
{{ : GS1 1 BRANCH [ 0 CELL+ , ] BL BL ; GS1 . . },
{20 1}},
enddoc)
_HEADER({BRANCH},{BRAN}, {_VAR_FIELD(SKIP)})
_C
worddoc( {CONTROL},{SKIP},{skip},{},{C},
{Skip over an area in memory, where the length is given in the next cell,
then align.
This length doesn't include the length cell, so it is compatible with
forthcode({$@@}) .
_VERBOSE_({{Internal, used for nested compilation and compiling strings. }})},
{{BRANCH}},
{{ : GS1 1 SKIP [ 0 CELL+ , ] BL BL ; GS1 . .},
{20 1}},
enddoc)
CODE_HEADER({SKIP},{SKIP})
BRAN1:  LODS
_ALIGNED_({
        DEC     AX
        OR      AL, _OFFSET M4_CELLWIDTH - 1
        INC     AX
},{dnl })_C{}_END_({_ALIGNED_})
        ADD     HIP,AX
        _NEXT
_C
worddoc( {CONTROL~},{0BRANCH},{zero_branch},{f ---},{FIG,C},
{The run-time proceedure to conditionally branch. If forthvar({f}) is false
(zero), the following in-line parameter is added to the interpretive
pointer to branch ahead or back.
Compiled by forthcode({IF}) , forthcode({UNTIL}) , and forthcode({WHILE}) .
},{{BRANCH},{(FORWARD},{(BACK)},{SKIP} },
{{ : GS1 1 0 0BRANCH [ 0 CELL+ , ] BL BL ; GS1 . .}, {20 1},
{ : GS2 1 1 0BRANCH [ 0 CELL+ , ] BL BL ; GS2 . . .}, {20 20 1}},
enddoc)
CODE_HEADER({0BRANCH},{ZBRAN})
        POP     AX      _C{ GET STACK VALUE}
        OR      AX,AX   _C{ ZERO?}
        JZ      BRAN1   _C{ YES, BRANCH}
        LEA     HIP,[HIP+_CELLS(1)]
        _NEXT
_C
_C
worddocsafe( {CONTROL~},{(LOOP)},{paren_loop},{},{C},
{The run-time proceedure compiled by LOOP which increments the loop
index and tests for loop completion.
},{{LOOP}},
{{." See LOOP"},{See LOOP}},
enddoc)
CODE_HEADER({(LOOP)},{XLOOP})
        MOV     BX,1    _C{ INCREMENT}
XLOO1:  ADD     [RPO],BX _C{ INDEX = INDEX + INCR}
        MOV     AX,[RPO] _C{ GET NEW INDEX}
        SUB     AX,[RPO+_CELLS(1)]        _C{ COMPARE WITH LIMIT}
        XOR     AX,BX   _C{ TEST SIGN}
        JS      BRAN1   _C{ KEEP LOOPING}
_C
_C{  END OF `DO' LOOP}
        LEA     RPO,[RPO+_CELLS(3)]  _C{ ADJ RETURN STACK}
        LEA     HIP,[HIP+_CELLS(1)]       _C{ BYPASS BRANCH OFFSET}
        _NEXT
_C
worddocsafe( {CONTROL~},{(+LOOP)},{paren_plus_loop},{n ---},{C},
{The run-time proceedure compiled by forthcode({+LOOP}), which increments the loop
index by n and tests for loop completion.},{{+LOOP}},
{{." Via +LOOP"},{Via +LOOP}},
enddoc)
CODE_HEADER({(+LOOP)},{XPLOO})
        POP     BX      _C{ GET LOOP VALUE}
        JMP SHORT     XLOO1
        _NEXT           _C{Helpfull for disassembly.}
_C
worddocsafe( {CONTROL~},{(DO)},{paren_do},{},{C},
{The run-time proceedure compiled by forthcode({DO}) which
prepares the return stack, where the looping bookkeeping is kept.},{{DO}},
{{( See DO)},{}},
enddoc)
CODE_HEADER({(DO)},{XDO})
        LODS
        ADD     AX,HIP  _C{Make absolute}
        POP     DX      _C{ INITIAL INDEX VALUE}
        POP     BX      _C{ LIMIT VALUE}
        XCHG    RPO,SPO   _C{ GET RETURN STACK}
        PUSH    AX      _C{ Target location.}
        PUSH    BX
        PUSH    DX
        XCHG    RPO,SPO   _C{ GET PARAMETER STACK}
        _NEXT
_C
worddocsafe( {CONTROL~},{(?DO)},{paren_question_do},{},{C},
{The run-time proceedure compiled by forthcode({?DO}) which
prepares the return stack, where the looping bookkeeping is kept.},{{?DO}},
{{( See ?DO)},{}},
enddoc)
CODE_HEADER({(?DO)},{XQDO})
        LODS
        ADD     AX,HIP  _C{Make absolute}
        POP     DX      _C{ INITIAL INDEX VALUE}
        POP     BX      _C{ LIMIT VALUE}
        CMP     DX,BX
        JGE     QXDO1
        XCHG    RPO,SPO   _C{ GET RETURN STACK}
        PUSH    AX      _C{ Target location.}
        PUSH    BX
        PUSH    DX
        XCHG    RPO,SPO   _C{ GET PARAMETER STACK}
        _NEXT
QXDO1:  MOV     HIP,AX
        _NEXT
_C
worddoc( {CONTROL},{I},{i},{--- n},{ISO,FIG,C},
{Used within a do-loop to copy the loop index to the stack.},
{{DO},{LOOP},{+LOOP}},
{ { : GS1 DO I . LOOP 0 . ; 2 -2 GS1},{-2 -1 0 1 0},
  { : GS2 DO I . LOOP 0 . ; 4 0 GS2},{0 1 2 3 0} },
enddoc)
CODE_HEADER({I},{IDO})
        MOV     AX,[RPO] _C{ GET INDEX VALUE}
        _PUSH          _C{ TO PARAMETER STACK}
_C
worddoc( {CONTROL},{J}, ,{--- n},{ISO,FIG,C},
{Used within a nested do-loop to copy the loop index of the
outer do-loop to the stack.},
{{DO},{LOOP},{+LOOP}},
{ { : GS1 DO 1 0 DO J . LOOP LOOP ; 2 -2 GS1},{-2 -1 0 1},
  { : GS2 DO 1 0 DO J . LOOP LOOP ; 4 0 GS2},{0 1 2 3} },
enddoc)
CODE_HEADER({J},{JDO})
        MOV     AX,[RPO+_CELLS(3)] _C{ GET INDEX VALUE}
        _PUSH          _C{ TO PARAMETER STACK}
_C
worddoc( {CONTROL},{UNLOOP},{unloop},{},{ISO,I,C},
{Discard the loop parameters. Must be used when the regular end
of the loop is by-passed. That means it is not ended via
forthcode({LOOP}) forthcode({+LOOP}) or forthcode({LEAVE}). },
{{DO},{LOOP},{+LOOP},{(BACK},{(FORWARD},{EXIT}},
{
{ : GS1 DO I . I 3 = IF UNLOOP EXIT THEN LOOP ; 10 0 GS1},
{0 1 2 3},
dnl This only words for SECURITY off.
dnl { : GS2 DO I . I 3 - 0BRANCH [ (FORWARD SWAP ] LOOP  EXIT dnl
dnl [ FORWARD) ] UNLOOP ; 10 0 GS2},
dnl {0 1 2 3},
},
enddoc)
CODE_HEADER({UNLOOP},{UNLOOP})
        LEA     RPO,[RPO+_CELLS(3)]
        _NEXT
_C
worddoc( {INITIALISATIONS},{+ORIGIN},{plus_origin},{n --- addr},{},
{Leave the memory address relative by forthvar({n}) bytes to
the area from which the user variables are initialised during startup.
Given a forthdefi({user variable}) the phrase forthsamp({>DFA @ +ORIGIN}) finds the address
where its initial value is stored.
One can access
or modify those boot-up parameters, prior to saving a customised
image in behalf of turnkey programs.
This will affect the initialisation by forthcode({COLD}).
_THREADS_({{
In this forth switching of the user area in behalf of multi-tasking
is accomplished
automatically when the return stack is switched.}},
{{
In this forth switching of the user area in behalf of multi-tasking
is accomplished as follows.
During run time
user variables are fetched from the current user area, via a
pointer at forthsamp({0 +ORIGIN }) . This pointer can be swapped to get
a fresh set of user variables. }})
}
,
{{USER}},
{{0A 0 CELL+ * +ORIGIN @ ' ENVIRONMENT = .}, {_T_}},
enddoc)
_HEADER({+ORIGIN},{PORIG},{DOCOL})
        DC      LIT
        DC      USINI
        DC      PLUS
        DC      SEMIS
_C
_C{      Initialisation block for user variables through DOC-LINK}
_C{       <<<<< must be in same order as user variables >>>>>}
_C{ Still fig-compatible! Both entries take two cells.}
_C
        LEA     WOR,[COLD]
        JMP     _CELL_PTR[WOR]          _C{Hope stacks are still okay.}
        _ALIGN(_CELLS(1))
dnl This is for indirect threaded code, loading HIP with PHA would be portable.
_C{ Make it possible to revector WARM. You can even make it low level. }
        LEA     WOR,[WARM]
        JMP     _CELL_PTR[WOR]          _C{Hope stacks are still okay.}
        _ALIGN(_CELLS(1))
USINI:  DC      STRUSA   dnl
_THREADS_(
_C{ user area, copied before use in this threading Forth.},
_C{ user area, cold value same as next.}
)_C{}_END_({_THREADS_})
        DC      STRUSA  _C{ INIT (U0) user area of the main task 1}
        DC      INITS0  _C{ INIT (S0)         2}
_THREADS_( _C{ RSP@ must not be divisible by TASK-SIZE, to serve as user pointer.})
        DC      INITR0  _THREADS_({ - _CELLS(1)})
                        _C{ INIT (R0)         3}
        DC      STRTIB  _C{ INIT (TIB)        4}
        DC      BSIN    _C{ RUBOUT: get rid of latest char 5}
        DC      0       _C{ AVAILABLE         6}
        DC      1       _C{ INIT (WARNING)     7}
        DC      INITDP  _C{      INIT (FENCE)  8}
DPA:    DC      INITDP  _C{      INIT (DP)     9}
        DC      _DEA(ENV) _C{       INIT (VOC-LINK) 10}
        DC      _CELLS(39+M4_MAXWORDLIST)  _C{ INIT (MAX-USER) 11}
_CLASSIC_({
_COMMENTED({
_C{ This will steer clear of a forth executable, provided it is}
_C{ the first file on the floppy. }
_C{ (X-1)/S+1 rounds up to whole `S', this is used several times. }
_C{ The 2 is rounding plus the extra sector in .EXE files.}
_C{ However it deviates much from the classic model and requires}
_C{ that the disk parameters are available (not only for USEBIOS)}
        DC      (RELATIVE_WRT_ORIG(TEXTEND)-1)/KBBUF+1 _C{ +1 for EXE}
})
_C{ So for now just the classic, swap disk after booting.}
        DC      0       _C{ INIT (OFFSET) }
})_C{}_END_({_CLASSIC_})
_RWSECTRK_({
_NO_RESPECTDOS_({
        DC      0x40     _C{ INIT (OFFSET) }
})_C{}_END_({_NO_RESPECTDOS_})
_RESPECTDOS_({
_C{ This will reserve place for dos information, such that the floppy}
_C{ can be accessed from DOS and makes sure blocks are not allocated}
_C{ within the Forth system itself. }
_C{ BPS subtracted because SECSTRT corresponds with one sector into source. }
_C{ Round up both parts separately.}
_C{       You need a filler file of one sector,}
_C{       if this  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv even (for a 3" drive).}
        DC      (SECSTRT+((RELATIVE_WRT_ORIG(TEXTEND)-1-BPS)/BPS+1)-1)/SPB+1     _C{ INIT (OFFSET) }
})_C{}_END_({_RESPECTDOS_})

})_C{}_END_({_RWSECTRK_})
_RWLBA_({
_C{ This will reserve place for the system itself, on the first part of a }
_C{ hard disk. No problem to just reserve whole memory.}
        DC      64      _C{ Kbyte.}
})_C{}_END_({_RWLBA_})
_C
        DC      0, 0            _C{ WHERE             12 13 }
        DC      0, 0            _C{REMAINDER   14 15 }
_SWITCH_({
_C{ Swap the following with DP to allocate in conventional memory.}
         DC     TEXTEND         _C{ LOW-DP        16}
_C{ Leave space to start conventional programs}
         DC     0x80000          _C{ LOW-EM        17}
})_C{}_END_({ _SWITCH_})
        _RESB(US-(_AP_ - USINI))        _C{ All user can be initialised.}
_C
_C{      <<<<< end of data used by cold start >>>>>}
worddoc( {FORMATTING~},{DIGIT},{digit},{c n1 --- n2 true (ok) c n1 --- x false (bad)},{},
{Converts the ASCII character forthvar({c}) (using base forthvar({n1}) ) to its binary
equivalent forthvar({n2}) , accompanied by a true flag. If the conversion is
invalid, leaves a don't care value and a false flag.},{},
{ {31 0A DIGIT . .},{_T_ 1},
  {41 0A DIGIT . DROP},{0},
  {41 10 DIGIT . .},{_T_ A} },
enddoc)
CODE_HEADER({DIGIT},{DIGIT})
        POP     DX      _C{NUMBER BASE}
        POP     AX      _C{ASCII DIGIT}
        SUB     AL,_OFFSET '0'
        JB      DIGI2   _C{NUMBER ERROR}
        CMP     AL,_OFFSET 9
        JBE     DIGI1   _C{NUMBER = 0 THRU 9}
        SUB     AL,_OFFSET 7
        CMP     AL,_OFFSET 10   _C{NUMBER 'A' THRU 'Z'?}
        JB      DIGI2   _C{NO}
DIGI1:  CMP     AL,DL   _C{ COMPARE NUMBER TO BASE}
        JAE     DIGI2   _C{NUMBER ERROR}
        SUB     DX,DX   _C{ZERO}
        MOV     DL,AL   _C{NEW BINARY NUMBER}
        MOV     AL,_OFFSET 1    _C{TRUE FLAG}
        NEG     AX
        _2PUSH          _C{ADD TO STACK}
_C{   NUMBER ERROR}
DIGI2:  SUB     AX,AX   _C{FALSE FLAG}
        _2PUSH
_C
worddocsafe( {DICTIONARY~},{~MATCH},{unmatch},{sc dea --- sc dea n},{},
{Intended to cooperate with forthcode({(FIND)}) . Compares
the forthdefi({string constant}) forthvar({sc}) with the dea
forthvar({dea})'s name,
Returns into forthvar({n}) the difference between the first characters
that compare unequal, or zero if the strings are the same up to the
smallest length.
_VERBOSE_({ It is required that the dea contains a pointer to a string
variable{,} which may contain an empty string.})
},
{{FOUND},{CORA}},
{ { "TASK" 'TASK ~MATCH . ID. TYPE },{0 TASK TASK },
{ "BLAST" 'TASK ~MATCH . ID. TYPE },{_T_ TASK BLAST } },
enddoc)
_HEADER({~MATCH},{NMATCH},{DOCOL})
_C
        DC      TOR                           _C{ Remember dea}
        DC      TDUP
        DC      RR, TNFA, FETCH, SFET
        DC      ROT, MIN
        DC      CORA
        DC      FROMR, SWAP                   _C{ Leave flag on top of dea.}
        DC      SEMIS                            _C
_C
worddoc( {PARSING},{?BLANK},{query_blank},{c --- ff },{},
{For the character forthvar({c}) return whether this is
considered to be white space into the flag forthvar({ff}) .
At least the space, ASCII null, the tab and the carriage return and line
feed characters are white space.
In ciforth all control characters are considered white space.
},
{{BL},{SPACE}},
{{HEX 20 ?BLANK . 41 ?BLANK .},{_T_ 0}}, enddoc)
_HEADER({?BLANK},{QBL},{DOCOL})
        DC      LBL, ONEP, LESS
        DC      SEMIS
_C
worddocsafe( {PARSING},{PP@@@@},{parse_pointer_fetch_fetch},{ ---addr c},{CI},
{Parse the forthdefi({current input source}) leaving the address forthvar({addr})
of the next character forthvar({c}) . If
at the end of the input source, leave a pointer past the end
and a zero. Advance the input pointer to the next character.
},
{{BLK},{WORD},{PP}},
{{PP@@ A   EMIT TIB @ 8000 OVER + WITHIN .},{A{}_T_} },
enddoc)
_HEADER({PP@@},{PPFET},{DOCOL})
        DC      SRC, CELLP, TFET
        DC      OVER, EQUAL
        _0BRANCH(PPFET1)
        DC      ZERO
        _BRANCH(PPFET2)
PPFET1:
        DC      LDUP
        _ISO_IN_({ DC      SRC, FETCH, PLUS _C{ Make IN >IN.}})
        DC      CFET
        DC      ONE, PP, PSTOR
PPFET2:
        DC      SEMIS
_C
worddocsafe( {PARSING},{NAME},{name},{--- sc},{CI},
{Parse the forthdefi({current input source}) for a word, i.e.
blank-delimited as per forthcode({?BLANK}) . Skip leading delimiters then
advance the input pointer to past the next delimiter or past
the end of the input source. Leave the word found as a string
constant forthvar({sc}). _VERBOSE_({{As it goes with string
constants, you may not alter its content, nor assume anything
is appended. Note that this is more deserving of the name
``WORD'' than what is in the ISO standard, that can be used to parse lines. }})
Contrast this to a forthcode({PREFIX}) word that leaves the input pointer
past itself.
},
{{BLK},{WORD},{PP}},
{{: GS2 NAME . C@ EMIT ; GS2 CELLO},{5 C},
{HEX : GS1 NAME . C@ EMIT ; GS1   QQ},{2 Q}}, enddoc)
_HEADER({NAME},{LNAME},{DOCOL})
        DC      X
PWORD0: DC      DROP
        DC      PPFET, QBL
        DC      OVER, SRC, CELLP, FETCH, LSUB _C{ At end?}
        DC      LAND, ZEQU
        _0BRANCH(PWORD0)

        DC      X
PWORD1: DC      DROP
        DC      PPFET, QBL
        _0BRANCH(PWORD1)

        DC      OVER, LSUB
        _ISO_IN_({DC      SWAP, SRC, FETCH, PLUS, SWAP})
        DC      SEMIS
_C
worddocsafe( {PARSING},{PARSE},{parse},{ c --- sc },{},
{Scan the forthdefi({current input source}) for the character forthvar({c}) .
Return forthvar({sc}): a string from the current position in the
input stream, ending before the first such character,
or at the end of the current input source if it isn't
there. The character is consumed.
_VERBOSE_({{As it goes with }forthdefin({string constant}){s, you may not alter
its content, nor assume anything is appended.}})
_VERBOSE_({{So no leading delimiters are skipped.}})},
{{WORD},{NAME}},
{{ : GS1 5A PARSE . C@ EMIT ; GS1 QQZ},{2 Q}}, enddoc)
_HEADER({PARSE},{PARSE},{DOCOL})
        DC      SRC, CELLP, TFET
        DC      OVER, LSUB
        _ISO_IN_({DC      SWAP, SRC, FETCH, PLUS, SWAP})
        DC      ROT, SSLAS, TSWAP
        DC      ZEQU
        _0BRANCH(PARSE8)
        DC      DROP, SRC, CELLP, FETCH
PARSE8: _ISO_IN_({DC      SRC, FETCH, LSUB })
        DC      PP, STOR
        DC SEMIS
_C
worddoc( {PARSING},{SRC},{s_r_c},{addr ---},{},
{Return the address forthvar({addr})
of the forthdefi({current input source}) specification,
allocated in the user area. It consists of three cells: the
lowest address of the parse area,
_CIF_IN_({the non-inclusive highest address of the parse area
and a pointer to the next character to be parsed.})
_ISO_IN_({the number of characters and the current offset in the
parse area.}) Changing forthsamp({SRC}) takes immediate effect,
and must be atomic,
by changing only the third cell or
by e.g. using forthcode({SET-SRC}).
The third cell has the alias forthsamp({PP}) .
_VERBOSE_({{Words like }forthsamp({>IN BLK SOURCE}){ are secondary,
and return their output by ``second-guessing'' }forthsamp({SRC}){ .}})},
{{SAVE},{RESTORE},{PP},{BLK}},
{{SRC @ TIB @ 8000 OVER + WITHIN .},{_T_} },
enddoc)
_HEADER({SRC},{SRC},{DOUSE}, _CELLS(27))      _C{ And 28 and 29.}
_C
_LOAD_({
worddoc( {PARSING},{SOURCE},{source},{ --- addr n1},{ISO},
{Return the address and length of the forthdefi({current input source}) .
},
{{SRC}},
{{SOURCE DROP TIB @ 8000 OVER + WITHIN .},{_T_},
{SOURCE NIP 0 8000 WITHIN .},{_T_} },
enddoc)
_HEADER({SOURCE},{SOURCE},{DOCOL})
        DC      SRC, TFET
        DC      SWAP, OVER, LSUB
        DC      SEMIS
_C
_SUPPRESSED({{
worddoc( {LIBRARY},{L_>IN},{legacy_in},{--- addr},{ISO,WANT},
{Hides and replaces the user variable forthcode({PP}).
All parsing words use and move the value of that user variable.
Return a variable that contains the offset from the start
within the current input text buffer (terminal or disc) from
which the next text will be accepted.
The legacy
forthcode({>IN}) is not actually a variable:
its content must be fetched immediately, and changing it has no effect.
},
{{(>IN)}},
dnl this test to be moved to library test (after  "-legacy-" WANTED .)
dnl {{: GS1 >IN @ ; QUIT
dnl GS1 .},{4}},
{},
enddoc)
_C
}})_C{}_END_({ _SUPPRESSED})
})_C{}_END_({_LOAD_})
worddoc( {OUTPUT},{CR},{cr},{},{ISO,FIG},
{Transmit character(s)
to the terminal, that result in
a "carriage return" and a "line feed".
_VERBOSE_({{This means that the cursor is positioned at the start
of the next line, if needed the display is scrolled.}})},{{OUT}},
{{ 41 EMIT CR 42 EMIT},{A
B}},
enddoc)
_HEADER({CR},{CR},{DOCOL})
        DC      LIT,ALF
        DC      EMIT
        DC      ZERO, LOUT, STOR
        DC      SEMIS
_C
worddoc( {MEMORY},{CMOVE},{cmove},{from to count ---},{},
{Move the forthvar({count}) quantity of characters beginning at address
 forthvar({from}) to address forthvar({to}) . The contents of
address from is moved first proceeding toward high memory, such
that memory propagation occurs. As the Intel 86-family is
byte-addressing there are no restrictions in ciforth. },
{{MOVE},{CHARS}},
{ {HERE 41 C, 42 C, 43 C, PAD 10 0 FILL PAD 3 CMOVE dnl
PAD COUNT EMIT COUNT EMIT C@ EMIT},{ABC},
{PAD DUP 1+ 2 CMOVE PAD COUNT EMIT COUNT EMIT C@ EMIT},{AAA} },
enddoc)
CODE_HEADER({CMOVE},{LCMOVE})
        CLD             _C{direction}
        MOV     BX,HIP   _C{save }
        POP     CX      _C{count}
        POP     DI      _C{dest}
        POP     SI      _C{source}
        REP     MOVSB
        MOV     HIP,BX   _C{get back }
        _NEXT
_C
worddoc( {MEMORY},{MOVE},{move},{from to count ---},{ISO},
{Move forthvar({count})
bytes beginning at address forthvar({from}) to
address forthvar({to}), such that the destination area contains
what the source area contained, regardless of overlaps.
As the Intel 86-family is byte-addressing there are
no restrictions.
Because in ciforth bytes (address units) and characters are the same
the difference with forthcode({CMOVE}) anounts to forthcode({MOVE})
being an intelligent move.
},
{},
{ {HERE 41 C, 42 C, 43 C, PAD 10 0 FILL PAD 3 MOVE dnl
PAD COUNT EMIT COUNT EMIT C@ EMIT},{ABC},
{PAD DUP 1+ 2 MOVE PAD COUNT EMIT COUNT EMIT C@ EMIT},{AAB} },
enddoc)
CODE_HEADER({MOVE},{LMOVE})
        MOV     BX,HIP   _C{SAVE }
        POP     CX      _C{count}
        POP     DI      _C{dest}
        POP     SI      _C{source}
        CMP     SI,DI
        JC    MOVE1
        CLD             _C{INC DIRECTION}
        JMP SHORT MOVE2
MOVE1:  STD
        ADD     DI,CX
        DEC     DI
        ADD     SI,CX
        DEC     SI
MOVE2:
        REP     MOVSB   _C{THAT'S THE MOVE}
        CLD             _C{INC DIRECTION}
        MOV     HIP,BX   _C{GET BACK }
        _NEXT
_C
_BITS64_(,{  dnl NOT in 64 bits.
worddoc( {MEMORY},{FARMOVE},{far_move},{faraddr1 faraddr2 count ---},{},
{Move forthvar({count})
bytes beginning at forthvar({faraddr1}) to
forthvar({faraddr2}). Segments that are zero are replaced by
defaults: data segment _SEGMENT_ for source, extra segment _SEGMENT_
for destination.
Copying is done from low to high
offset, so there may be memory
propagating. _VERBOSE_({This is not easily seen
from the _SEGMENT_'s{}_PROTECTED_({{, particularly not so in
protected mode}}).})
As the Intel 86-family is byte-addressing there are
no restrictions.
},
{{MOVE},{CMOVE}},
{{." No test"},{No test} },
enddoc)
CODE_HEADER({FARMOVE},{FMOVE})
        CLD             _C{direction}
        MOV     AX,HIP   _C{save }
        MOV     BX,DS    _C{save }
        POP     CX      _C{count}
        POP     DI      _C{dest}
        POP     DX
        AND     _DX16,_DX16
        JZ      FARMV1
        MOV     ES,_DX16
FARMV1:
        POP     SI      _C{source}
        POP     DX
        AND     _DX16,_DX16
        JZ      FARMV2
        MOV     DS,_DX16
FARMV2:
        REP     MOVSB
        MOV     HIP,AX   _C{restore }
        PUSH    BX
        PUSH    BX
        POP     ES
        POP     DS
        _NEXT
_C
})_C{}_END_({_BITS64_})
worddoc( {MULTIPLYING},{UM*},{u_star},{u1 u2 --- ud},{ISO},
{A mixed magnitude math operation which leaves the double number
forthvar({ud}) : the unsigned product of two unsigned numbers
forthvar({u1}) and forthvar({u2}) .},
{{UM/MOD}, {M*},{*}},
{ { -1 -1 UM* . INVERT .},{-2 -2},
  {DECIMAL 240 204 UM* D.},{48960} },
enddoc)
CODE_HEADER({UM*},{USTAR})
        POP     AX
        POP     BX
        MUL     BX      _C{UNSIGNED}
        XCHG    AX,DX   _C{AX NOW = MSW}
        _2PUSH          _C{STORE DOUBLE CELL}
_C
worddoc( {MULTIPLYING},{UM/MOD},{u_slash},{ud u1 --- u2 u3},{ISO},
{Leave the unsigned remainder forthvar({u2}) and unsigned
quotient forthvar({u3}) from the unsigned double dividend
forthvar({ud}) and unsigned divisor forthvar({u1}) .},
{{UM*},{SM/REM},{/}},
{
{1 -2 -1 UM/MOD . .},{-1 0},
{DECIMAL 12.34 100 UM/MOD . .},{12 34}
},
enddoc)
CODE_HEADER({UM/MOD},{USLAS})
        POP     BX      _C{DIVISOR}
        POP     DX      _C{MSW OF DIVIDEND}
        POP     AX      _C{LSW OF DIVIDEND}
        DIV     BX      _C{16 BIT DIVIDE}
        _2PUSH          _C{STORE QUOT/REM}
_C
worddoc( {LOGIC},{AND},{and},{n1 n2 --- n3},{ISO,FIG},
{Leave the bitwise logical and of forthvar({n1}) and
forthvar({n2}) as forthvar({n3}) .
For Forth flags (0 or -1) this is the forthdefi({logical and}) operator.
},
{{XOR},{OR}},
{ { 2 BASE !  11110000 11001100 AND .},{11000000} },
enddoc)
CODE_HEADER({AND},{LAND})
        POP     AX
        POP     BX
        AND     AX,BX
        _PUSH
_C
worddoc( {LOGIC},{OR},{or},{n1 n2 --- n3},{ISO,FIG},
{Leave the bit-wise logical or of two _BITS_-bit
values.
For Forth flags (0 or -1) this is the forthdefi({logical or}) operator.
},{{AND},{XOR}},
{ { 2 BASE !  11110000 11001100 OR .},{11111100} },
enddoc)
CODE_HEADER({OR},{LOR})
        POP     AX      _C{ (S1) <- (S1) OR (S2)}
        POP     BX
        OR      AX,BX
        _PUSH
_C
worddoc( {LOGIC},{XOR},{xor},{nl n2 --- n3},{ISO,FIG},
{Leave the bitwise logical exclusive or of two
 _BITS_-bit values.
For Forth flags (0 or -1) this is the forthdefi({logical xor}) operator.
},{{AND},{OR}},
{ { 2 BASE !  11110000 11001100 XOR .},{111100} },
enddoc)
CODE_HEADER({XOR},{LXOR})
        POP     AX      _C{ (S1) <- (S1) XOR (S2)}
        POP     BX
        XOR     AX,BX
        _PUSH
_C
worddoc( {LOGIC},{INVERT},{INVERT},{n1 --- n2},{ISO},
{Invert all bits of forthvar({n1}) leaving forthvar({n2}) .
For pure flags (0 or -1) this is the forthdefi({logical not}) operator.
},
{{AND},{OR}},
{ { 2 BASE ! 11101101 INVERT 11111111 AND .},{10010} },
enddoc)
CODE_HEADER({INVERT},{INVERT})
        POP     AX      _C{ (S1) <- (S1) XOR (S2)}
        NOT     AX
        _PUSH
_C
worddocsafe( {STACKS},{DSP@@},{d_s_p_fetch},{--- addr},{},
{Return the address forthvar({addr}) of the data stack position,
as it was before forthcode({DSP@@}) was executed.
},
{{S0},{DSP!}},
{ {1  2  DSP@  @  . . . },{2 2 1} },
enddoc)
CODE_HEADER({DSP@},{SPFET})
        MOV     AX,SPO   _C{ (S1) <- (SP)}
        _PUSH
_C
worddoc( {STACKS},{DSP!},{d_s_p_store},{addr ---},{},
{Initialize the data stack pointer with forthvar({addr}) .},
{{DSP@@},{S0}},
{{  1 2 3 S0 @ DSP! DSP@ S0 @ = .},{_T_} },
enddoc)
CODE_HEADER({DSP!},{SPSTO})
        POP     AX
        MOV     SPO,AX        _C{RESET PARAM STACK POINTER}
        _NEXT
_C
worddoc( {STACKS},{DEPTH},{depth},{--- n1},{ISO},
{Leave into forthvar({n1}) the number of items on the data stack,
before forthvar({n1}) was pushed.},
{{DSP@@}},
{{  1 2 3 DEPTH . DROP DROP DROP DEPTH .},{3 0} },
enddoc)
_HEADER({DEPTH},{DEPTH},{DOCOL})
        DC      SZERO, FETCH
        DC      SPFET
        DC      LSUB
        DC      LIT, CW, SLASH
        DC      ONEM
        DC      SEMIS
_C
worddoc( {STACKS},{CLS},{c_l_s},{ i*x -- },{},
{Clear the data stack},
{{DSP!}},
{{  1 2 3 CLS DEPTH .},{0} },
enddoc)
_HEADER({CLS},{CLS},{DOCOL})
        DC      SZERO, FETCH
        DC      SPSTO
        DC      SEMIS
_C
dnl was the end of a LOADable option.
worddocsafe( {STACKS},{RSP@@},{r_s_p_fetch},{--- addr},{},
{Return the address forthvar({addr}) of the current return
stack position, i.e. pointing the current topmost value.},
{{R0},{RSP!}},
{ {: GS1 1 >R  RSP@  @  . R> DROP ; GS1},{1} },
enddoc)
CODE_HEADER({RSP@},{RPFET})      _C{(S1) <- (RP)}
        PUSH    RPO
        _NEXT
_C
worddoc( {STACKS},{RSP!},{r_s_p_store},{addr ---},{},
{Initialize the return stack
pointer with forthvar({addr}).},
{{RSP@@},{R0}},
{{." No test"},{No test} },
enddoc)
CODE_HEADER({RSP!},{RPSTO})
        POP     RPO
        _NEXT
_C
worddoc( {CONTROL},{EXIT},{exit},{},{ISO},
{ Stop interpretation of the current definition. The return
stack must not be engaged, such as between forthcode({>R}) and
forthcode({R>}) , or forthcode({DO}) and forthcode({LOOP}) . In
ciforth it can also be used to terminate
interpretation from a
string, block or file, or a line from the current input stream.
},
{{(;)}},
{ {: GS1 1 EXIT 2 ; GS1 .},{1} },
enddoc)
CODE_HEADER({EXIT},{EXIT})
        MOV     HIP,[RPO] _C{(IP) <- (R1)}
        LEA     RPO,[RPO+_CELLS(1)]
        _NEXT
_C
worddoc( {CONTROL},{CO},{coroutine},{},{},
{ Return to the caller,
suspending interpretation of the current definition,
such that when the caller exits, this definition is resumed.
The return stack must not be engaged,
such as between forthcode({>R}) and
forthcode({R>}) , or forthcode({DO}) and forthcode({LOOP}) .
},
{{EXIT}},
{ {: GS1 2 CO 4 ; : GS2 1 GS1 3 ; GS2 . . . .},{4 3 2 1} },
enddoc)
CODE_HEADER({CO},{CO})
        XCHG    HIP,[RPO]
        _NEXT
_C
worddocsafe( {CONTROL~},{(;)},{paren_semicolon},{},{},
{ This is a synonym for forthcode({EXIT}). It is the run-time
word compiled at the end of a colon-definition which returns
execution to the calling proceedure. Stop interpretation of the
current definition. The return stack must not be engaged. },
{EXIT},
{ {: GS1 1 (;) 2 ; GS1 .},{1} },
enddoc)
_HEADER({(;)},{SEMIS},{_VAR_FIELD(EXIT)})
_C
worddoc( {CONTROL},{LEAVE},{leave},{},{ISO},
{Terminate a do-loop by branching to directly behind the
end of a loop started by forthcode({DO}) or forthcode({?DO}) ,
so after the corresponding
forthcode({LOOP}) or forthcode({+LOOP}) .},{},
{ {: GS1 10 1 DO I 4 = IF LEAVE THEN I . LOOP ; GS1},{1 2 3} },
enddoc)
_HEADER({LEAVE},{LLEAV},{DOCOL})  _C{LIMIT <- INDEX}
        DC      UNLOOP
        DC      SEMIS
_C
worddoc( {STACKS},{>R},{to_r},{n ---},{ISO,FIG,C},
{Remove a number from the forthdefi({data stack}) and place as the most
accessable on the forthdefi({return stack}). Use
should be balanced with forthcode({R>}) in
the same definition.},{{R@@}},
{ {: GS1 1 2 3 >R . R@ . R> . . ; GS1},{2 3 3 1} },
enddoc)
CODE_HEADER({>R},{TOR})        _C{ (R1) <- (S1)}
        POP     BX      _C{GET STACK PARAMETER}
        LEA     RPO,[RPO - _CELLS(1)]    _C{MOVE RETURN STACK DOWN}
        MOV     [RPO],BX _C{ADD TO RETURN STACK}
        _NEXT
_C
worddoc( {STACKS},{R>},{r_from},{--- n},{ISO,FIG},
{Remove the top value from the forthdefi({return stack}) and leave it on the
forthdefi({data stack}) . },{{>R},{R@@}},
{{." Via >R"},{Via >R}},
enddoc)
CODE_HEADER({R>},{FROMR})      _C{(S1) <- (R1)}
        MOV     AX,[RPO] _C{ GET RETURN STACK VALUE}
        LEA     RPO,[RPO + _CELLS(1)]
        _PUSH
_C
worddoc( {STACKS},{RDROP},{r_drop},{---} ,{},
{Remove the top value from the return stack.},{{>R},{R@@},{R>}},
{{." Via >R"},{Via >R}},
enddoc)
CODE_HEADER({RDROP},{RDROP})      _C{(S1) <- (R1)}
        LEA     RPO,[RPO+_CELLS(1)]
        _NEXT
_C
worddocsafe( {STACKS},{R@@},{r_fetch},{--- n},{ISO},
{Copy the top of the return stack to the data stack.},{{>R},{<R}},
{{." Via >R"},{Via >R}},
enddoc)
_HEADER({R@},{RR},{_VAR_FIELD(IDO)})
_C
worddoc( {LOGIC},{0=},{zero_equals},{n --- ff},{ISO,FIG},
{Leave a true flag forthvar({ff}) is the number forthvar({n})
is equal to zero, otherwise leave a false flag.
It may be aliased to forthcode({NOT}) , which inverts a flag.
},{{=},{0<}},
{ {0 0= .},{_T_},
  {  1 0= .},{0},
  {  -1 0= .},{0} },
enddoc)
CODE_HEADER({0=},{ZEQU})
        POP     AX
        NEG     AX
        CMC
        SBB     AX,AX
        _PUSH
_C
worddoc( {LOGIC},{0<},{zero_less},{n --- ff},{ISO,FIG},
{Leave a true flag if the number is less than zero (negative),
otherwise leave a false flag.},{{<},{0=}},
{ {0 0< .}, {0},
  {  1 0< .}, {0},
  {  -1 0< .}, {_T_} },
enddoc)
CODE_HEADER({0<},{ZLESS})
        POP     AX
        OR      AX,AX   _C{SET FLAGS}
        MOV     AX,0    _C{FALSE}
        JNS     ZLESS1
        DEC     AX      _C{TRUE}
ZLESS1: _PUSH
_C
worddoc( {OPERATOR},{+},{plus},{n1 n2 --- sum},{ISO,FIG},
{Leave the sum of forthvar({n1}) and forthvar({n2}) .},{{-},{*},{/},{MOD}},
{ { 0A BASE !  240 204 + .},{444} },
{}, enddoc)
CODE_HEADER({+},{PLUS})
        POP     AX      _C{(S1) <- (S1) + (S2)}
        POP     BX
        ADD     AX,BX
        _PUSH
_C
worddoc( {DOUBLE},{D+},{d_plus},{d1 d2 --- dsum},{ISO,FIG},
{Leave the double number forthvar({dsum}): the sum of two
double numbers forthvar({d1}) and forthvar({d2}) .},
{{DNEGATE},{+}},
{ { DECIMAL  240. 204. D+ D.},{444},
  { DECIMAL  -240. -204. D+ D.},{-444} },
enddoc)
CODE_HEADER({D+},{DPLUS})
        POP     AX      _C{ YHC}
        POP     DX      _C{ YLC}
        POP     BX      _C{ XHC}
        POP     CX      _C{ XLC}
        ADD     DX,CX   _C{ SLC}
        ADC     AX,BX   _C{ SHC}
        _2PUSH
_C
worddoc( {OPERATOR},{NEGATE},{negate},{n1 --- n2},{ISO,FIG},
{Leave the two's complement of a number, i.e.
 forthvar({n2}) is forthvar({-n1})},
{{-}},
{ {0 NEGATE .}, {0},
  {  1 NEGATE .}, {-1},
  {  -1 NEGATE .}, {1} },
enddoc)
CODE_HEADER({NEGATE},{NEGATE})
        POP     AX
        NEG     AX
        _PUSH
_C
worddoc( {DOUBLE},{DNEGATE},{d_negate},{d1 --- d2},{ISO},
{forthvar({d2}) is the negation of forthvar({d1}).
},{{D+}},
{ {0. DNEGATE D.}, {0},
  {  1. DNEGATE D.}, {-1},
  {  -1. DNEGATE D.}, {1} },
enddoc)
dnl What is more fundamental DNEGATE or D-?
CODE_HEADER({DNEGATE},{DNEGA})
        POP     BX
        POP     CX
        SUB     AX,AX
        MOV     DX,AX
        SUB     DX,CX   _C{ MAKE 2'S COMPLEMENT}
        SBB     AX,BX   _C{ HIGH CELL}
        _2PUSH
        PAGE
_C
worddoc( {JUGGLING},{OVER},{over},{nl n2 --- nl n2 n1},{ISO,FIG},
{Copy the second stack value, placing it as the new top.},
{{DUP}},
{{S0 @ DSP! 1 2 3 4 OVER .S},{
S[  1 2 3 4 3 ]},
{S0 @ DSP!},{} },
enddoc)
CODE_HEADER({OVER},{OVER})
        POP     DX
        POP     AX
        PUSH    AX
        _2PUSH
_C
worddoc( {JUGGLING},{DROP},{drop},{n ---},{ISO,FIG},
{Drop the number from the stack.},
{{DUP},{SWAP},{OVER}},
{{S0 @ DSP! 1 2 3 4 DROP .S},{S[  1 2 3 ]},
{S0 @ DSP!},{} },
enddoc)
CODE_HEADER({DROP},{DROP})
        POP     AX
        _NEXT
_C
worddoc( {JUGGLING},{NIP},{nip},{n1 n2---n2},{ISO},
{Drop the second number from the stack.},
{{DUP},{DROP},{SWAP},{OVER}},
{{S0 @ DSP! 1 2 3 4 NIP .S},{S[  1 2 4 ]},
{S0 @ DSP!},{} },
enddoc)
CODE_HEADER({NIP},{NIP})
        POP     AX
        POP     BX
        PUSH    AX
        _NEXT
_C
worddoc( {JUGGLING},{2DROP},{two_drop},{n1 n2 ---},{ISO},
{Drop the topmost two
numbers (or one double number)
 from the stack.},
{{DROP},{2DUP}},
{{S0 @ DSP! 1 2 3 4 2DROP .S},{
S[  1 2 ]},
{S0 @ DSP!},{} },
enddoc)
CODE_HEADER({2DROP},{TDROP})
        POP     AX
        POP     AX
        _NEXT
_C
worddoc( {JUGGLING},{SWAP},{swap},{n1 n2 --- n2 n1},{ISO,FIG},
{Exchange the top two values on the stack.},{{ROT}},
{{S0 @ DSP! 1 2 3 4 SWAP .S },{
S[  1 2 4 3 ]},
{S0 @ DSP!},{} },
enddoc)
CODE_HEADER({SWAP},{SWAP})
        POP     DX
        POP     AX
        _2PUSH
_C
worddoc( {JUGGLING},{DUP},{dup},{n --- n n},{ISO,FIG},
{Duplicate the value on the stack.},{{OVER},{SWAP},{DROP}},
{{S0 @ DSP! 1 2 3 4 DUP .S},{
S[  1 2 3 4 4 ]},
{S0 @ DSP!},{} },
enddoc)
CODE_HEADER({DUP},{LDUP})
        POP     AX
        PUSH    AX
        _PUSH
_C
worddoc( {JUGGLING},{2DUP},{two_dup},{d --- d d},{ISO},
{Duplicate the double number on the stack.},{{OVER}},
{{S0 @ DSP! 1 2 3 4 2DUP .S},{
S[  1 2 3 4 3 4 ]},
{S0 @ DSP!},{} },
enddoc)
CODE_HEADER({2DUP},{TDUP})
        POP     AX
        POP     DX
        PUSH    DX
        PUSH    AX
        _2PUSH
_C
worddoc( {JUGGLING},{2SWAP},{two_swap},{d1 d2 --- d2 d1},{ISO},
{Exchange the top doubles on the stack.},{{SWAP}},
{{S0 @ DSP! 1 2 3 4 2SWAP .S },{
S[  3 4 1 2 ]},
{S0 @ DSP!},{} },
enddoc)
CODE_HEADER({2SWAP},{TSWAP})
        POP     BX
        POP     CX
        POP     AX
        POP     DX
        PUSH     CX
        PUSH     BX
        _2PUSH
_C
worddoc( {JUGGLING},{2OVER},{two_over},{d1 d2 --- d1 d2 d1},{ISO},
{Copy the second stack double, placing it as the new top.},
{{OVER}},
{{S0 @ DSP! 1 2 3 4 2OVER .S},{
S[  1 2 3 4 1 2 ]} ,
{S0 @ DSP!},{} },
enddoc)
CODE_HEADER({2OVER},{TOVER})
        POP     BX
        POP     CX
        POP     AX
        POP     DX
        PUSH     DX
        PUSH     AX
        PUSH     CX
        PUSH     BX
        _2PUSH
_C
worddoc( {MEMORY},{+!},{plus_store},{n addr ---},{ISO,FIG},
{ Add forthvar({n}) to the value at forthvar({addr}).},
{{TOGGLE},{!}},
{{0 PAD ! 1 PAD +! PAD @ .},{1},
 {1 PAD ! -1 PAD +! PAD @ .},{0} },
enddoc)
CODE_HEADER({+!},{PSTOR})
        POP     BX      _C{ADDRESS}
        POP     AX      _C{INCREMENT}
        ADD     [BX],AX
        _NEXT
_C
worddoc( {MEMORY},{TOGGLE},{toggle},{addr b ---},{NFIG},
{Complement the contents of forthvar({addr}) by the bit pattern
forthvar({b}) .},
{{XOR},{+!} },
{{0 PAD ! PAD 1 TOGGLE PAD @ .},{1},
 {1 PAD ! PAD 1 TOGGLE PAD @ .},{0} },
enddoc)
CODE_HEADER({TOGGLE},{TOGGL})
        POP     AX      _C{BIT PATTERN}
        POP     BX      _C{ADDR}
        XOR     [BX],AX _C
        _NEXT
_C
worddocsafe( {MEMORY},{@@},{fetch},{addr --- n},{ISO,FIG},
{Leave the _BITS_ bit contents forthvar({n})
of forthvar({addr}) .},
{{!},{C@@},{2@@},{PW@@},{PC@@},{FAR@@}},
{ {-23 PAD ! PAD @ .},{-23} },
enddoc)
CODE_HEADER({@},{FETCH})
        POP     BX
        MOV     AX,[BX]
        _PUSH
_C
_BITS64_({
worddocsafe( {MEMORY},{L@@},{long_fetch},{addr --- u},{ISO,FIG},
{Leave the 32 bit contents forthvar({u})
of forthvar({addr}) .},
{{!},{C@@},{2@@},{PW@@},{PC@@},{FAR@@}},
{ {-23 PAD L! PAD L@ .},{FFFFFFDD} },
enddoc)
CODE_HEADER({L@},{LFETCH})
        POP     BX
        XOR     AX,AX
        MOV     _AX32,[BX]
        _PUSH
_C
})_C{}_END_({_BITS64_})
worddocsafe( {MEMORY},{C@@},{c_fetch},{addr --- b},{ISO},
{Leave the 8 bit contents of memory address.
In ciforth , running on the Intel architectures
there are no restrictions regarding byte
addressing.
},{{C!},{@@},{2@@}},
{ {-23 PAD C! PAD C@ .},{DD} },
enddoc)
CODE_HEADER({C@},{CFET})
        POP     BX
        XOR     AX,AX
        MOV     AL,[BX]
        _PUSH
_C
worddocsafe( {MEMORY},{2@@},{two_fetch},{addr--- x1 x2},{ISO},
{Leave a pair of _BITS_ bits values forthvar({x1}) forthvar({x2}) from
consecutive cells at forthvar({addr}) . forthvar({x2}) is fetched from
the lowest address. },{{2!},{@@},{C@@}},
{ {-23. PAD 2! PAD 2@ D.},{-23} },
enddoc)
CODE_HEADER({2@},{TFET})
        POP     BX      _C{ADDR}
        MOV     AX,[BX] _C{MSW}
        MOV     DX,[BX+_CELLS(1)]        _C{LSW}
        _2PUSH
_C
worddoc( {MEMORY},{!},{store},{n addr ---},{ISO,FIG},
{Store all _BITS_ bits of n at forthvar({addr}) .},
{{@@},{C!},{2!},{FAR!},{PW!},{PC!}},
{{." Via @"},{Via @}},
enddoc)
CODE_HEADER({!},{STOR})
        POP     BX      _C{ADDR}
        POP     AX      _C{DATA}
        MOV     [BX],AX
        _NEXT
_C
_BITS64_({
worddocsafe( {MEMORY},{L!},{long_store},{u addr --- },{},
{Store the 32-bit contents of forthvar({u}) at forthvar({addr}) .},
{{L@@},{!},{C!},{2!},{PW!},{PC!},{FAR!}},
{ {-23 PAD L! PAD L@ .},{FFFFFFDD} },
enddoc)
CODE_HEADER({L!},{LSTOR})
        POP     BX      _C{ADDR}
        POP     AX      _C{DATA}
        MOV     [BX],_AX32
        _NEXT
_C
})_C{}_END_({_BITS64_})
worddoc( {MEMORY},{C!},{c_store},{b addr ---},{ISO},
{Store 8 bits of forthvar({b}) at forthvar({addr}) .
In ciforth , running on the Intel architectures
there are no restrictions regarding byte
addressing.
},{{C@@},{!}},
{{." Via C@"},{Via C@}},
enddoc)
CODE_HEADER({C!},{CSTOR})
        POP     BX      _C{ADDR}
        POP     AX      _C{DATA}
        MOV     [BX],AL
        _NEXT
_C
worddoc( {MEMORY},{2!},{two_store},{x1 x2 addr --- },{ISO},
{Store a pair of _BITS_ bits values forthvar({x1})
forthvar({x2}) to consecutive cells at forthvar({addr}) .
forthvar({x2}) is stored at the lowest address.
},{{2@@},{!},{C!}},
{{." Via 2@"},{Via 2@}},
enddoc)
CODE_HEADER({2!},{TSTOR})
        POP     BX      _C{ADDR}
        POP     AX      _C{MSW}
        MOV     [BX],AX
        POP     AX      _C{LSW}
        MOV     [BX+_CELLS(1)],AX
        _NEXT
_C
worddoc( {MEMORY},{WITHIN},{within},{n1 n2 n3 --- ff},{ISO},
{Return a flag indicating that forthvar({n1}) is in
the range forthvar({n2}) (inclusive)
to forthvar({n3}) (non-inclusive).
This works for signed as well as unsigned numbers.
This is shorthand for: forthsamp({OVER - >R - R U<}) },
{{<},{U<}},
{{ 1 1 3 WITHIN .},{_T_},
{ 2 1 3 WITHIN .},{_T_},
{ 3 1 3 WITHIN .},{0},
{ 4 1 3 WITHIN .},{0}}, enddoc)
_HEADER({WITHIN},{WITHIN}, {DOCOL})
        DC      OVER, LSUB, TOR
        DC      LSUB, FROMR
        DC      ULESS
        DC      SEMIS
_C
_BITS64_(,{
worddocsafe( {MEMORY},{FAR@@},{far_fetch},{faraddr --- u},{},
{Leave the _BITS_ bit contents forthvar({u}) of
segment address pair forthvar({faraddr}).
},
{{FAR!},{@@},{C@@},{2@@}},
{{." No test"},{No test} },
enddoc)
CODE_HEADER({FAR@},{LFET})
_BITS16_({
        POP     BX      _C{Offset}
        POP     CX      _C{Segment}
_BITS16_({_SWITCH_({ JMPHERE_FROM_PROT},{dnl})},{dnl})
        MOV     _DX16,DS
        MOV     DS,CX
        MOV     BX,[BX]
        MOV     DS,_DX16
_BITS16_({_SWITCH_({ JMPHERE_FROM_REAL},{dnl})},{dnl})
        PUSH    BX
})_C{}_END_({_BITS16_})
_BITS32_({
        POP     BX      _C{MEM LOC}
        MOV     _DX16,FS
        POP     FS      _C{SEG REG VAL}
        MOV     BX,_FAR_ADDRESS(FS,BX)
        MOV     FS,_DX16
        PUSH    BX
        _NEXT
})_C{}_END_({_BITS32_})
        _NEXT
_C
worddoc( {MEMORY},{FAR!},{far_store},{u faraddr ---},{},
{Store _BITS_ bits of forthvar({u}) at segment address pair
forthvar({faraddr}).
},
{{FAR@@},{!},{C!},{2!}},
{{." No test"},{No test} },
enddoc)
CODE_HEADER({FAR!},{LSTOR})
_BITS16_({
        POP     BX
        POP     CX
        POP     DX
_BITS16_({_SWITCH_({ JMPHERE_FROM_PROT},{dnl})},{dnl})
        MOV     AX,DS
        MOV     DS,CX
        MOV     [BX],DX
        MOV     DS,AX
_BITS16_({_SWITCH_({ JMPHERE_FROM_REAL},{dnl})},{dnl})
        _NEXT
})_C{}_END_({_BITS16_})
_BITS32_({
        POP     BX
        MOV     _DX16,FS
        POP     FS      _C{SEG REG VAL}
        POP     AX
        MOV     _FAR_ADDRESS(FS,BX),AX
        MOV     FS,_DX16
        _NEXT
})_C{}_END_({_BITS32_})
})_C{}_END_({_BITS64_})
_C
worddoc( {DEFINING},{colon},{colon},{},{ISO,FIG,E},
{Used in the form called a colon-definition:
forthexample({: cccc     ...     ;})
Creates a dictionary entry defining forthsamp({cccc}) as equivalent to the
following sequence of Forth word definitions '...' until the next
forthcode({';'}) or forthcode({';CODE'}). The word is added as the latest
into the forthcode({CURRENT}) word list.
The compiling process is done by the text interpreter as long as
forthcode({STATE}) is non-zero.
Words with the forthdefi({immediate}) bit set, attribute forthvar({I}),
are executed rather than being compiled.},{{(CREATE)}},
{{: GS1 1 2 3 ; GS1 . . .},{3 2 1} },
enddoc)
_HEADER({:},{COLON},{DOCOL})
        _SECURITY_({DC      SCSP})
        DC      LNAME
        DC      PCREAT
        DC      LATEST, HIDDEN
        DC      RBRAC
        DC      PSCOD
DOCOL:  LEA     RPO,[RPO - _CELLS(1)]  _C{Push HIP}
        MOV     [RPO],HIP _C{R1 <- (IP)}
         MOV     HIP,[WOR+_CELLS(D_HOFFSET - C_HOFFSET)]  _C{(IP) <- (PFA)}
_C{        CALL    DISPLAYSI}
_SWITCH_({
        _SWITCH_({JMPHERE_FROM_FORTH})
        _C{ Allow interrupts to happen.}
        _SWITCH_({JMPHERE_FROM_OS})
})_C{}_END_({ _SWITCH_})
        _NEXT
_C
worddoc( {DEFINING},{;},{semicolon},{},{ISO,FIG,I,C},
{Terminate a colon-definition and stop further compilation. Compiles
the run-time forthcode({(;)}) .},{{:}},
{{." Via :"},{Via :}},
enddoc)
_HEADER({;},{SEMI},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      QCSP})
        DC      LIT, SEMIS, COMMA
        DC      LATEST, HIDDEN
        DC      LBRAC
        DC      SEMIS
_C
worddoc( {DEFINING},{CONSTANT},{constant},{n ---},{ISO,FIG},
{A defining word used in the form:
    forthvar({n}) forthcode({CONSTANT}) forthsamp({cccc})
to create word forthsamp({cccc}) ,
where the content of its forthdefi({data field address}) is forthvar({n}) .
When forthsamp({cccc}) is later executed, it
will push the value of forthvar({n}) to the stack.},
{{VARIABLE},{>DFA}},
{{12A CONSTANT FRED FRED .},{12A} },
enddoc)
_HEADER({CONSTANT},{LCONST},{DOCOL})
        DC      LNAME
        DC      PCREAT
        DC      LATEST, TDFA, STOR
        DC      PSCOD
DOCON:  MOV     AX,[WOR+_CELLS((D_HOFFSET))] _C{GET DATA FROM PFA}
        _PUSH
_C
worddoc( {DEFINING},{VARIABLE},{variable},{},{ISO,FIG},
{A defining word used in the form:
                 forthsamp({VARIABLE cccc})
When forthcode({VARIABLE}) is executed,
it creates the definition forthsamp({cccc})
whose forthdefi({data field address}) contains a
pointer forthsamp({n}) to a data location,
that can contain one cell.
When forthsamp({cccc}) is later executed,
this pointer forthsamp({n}) is left on the stack,
so that a fetch or store may access this location.},
{{USER},{CONSTANT},{>DFA},{DATA}},
{{ VARIABLE APE 1A34 APE ! APE @ .},{1A34} },
enddoc)
_HEADER({VARIABLE},{VAR},{DOCOL})
        DC      LDATA
        DC      ZERO, COMMA
        DC      SEMIS
_C
worddoc( {DEFINING},{DATA},{data},{},{},
{A defining word used in the form:
                 forthsamp({DATA cccc})
When forthcode({DATA}) is executed,
it creates the definition forthsamp({cccc})
whose forthdefi({data field address}) contains a
pointer forthsamp({n}) to forthcode({HERE}).
_VERBOSE_({{This code is typically followed by some data
allocation word like forthcode({ALLOT}) or forthcode({{{{,}}}}) .
forthcode({DOES>}) must not be used with forthsamp({cccc}).
}})
When forthsamp({cccc}) is later executed,
this pointer forthsamp({n}) is left on the stack,
so that data can be accessed.},
{{VARIABLE},{CREATE},{>DFA}},
{{ DATA APE 1A34 , APE @ .},{1A34} },
enddoc)
_HEADER({DATA},{LDATA},{DOCOL})
        DC      LNAME
        DC      PCREAT
        DC      PSCOD
DOVAR:  MOV     AX,[WOR+_CELLS((D_HOFFSET))] _C{(AX) <- PFA}
        _PUSH
_C
worddoc( {DEFINING},{USER},{user},{n ---},{ISO},
{A defining word used in the form:
               forthsamp({n USER cccc})
which creates a user variable forthsamp({cccc}) . The data
field of forthsamp({cccc}) contains forthvar({n}) as a
byte offset relative to the user pointer register forthsamp({UP})
for this user variable. When forthsamp({cccc}) is later
executed, it places the sum of its offset and the user area
base address on the stack as the storage address of that
particular variable.
_THREADS_(
{{In this ciforth forthsamp({UP}) is coupled to the return stack.
This means that with a switch of the return stack{,}
forthsamp({UP}) is switched also automatically.}},
{{In this ciforth the forthsamp({UP}) is to be found at
forthsamp({0 +ORIGIN}).
}})
forthcode({CONTEXT}) is the last user variable at offset 38 CELLS,
such that new user variables may be allocated using offsets of
38+M4_MAXWORDLIST CELLS and up.
It is best to do
  forthsamp({MAX-USER @@ DUP USER cccc    CELL+ MAX-USER ! })
reflecting the current allocation in the user area.
},
{{VARIABLE},{+ORIGIN},{CONTEXT},{>DFA}},
{{ 0 USER APE 1A34 APE ! APE @ .},{1A34} },
enddoc)
_HEADER({USER},{USER},{DOCOL})
        DC      LCONST
        DC      PSCOD
DOUSE:  MOV     BX,[WOR+_CELLS((D_HOFFSET))] _C{PFA  }
_THREADS_(
{       MOV     AX, BP
        OR      AX, _OFFSET STACKSIZE-1  _C{Requires it is power of 2.}
        INC     AX
},
{        MOV     AX,_CELL_PTR[USINI]
})dnl _END_({_THREADS_})
        ADD     AX,BX      _C{ADDR OF VARIABLE}
        _PUSH
_C
_C
worddoc( {MISC},{_},{do_not_care},{--- x},{},
{Leave an undefined value forthvar({x}).
_VERBOSE_({{Presumably it is to be dropped at some time, or it is a place holder.}})
},{},
{{123475 _ DROP . },{123475}},
enddoc)
CODE_HEADER({_},{X})
        _PUSH _C{Whatever happens to be in }AX{, i.e. the dea of ``_''.}
_C
worddoc( {SUPERFLUOUS},{0},{zero},{--- 0},{},
{Leave the number 0. },{{CONSTANT}},
{{0 .},{0}},
enddoc)
_HEADER({0},{ZERO},{DOCON},0)
_C{ The data field of 0 is used for an empty string.}
_C
worddoc( {SUPERFLUOUS},{Number_1},{one},{--- 1},{},
{Leave the number 1. },{{CONSTANT}},
{{1 .},{1}},
enddoc)
_HEADER({1},{ONE},{DOCON},1)
_C
worddoc( {SUPERFLUOUS},{Number_2},{two},{--- 2},{},
{Leave the number 2. },{{CONSTANT}},
{{2 .},{2}},
enddoc)
_HEADER({2},{TWO},{DOCON},2)
_C
worddoc( {STRING},{BL},{BL},{--- c},{ISO.FIG},
{ A constant that leaves the
   ASCII value for "blank".},{},
{{BL .},{20}},
enddoc)
_HEADER({BL},{LBL},{DOCON}, ABL)
_C
worddocsafe( {STRING},{$@@},{string_fetch},{addr --- sc},{},
{ From address forthvar({addr}) fetch a forthdefin({string constant}) forthvar({sc}) .
This is similar to forthcode({COUNT}) with a cell-length instead of a char-length.
},
{{$!},{$+!},{$C+}},
{{ HEX 4 , 41 C, 39 C, 45 C, 30 C, HERE 4 CELL+ - $@ TYPE},{A9E0}}, enddoc)
_C
CODE_HEADER({$@},{SFET})
        POP   BX
        MOV   AX,[BX]
        LEA   DX, [BX+_CELLS(1)]
        _2PUSH
_C
worddoc( {STRING},{$!},{string_store},{sc addr ---},{},
{Store a forthdefin({string constant}) forthvar({sc})
in the string variable at address forthvar({addr}).},
{{$@@},{$+!},{$C+}},
{{ HEX 2 , 41 C, 39 C, HERE 2 CELL+ - $@ PAD $! PAD $@ TYPE},{A9}}, enddoc)
_HEADER({$!},{SSTOR},{DOCOL})
        DC TDUP, STOR, CELLP, SWAP, LMOVE
        DC SEMIS
_C
worddoc( {STRING},{$!-BD},{string_store_brain_damaged},{sc addr ---},{WANT},
{Store a forthdefin({string constant}) forthvar({sc}) in the
forthdefi({old fashioned string}) variable at address
forthvar({addr}), i.e. it can be fetched with
forthcode({COUNT}). _VERBOSE_({{ (Where would that BD come
from?)}})},
{{COUNT},{$!}},
{{ 1 LOAD  "$!-BD" WANTED "A9" PAD $!-BD PAD COUNT TYPE},{A9}}, enddoc)
_SUPPRESSED({{
_HEADER({$!-BD},{SSTORBD},{DOCOL})
        DC TDUP, CSTOR, ONEP, SWAP, LMOVE
        DC SEMIS
_C
}})_C{}_END_({ _SUPPRESSED})
worddoc( {STRING},{$+!},{string_append},{sc addr ---},{},
{Append a forthdefin({string constant}) forthvar({sc})
to the string variable at address forthvar({addr}).},
{{$@@},{$!},{$C+}},
{{ HEX 2 , 41 C, 39 C, HERE 2 CELL+ - dnl
$@ 2DUP PAD $! PAD $+! PAD $@ TYPE},{A9A9}}, enddoc)
_HEADER({$+!},{SADD},{DOCOL})
        DC   LDUP, FETCH, TOR _C{ Remember old count.}
        DC   TDUP, PSTOR
        DC   CELLP, FROMR, PLUS, SWAP, LMOVE
        DC SEMIS
_C
worddoc( {STRING},{$C+},{char_append},{c addr ---},{},
{Append a char forthvar({c})
to the string variable at address forthvar({addr}).},
{{$!},{$+!},{&},{^},{CHAR}},
{{ HEX 2 , 41 C, 39 C, HERE 2 CELL+ -  dnl
$@ PAD $! HERE 1 - C@ PAD $C+ PAD $@ TYPE},{A99}}, enddoc)
_HEADER({$C+},{CHAPP},{DOCOL})
        DC   LDUP, TOR
        DC   LDUP, FETCH, PLUS, CELLP, CSTOR
        DC   ONE, FROMR, PSTOR
        DC SEMIS
_C
worddocsafe( {STRING},{$,},{string_comma},{sc --- addr},{},
{Allocate and store a forthdefin({string constant}) forthvar({sc})
in the dictionary and leave its address forthvar({addr}).},
{{$@@},{$!},{}},
{{ HEX 2 , 41 C, 39 C, HERE 2 CELL+ - $@ $, $@ TYPE},{A9}}, enddoc)
_HEADER({$,},{SCOMMA},{DOCOL})
        DC HERE, TOR
        DC LDUP, CELLP, ALLOT
        DC RR, SSTOR, FROMR
_ALIGNED_({ DC LALIGN}, {dnl})
        DC SEMIS
_C
worddoc( {SCREEN},{C/L},{char_per_line},{--- c},{},
{A constant that leaves the number of characters on a line of a
standard screen: 64. The last character of each line is a forthkey({LF}). },
{{LIST},{LINE}},
{{C/L .},{40}},
enddoc)
_HEADER({C/L},{CSLL},{DOCON}, 64)
_C
_HIGH_BUF_({
worddoc( {BLOCKS~},{_FIRST},{first},{--- addr1},{},
{A constant that leaves the address of the block
buffer lowest in memory. },
{{BLOCK},{_LIMIT}},
{{_LIMIT _FIRST - B/BUF 2 CELLS + /MOD #BUFF = . .},{_T_ 0}},
enddoc)
_HEADER({_FIRST},{_FIRST},{DOCON}, BUF1)
})_C{}_END_({ _HIGH_BUF_})
_C
_LOW_BUF_({
        _ALIGN(2)       _C{ Otherwise INT 13 hangs when filling}
        _C{ in into the lba block as a buffer address.}
        DB      0       _C{Padding the odd # of bytes in the name FIRST.}
worddoc( {BLOCKS~},{_FIRST},{first},{--- n},{},
{A constant that leaves the address of the block
buffer lowest in memory.
This is allocated in the lowest 1 Megabyte of memory,
to allow the BIOS to access it.
},{{BLOCK},{_LIMIT}},
{{_LIMIT _FIRST - B/BUF 2 CELLS + /MOD DROP #BUFF = .},{_T_}},
enddoc)
_HEADER({_FIRST},{_FIRST},{DOVAR}, BUF1)
BUF1:   _RESB( (KBBUF+2*CW)*NBUF )
})_C{}_END_({ _LOW_BUF_})
_C
worddoc( {BLOCKS~},{_LIMIT},{limit},{---- addr1},{},
{A constant leaving the address just above the highest memory
available for a disc buffer.
_HIGH_BUF_({Actually this is the highest system memory.})
},{{BLOCK},{_FIRST}},
{{." See _FIRST"},{See _FIRST}},
enddoc)
_HEADER({_LIMIT},{_LIMIT},{DOCON}, BUF1+(KBBUF+2*CW)*NBUF)
_C{ THE END  OF THE MEMORY }
worddoc( {MEMORY},{EM},{end_memory},{---- addr},{},
{A constant leaving the address just above the highest memory
in use by Forth.
},{{DP},{BM}},
{{." See _FIRST"},{See _FIRST}},
enddoc)
_HEADER({EM},{LEM},{DOCON}, ACTUAL_EM)
_C
worddoc( {MEMORY},{BM},{begin_memory},{---- addr},{},
{A constant leaving the address of the lowest memory
in use by Forth.
},{{DP},{EM}},
{{." No test"},{No test} },
enddoc)
_HEADER({BM},{LBM},{DOCON}, _ORIG)
_C
_THREADS_({
worddoc( {MEMORY},{TASK-SIZE},{task_size},{---- n},{},
{A constant leaving the total size of the per task areas:
data stack, return stack, terminal input buffer plus
user area.
The data stack of the main task runs down to forthcode({HERE}) .
},{{DSP@@},{RSP@@},{TIB}},
{{TASK-SIZE . ." one bit up"},{10000 one bit up} },
enddoc)
_HEADER({TASK-SIZE},{LTAS},{DOCON}, TAS)
_C
})dnl{}_END_({_THREADS_})
worddoc( {BLOCKS},{B/BUF},{bytes_per_buf},{--- n},{},
{This constant leaves the number of bytes per disc buffer, the byte
count read from disc by forthcode({BLOCK}) .
The ISO standard fixes this to 1024.},{{(BUFFER)}},
{{B/BUF .},{400}},
enddoc)
_HEADER({B/BUF},{BBUF},{DOCON}, KBBUF)
_C
_C{ All user variables are initialised }
_C{ with the values from USINI.}
_C{ The implementation relies on the initialisation of }
_C{ those with numbers (1..11), so change in concord with USINI.}
worddoc( {MISC},{U0},{u_zero},{--- addr},{},
{A user variable, leaving the start address of the user area. This is
for reference only.
_THREADS_({After initialisation user variables derive their start address
from the return stack pointer.},
{ What is taken into account by user variables is
the initialisation variable at forthsamp({0 +ORIGIN}) .})
_VERBOSE_({{This might be used for task switching.}})
},
{{USER},{+ORIGIN}},
{{U0 @ 0 +ORIGIN @ = .},{_T_}},
enddoc)
_HEADER({U0},{UZERO},{DOUSE}, _CELLS(1))
_C
worddoc( {STACKS},{S0},{s_zero},{--- addr},{U},
{A user variable that contains the initial value for the data stack
pointer.},{{DSP!}},
{{." See DSP@"},{See DSP@}},
enddoc)
_HEADER({S0},{SZERO},{DOUSE}, _CELLS(2))
_C
worddoc( {STACKS},{R0},{r_zero},{--- addr},{U},
{A user variable containing the initial location of the return stack. },
{{RSP!}},
{{." See RSP@"},{See RSP@}},
enddoc)
_HEADER({R0},{RZERO},{DOUSE}, _CELLS(3))
_C
worddoc( {INPUT},{TIB},{t_i_b},{--- addr},{ISO,FIG,U},
{A user variable containing the address of the terminal input buffer.
_VERBOSE_({Traditionally{,} this was used for file i/o too{,} but not so in
ciforth.})
},
{{QUIT}},
{{." See SRC"},{See SRC}},
enddoc)
_HEADER({TIB},{TIB},{DOUSE}, _CELLS(4))
_C
worddoc( {INPUT},{RUBOUT},{rub_out},{--- c},{},
{A user variable, leaving the key code that must delete the
last character from the input buffer.
_HOSTED_({{In this ciforth it is not used, as the terminal input
editing is left to the host operating system.}})
},{{USER}},
{{." interactive"},{interactive}},
enddoc)
_HEADER({RUBOUT},{RUBOUT},{DOUSE}, _CELLS(5))
_C
worddoc( {ERRORS},{WARNING},{warning},{--- addr},{FIG,U},
{A user variable containing a value controlling messages.
If it is 1,
a library file is assumed to be open,
and messages are fetched from it.
If it is 0,
error messages will be presented by number only.
},
{{MESSAGE},{ERROR},{ERRSCR}},
{{." See MESSAGE"},{See MESSAGE}},
enddoc)
_HEADER({WARNING},{LWARN},{DOUSE}, _CELLS(7))
_C
worddoc( {DICTIONARY~},{FENCE},{fence},{---  addr},{FIG,U},
{A user variable containing an address below which forthcode({FORGET}) ting is
trapped. To forget below this point the user must alter the contents
of forthcode({FENCE}) .},{},
{{." interactive"},{interactive}},
enddoc)
_HEADER({FENCE},{FENCE},{DOUSE}, _CELLS(8))
_C
worddoc( {DICTIONARY},{DP},{d_P},{---- addr},{FIG,U,L},
{A user variable, the forthdefi({dictionary pointer}), which contains the address
of the next free memory above the dictionary. The value may be read
by forthcode({HERE}) and altered by forthcode({ALLOT}) .},{},
{{HERE DP @ = .},{_T_}},
enddoc)
_HEADER({DP},{LDP},{DOUSE}, _CELLS(9))
_C
worddoc( {WORDLISTS~},{VOC-LINK},{voc_link},{--- addr},{U},
{A user variable containing the forthdefi({dictionary entry
address}) of the word most recently created by
forthcode({NAMESPACE}) . _VERBOSE_({{All namespace names are
linked by these fields to allow }forthcode({FORGET}){ to find all
vocabularies.}})},
{{NAMESPACE}},
{{VOC-LINK @ ' ENVIRONMENT = .},{_T_}},
enddoc)
_HEADER({VOC-LINK},{VOCL},{DOUSE}, _CELLS(10))
_C
worddoc( {DEFINING},{MAX-USER},{max_user},{--- addr},{U},
{A user variable which contains the part of the
area for user variables, that is in use.
It is measured in bytes from the start of the user area. },
{{BLOCK},{MESSAGE},{U0}},
{{MAX-USER @ 1000 U< .},{_T_}},
enddoc)
_HEADER({MAX-USER},{MAXUSER},{DOUSE}, _CELLS(11))
_C
_C
_C
worddoc( {ERRORS},{WHERE},{where},{--- addr},{U},
{A user variable pair which contains the start of the source and the
position after the last character parsed when an error thrown by
forthcode({?ERROR})_VERBOSE_({{, so not of exceptions thrown}}).
The contents of forthcode({WHERE}) is interpreted by
forthcode({ERROR}) if the corresponding exception was never
caught. },
{{THROW},{CATCH} },
{{"1 12 ?ERROR" 2DUP 'EVALUATE CATCH DROP 2DROP + WHERE 2@ DROP = .},{_T_}},
enddoc)
_HEADER({WHERE},{LWHERE},{DOUSE}, _CELLS(12))    _C{  Occupies two CELLS! }
_C
worddoc( {SCREEN},{SCR},{s_c_r},{--- addr},{U},
{A user variable containing the screen number most recently reference
by forthcode({LIST}) .},{{BLOCK}},
{{." interactive"},{interactive}},
enddoc)
_HEADER({SCR},{SCR},{DOUSE}, _CELLS(33))
_C
worddoc( {PARSING},{STATE},{state},{--- addr},{ISO,U},
{A user variable containing the compilation state. A non-zero value
indicates compilation.
In ciforth it then contains 1.},
{{[},{]}},
{{STATE @ .},{0},
{ : GT8 STATE @ 0= . ; IMMEDIATE : GT7 GT8 ; GT7},{0}},
enddoc)
_HEADER({STATE},{STATE},{DOUSE}, _CELLS(18))
_C
worddoc( {FORMATTING},{BASE},{base},{--- addr},{ISO,FIG,U},
{A forthdefi({user variable}) containing the current number base used for input
and output conversion.},
{{DECIMAL},{HEX},{<#}},
{{DECIMAL BASE @ 16 BASE ! .},{A}},
enddoc)
_HEADER({BASE},{BASE},{DOUSE}, _CELLS(19))
_C
worddoc( {FORMATTING~},{DPL},{d_p_l},{---- addr},{FIG,U},
{A user variable containing the address of the decimal point on
double integer or floating point input, or a forthdefin({nil pointer}).
},
{{<#},{FLD},{HLD}},
{{1234.56 DPL @ 0= . 2DROP},{0}},
enddoc)
_HEADER({DPL},{DPL},{DOUSE}, _CELLS(20))
_C
worddoc( {FORMATTING~},{FLD},{f_l_d},{--- addr},{FIG,U},
{A user variable for control of number output field width.
Unused in the kernel of ciforth.},
{},
{{." No test"},{No test} },
enddoc)
_HEADER({FLD},{LFLD},{DOUSE}, _CELLS(21))
_C
_SECURITY_({
worddoc( {SECURITY},{CSP},{c_s_p},{---- addr},{U},
{A user variable temporarily storing the stack pointer position, for
compilation error checking.},{},
{{1256 CSP ! CSP @ .},{1256}},
enddoc)
_HEADER({CSP},{LCSP},{DOUSE}, _CELLS(22))
_C
})_C{}_END_({_SECURITY_})
worddoc( {SCREEN},{R#},{r_hash},{--- addr},{U},
{A user variable which may contain the location of an editing cursor,
or other file related function.
Unused in the kernel of ciforth.},
{},
{{." No test"},{No test} },
enddoc)
_HEADER({R#},{RNUM},{DOUSE}, _CELLS(23))
_C
worddoc( {FORMATTING~},{HLD},{hld},{--- addr},{FIG},
{A user variable that holds the address of the latest character of
text during numeric output conversion.},
{{<#},{DPL},{FLD},{HOLD}},
{{." No test"},{No test} },
enddoc)
_HEADER({HLD},{HLD},{DOUSE}, _CELLS(24))
_C
dnl This can really be used to prevent lines from overflowing. Keep it.
worddoc( {OUTPUT},{OUT},{OUT},{--- addr},{U},
{A user variable that reflects the position at the current line
of the output device where the next character transmitted will
appear. The first position is zero. Only an explicit
forthcode({CR}) will reset forthcode({OUT}) , not an
forthkey(LF) embedded in a string that is forthcode({TYPE})d.},
{{EMIT},{TYPE},{CR}},
{{41 EMIT 42 EMIT OUT @ .},{AB2}},
enddoc)
_HEADER({OUT},{LOUT},{DOUSE}, _CELLS(25))
_C
worddocsafe( {SCREEN~},{(BLK)},{paren_blk},{--- addr},{U},
{When the standard word forthcode({BLK}) is used, this user variable
reflects the state of the forthdefi({current input source}).
It indicates the block number being interpreted, or
zero, if input is being taken from the terminal input buffer.
Changing forthcode({BLK}) has no effect, and its content must be fetched before
the forthdefi({current input source}) has changed.},
{{BLOCK},{TIB}},
{{BLK (BLK) @ . ?},{0 0}},
enddoc)
_HEADER({(BLK)},{PBLK},{DOUSE}, _CELLS(26))
_C
worddoc( {INPUT},{PP},{parse_pointer},{--- addr},{},
{A user variable containing a pointer within the current input
text buffer (terminal or disc) from which the next text will be
accepted. All parsing words use and move the value of forthcode({PP}) .
This is different from how ISO forthcode({>IN}) works,
in the sense that zeroing it
doesn't reset the parse pointer to the start of the current line.
},
{{(>IN)},{WORD},{NAME},{NUMBER},{PARSE},{PP@@@@}},
{{: GS1 PP @ PP@@ 2DROP PP @ - ; GS1 Q .},{-1}},
enddoc)
_HEADER({PP},{PP},{DOUSE}, _CELLS(29))
_C
_LOAD_({
worddocsafe( {INPUT~},{(>IN)},{paren_iso_in},{--- addr},{},
{This is a user variable that is foreseen for code that fakes
the behaviour of forthcode({>IN}) in ciforth.
This could be part of the code loaded by forthsamp({ "-legacy-" WANTED }) .
(The word forthcode({>IN}) is intended to be used in the context that the source is
interpreted line by line.)
In ciforth the parse pointer forthcode({PP}) is used by the system instead of
 forthcode({>IN}) .
},
{{>IN},{PP}},
{{." See >IN"},{See >IN}},
enddoc)
_HEADER({(>IN)},{PIIN},{DOUSE}, _CELLS(30))
_C
})_C{}_END_({_LOAD_})
worddoc( {OPERATINGSYSTEM},{ARGS},{arguments},{--- addr},{},
{ Return the addr of forthcode({ARGS}) a user variable that
contains a system dependant pointer to any arguments that are
passed from the operating system to ciforth during startup.
_HOSTED_X_({{
In this ciforth it points to an area with the argument count,
followed by a null ended array of arguments c-strings,
then by a null ended array of environment c-strings.
C-string are chars followed by a zero byte and no preceeding count.
}})
_PC_({{
In this ciforth it contains the real segment descriptor of the
``environment-block''_HOSTED_DPMI_({,which is real hard to come
by in protected mode}).
_VERBOSE_({{The arguments passed to the program, ``command tail''
is available as a }forthdefi({brain damaged string}){ at address 0x80.}})
}})
_DLL_({{
In this ciforth it contains a pointer to a zero ended string
with the command line.
_VERBOSE_({{The operating system doesn't help to separate the arguments,
so beware of blank space.}})
}})
},
{{SYSTEM}},
{{." Interactive"},{Interactive}},
enddoc)
_HEADER({ARGS},{ARGS},{DOUSE}, _CELLS(31))
_C
worddoc( {ERRORS~},{HANDLER},{handler},{--- addr},{},
{A user variable address containing a pointer to the
last exception intercepting frame activated by forthcode({CATCH}) .
It points into the return stack.
If there is a forthcode({THROW}), the return stack
is restored from forthcode({HANDLER}) effecting a multiple level return.
It is called a frame because more things are restored, such as the
position of the data stack top, and the previous value of forthcode({HANDLER}) .},
{{CATCH},{THROW}},
{{." See CATCH"},{See CATCH}},
enddoc)
_HEADER({HANDLER},{HANDLER},{DOUSE}, _CELLS(32))
_C
worddoc( {WORDLISTS},{CURRENT},{current},{--- addr},{FIG,U},
{A user variable containing the WID of a namespace to which
new words will be added.
It is
the forthdefi({compilation word list}) in the sense of the ISO
standard.
_VERBOSE_({{The WID has the structure of a }forthdefi({dictionary entry}){.
This allows to link in a new word between the
link field of the WID and the next definition.}})
},
{{NAMESPACE},{CONTEXT}},
{{CURRENT @ ' FORTH >WID = .},{_T_}},
enddoc)
_HEADER({CURRENT},{CURR},{DOUSE}, _CELLS(34))
_C
worddoc( {INPUT~},{REMAINDER},{remainder},{--- addr},{},
{A pointer to a constant string that contains the balance of
characters fetched from the the input stream,
but not yet part of the input buffer.
Unless there is redirection from a file,
this contains an empty string.
Used as in forthsamp({REMAINDER 2@@}) .
},
{{REFILL-TIB}},
{{REMAINDER 2@ DROP TIB @ R0 @ WITHIN .},{_T_}},
enddoc)
_HEADER({REMAINDER},{REMAIND},{DOUSE}, _CELLS(14))
_C{      IMPORTANT}
_C{ REQUIRES ONE MORE CELL!}
_C
_C
worddoc( {BLOCKS~},{OFFSET},{offset},{--- addr},{U},
{A user variable which contains a block offset.
The contents of forthcode({OFFSET}) is added to the argument
for forthcode({BLOCK}) before reading or writing blocks.
In this way a part of disc drives can be reserved for boot-code.
_HOSTED_MSDOS_({As blocks are allocated in a file on the host operating system it is 0.})
_HOSTED_X_({As blocks are allocated in a file on the host operating system it is 0.})
},
{{BLOCK},{MESSAGE},{BLOCK-READ},{BLOCK-WRITE}},
{{OFFSET @ 1000 U< .},{_T_}},
enddoc)
_HEADER({OFFSET},{LOFFSET},{DOUSE}, _CELLS(37))
_C
_C
_C
worddoc( {WORDLISTS},{CONTEXT},{context},{--- addr},{FIG,U},
{ The context is the address where the WID is found of the wordlist
that is searched first. In ciforth forthvar({addr}) actually points
to the forthdefi({search order}),
a row of WID 's
ending with the minimum search order WID.
The corresponding wordlists are searched in that order for definitions during
interpretation.
This row of WID's is allocated in the user variable space _VERBOSE_({allowing for
compilation in threads}).
It may contain up to M4_MAXWORDLIST WID 's in
this ciforth, while the ISO Search-Order wordset requires a capacity of at
least 8.
},
{{PRESENT},{NAMESPACE},{CURRENT},{USER}},
{{CONTEXT @ ' FORTH >WID = .},{_T_}},
enddoc)
_HEADER({CONTEXT},{CONTEXT},{DOUSE}, _CELLS(38)) _C{ Up to } 38+M4_MAXWORDLIST
_C{      IMPORTANT}
_C{     }M4_MAXWORDLIST{ USER SPACE CELLS MUST BE KEPT FREE}
_C{     IN ADDITION TO THE ONE FOR CONTEXT}
_C
_C{========== END USER VARIABLES =============}
_C
worddoc( {SUPERFLUOUS},{1+},{one_plus},{n1 --- n2},{ISO,FIG},
{This is shorthand for ``forthsamp({1 +})''.},
{{CELL+},{1-}},
{{5 1+ .},{6}},
enddoc)
_HEADER({1+},{ONEP},{DOCOL})
        DC      ONE
        DC      PLUS
        DC      SEMIS
_C
worddoc( {MEMORY},{CELL+},{cell_plus},{n1 --- n2},{ISO},
{Advance the memory pointer forthvar({n1}) by one (in this case  _BITS_ bits) cell to
forthvar({n2}). _VERBOSE_({{This is invaluable for writing portable
code.
Much of the library code of ciforth runs on 64, 32 and 16 bits
systems, thanks to this. }})
},{},
_BITS64_({{{0 CELL+ .},{8}},})dnl expanded before worddoc is!
_BITS32_({{{0 CELL+ .},{4}},})dnl expanded before worddoc is!
_BITS16_({{{0 CELL+ .},{2}},})dnl
enddoc)
_HEADER({CELL+},{CELLP},{DOCOL})
        DC      LIT, CW
        DC      PLUS
        DC      SEMIS
_C
worddoc( {MEMORY},{CELLS},{cells},{n1 --- n2},{ISO},
{Return the equivalent of forthvar({n1}) cells in bytes:
forthvar({n2}). _VERBOSE_({{This is invaluable for writing portable
code.
Much of the library code of ciforth runs on 64, 32 and 16 bits
systems, thanks to this. }})
},{{CELL+}},
_BITS64_({{{2 CELLS .},{10}},})dnl expanded before worddoc is!
_BITS32_({{{2 CELLS .},{8}},})dnl expanded before worddoc is!
_BITS16_({{{2 CELLS .},{4}},})dnl expanded before worddoc is!
enddoc)
_C
_HEADER({CELLS},{LCELLS},{DOCOL})
        DC      _BITS16_({ONE}) _BITS32_({TWO}) _BITS64_({{LIT, 3}})
        DC      LSHIFT
        DC      SEMIS
_C
worddoc( {MEMORY},{CHAR+},{char_plus},{n1 --- n2},{ISO},
{Advance the memory pointer forthvar({n1}) by one character to
forthvar({n2}). In ciforth this means one byte. Bytes are the
address units ISO is talking about. _VERBOSE_({{Unfortunately
the ISO standard has no way to address bytes.}})
},{{CELL+}},
{{123 CHAR+ .},{124}},
enddoc)
_HEADER({CHAR+}, {CHARP},{DOCOL}, {_VAR_FIELD(ONEP)})
_C
worddoc( {MEMORY},{CHARS},{chars},{n1 --- n2},{ISO},
{Return the equivalent of forthvar({n1}) chars in bytes:
forthvar({n2}). In ciforth this is a NOOP.
_VERBOSE_({{Unfortunately
the ISO standard has no way to address bytes.}})
},{{CELLS}},
{{123 CHARS .},{123}},
enddoc)
_HEADER({CHARS}, {CHARS}, {DOCOL} )
        DC      SEMIS
_C
worddoc( {MEMORY},{ALIGN},{align},{ ---},{ISO},
{Make sure that forthcode({HERE}) is forthdefi({aligned}) by advancing
it if necessary.
This means that data of any size can be fetched from that address efficiently.
_ALIGNED_(,{ In this ciforth this is a NOOP.})
},{{ALIGNED}},
_ALIGNED_({
{{ 1 ALLOT ALIGN HERE 0 CELL+ MOD . },{0}}
}),
enddoc)
_HEADER({ALIGN}, {LALIGN}, {DOCOL} )
_ALIGNED_({
        DC      LDP, FETCH
        DC      ALIGNED
        DC      LDP, STOR
},{dnl })_C{}_END_({_ALIGNED_})
        DC      SEMIS
_C
worddoc( {MEMORY},{ALIGNED},{aligned},{addr1 --- addr2},{ISO},
{Make sure that forthvar({addr1}) is forthdefi({aligned}) by advancing
it if necessary to forthvar({addr2}).
_ALIGNED_(,{ In this ciforth this is a NOOP.})
},{{ALIGN}},
_ALIGNED_({
_BITS16_({{{ 4 ALIGNED .},{4}, {5 ALIGNED . },{6}},}) dnl Expanded before worddoc.
_BITS32_({{{ 4 ALIGNED .},{4}, {5 ALIGNED . },{8}},}) dnl Expanded before worddoc.
_BITS64_({{{ 8 ALIGNED .},{8}, {0A ALIGNED . },{10}},}) dnl Expanded before worddoc.
}),
enddoc)
CODE_HEADER({ALIGNED}, {ALIGNED} )
_ALIGNED_({
        POP     AX
        DEC     AX
        OR      AX, _OFFSET _CELLS(1)-1
        INC     AX
        PUSH    AX
},{dnl })_C{}_END_({_ALIGNED_})
        _NEXT
_C
worddoc( {DICTIONARY},{HERE},{here},{--- addr},{ISO,FIG},
{Leave the address forthvar({addr}) of the next available
dictionary location.},
{{DP}},
{{HERE 896 ALLOT HERE SWAP - .},{896}},
enddoc)
_HEADER({HERE},{HERE},{DOCOL})
        DC      LDP
        DC      FETCH
        DC      SEMIS
_C
worddoc( {DICTIONARY},{ALLOT},{allot},{n ---},{ISO,FIG},
{Add the signed number to the forthdefi({dictionary pointer}) forthcode({DP}) . May be used to
reserve dictionary space or re-origin memory. As the Pentium is a byte-addressable
machine forthvar({n}) counts bytes. },
{{HERE},{,}},
{{." Via HERE"},{Via HERE}},
enddoc)
_HEADER({ALLOT},{ALLOT},{DOCOL})
        DC      LDP
        DC      PSTOR
        DC      SEMIS
_C
worddocsafe( {DICTIONARY},{,},{comma},{n ---},{ISO,FIG},
{Store forthvar({n}) into the next available dictionary memory cell, advancing
the forthdefi({dictionary pointer}).},{{DP},{C,}},
{{HERE 625 , DUP @ . CELL+ HERE = .},{625 _T_}},
enddoc)
_HEADER({,},{COMMA},{DOCOL})
        DC      HERE
        DC      LIT
        DC      CW
        DC      ALLOT
        DC      STOR
        DC      SEMIS
_C
worddocsafe( {DICTIONARY},{C,},{c_comma},{b ---},{ISO,FIG},
{Store the least significand bits of forthvar({b}) into the next available dictionary byte, advancing
the forthdefi({dictionary pointer}). },{{DP},{,}},
{{HERE 62 C, DUP C@ . 1+ HERE = .},{62 _T_}},
enddoc)
_HEADER({C,},{CCOMM},{DOCOL})
        DC      HERE
        DC      ONE
        DC      ALLOT
        DC      CSTOR
        DC      SEMIS
_C
worddocsafe( {DICTIONARY},{2,},{two_comma},{d ---},{ISO,FIG},
{Store the most significand cell of forthvar({d}) into the next available dictionary
cell, advancing
the forthdefi({dictionary pointer}), then the least significand one.
. },{{DP},{,}},
{{HERE 62. 2, DUP $@ . @ . CELL+ CELL+  HERE = .},{0 62 _T_}},
enddoc)
_HEADER({2,},{TCOMM},{DOCOL})
        DC      HERE
        DC      LIT
        DC      CW*2
        DC      ALLOT
        DC      TSTOR
        DC      SEMIS
_C
worddoc( {OPERATOR},{-},{minus_sign},{n1 n2 --- diff},{ISO,FIG},
{Leave the difference of forthvar({n1}) and forthvar({n2}) .},
{{NEGATE},{+},{*},{/},{MOD}},
{ { 0A BASE !  240 204 - .},{36} },
{}, enddoc)
CODE_HEADER({-},{LSUB})
        POP     DX      _C{S1}
        POP     AX
        SUB     AX,DX
        _PUSH   _C{S1 = S2 - S1}
_C
worddoc( {LOGIC},{=},{equals},{n1 n2 --- ff},{ISO,FIG},
{Leave a true flag if forthsamp({n1=n2}) ; otherwise leave a false flag.},
{{<},{>},{0=},{-}},
{ { 0A BASE !  240 204 = .},{0},
  { 240 240 = .},{_T_} },
enddoc)
_HEADER({=},{EQUAL},{DOCOL})
        DC      LSUB
        DC      ZEQU
        DC      SEMIS
_C
worddoc( {LOGIC},{<},{less_than},{n1 n2 --- ff},{ISO},
{Leave a true flag if forthvar({n1}) is less than forthvar({n2}) ;
otherwise leave a false
flag.},{{=},{>},{0<}},
{{1 2 < .},{_T_},
 {-1 -2 < .},{0},
 {0 -1 < .},{0},
 {1 1 < .},{0} },
enddoc)
CODE_HEADER({<},{LESS})
        POP     DX      _C{S1}
        POP     BX      _C{S2}
        XOR     AX,AX   _C{0 default RESULT}
        CMP     BX,DX
        JNL     LES1
        DEC     AX
LES1:   _PUSH
_C
worddoc( {LOGIC},{U<},{u_less_than},{u1 u2 --- ff},{ISO},
{Leave a true flag if forthvar({u1}) is less than forthvar({u2}) ; otherwise leave a false
flag.(Interpreted as unsigned numbers).},{{<}},
{{1 2 U< .},{_T_},
 {-1 -2 U< .},{0},
 {0 -1 U< .},{_T_},
 {1 1 U< .},{0} },
enddoc)
CODE_HEADER({U<},{ULESS})
        POP     AX
        POP     DX
        SUB     DX,AX
        SBB     AX,AX
        _PUSH
_C
worddoc( {LOGIC},{>},{greater_than},{n1 n2 --- ff},{ISO},
{Leave a true flag if forthvar({n1}) is greater than
forthvar({n2}) ; otherwise leave a false flag.},
{{<},{=},{0<}},
{{1 2 > .},{0},
 {-1 -2 > .},{_T_},
 {0 -1 > .},{_T_},
 {1 1 > .},{0} },
enddoc)
_HEADER({>},{GREAT},{DOCOL})
        DC      SWAP
        DC      LESS
        DC      SEMIS
_C
worddoc( {LOGIC},{<>},{unequal},{n1 n2 --- ff},{ISO},
{Leave a true flag if forthvar({n1}) is not equal than
forthvar({n2}) ; otherwise leave a false flag.},
{{>},{=},{0<}},
{{1 2 <> .},{_T_},
 {-1 -2 <> .},{_T_},
 {0 -1 <> .},{_T_},
 {1 1 <> .},{0} },
enddoc)
_HEADER({<>},{UNEQ},{DOCOL})
        DC      LSUB
        DC      ZEQU
        DC      ZEQU
        DC      SEMIS
_C
worddoc( {JUGGLING},{ROT},{rot},{nl n2 n3 --- n2 n3 nl},{ISO,FIG},
{Rotate the top three values on the stack, bringing the third to the
top.},{{SWAP}},
{{S0 @ DSP! 1 2 3 4 ROT .S},{
S[  1 3 4 2 ]} ,
{S0 @ DSP!},{} },
enddoc)
CODE_HEADER({ROT},{ROT})
        POP     DX      _C{S1}
        POP     BX      _C{S2}
        POP     AX      _C{S3}
        PUSH    BX
        _2PUSH
_C
worddoc( {OUTPUT},{SPACE},{space},{},{ISO,FIG},
{Transmit an ASCII blank to the output device.},{{EMIT},{OUT}},
{{41 EMIT SPACE 41 EMIT},{A A}},
enddoc)
_HEADER({SPACE},{SPACE},{DOCOL})
        DC      LBL
        DC      EMIT
        DC      SEMIS
_C
worddoc( {JUGGLING},{?DUP},{question_dupe},
{n1 --- n1 (if zero) / n1 --- n1 n1 (non-zero)},{ISO,FIG},
{Reproduce forthvar({n1}) only if it is non-zero. This is
usually used to copy a value just before forthcode({IF}) , to
eliminate the need for an forthcode({ELSE}) part to drop
it.},{{DUP},{_}},
{{S0 @ DSP!  1 2 3 4 ?DUP .S},{
S[  1 2 3 4 4 ]},
{S0 @ DSP! 1 2 3 0 ?DUP .S},{
S[  1 2 3 0 ]},
{S0 @ DSP!},{} },
enddoc)
_HEADER({?DUP},{QDUP},{DOCOL})
        DC      LDUP
        _0BRANCH(QDUP1) _C{ IF}
        DC      LDUP    _C{THEN}
QDUP1:  DC      SEMIS
_C
worddoc( {WORDLISTS},{LATEST},{latest},{--- addr},{FIG},
{Leave the dictionary entry address forthvar({addr}) of the
topmost word in the forthcode({CURRENT}) word list.},
{{NAMESPACE}},
{{: APE ;  LATEST ID.},{APE}},
enddoc)
_HEADER({LATEST},{LATEST},{DOCOL})
        DC      CURR
        DC      FETCH
        DC      TLFA
        DC      FETCH
        DC      SEMIS
_C
worddoc( {DICTIONARY~},{>CFA},{to_code_field_address},{dea --- addr},{},
{Given a dictionary entry addres forthvar({dea}) return its
forthdefi({code field address}) forthvar({addr}). By jumping
indirectly via this address the definition forthvar({dea}) is
executed.
_VERBOSE_({{In ciforth it has offset 0, so it is actually the
same as the }forthdefi({dea}){}}).},
{{Prefix_'},{HEADER}},
{{' TASK  DUP >CFA = .},{_T_}},
enddoc)
_HEADER({>CFA},{TCFA},{DOCOL})
        DC      LIT, _CELLS(C_HOFFSET)
        DC      PLUS
        DC      SEMIS
_C
worddoc( {DICTIONARY~},{>DFA},{to_data_field_address},{dea --- addr},{},
{Given a dictionary entry addres return
its forthdefi({data field address}) forthvar({addr}) .
This contains a pointer to the code for a code word,
to the data for a word defined by forthcode({VARIABLE}) or forthcode({DATA}) ,
to the high level code for a colon-definition, and
to the forthcode({DOES>}) pointer for a word build using
forthcode({CREATE}). Normally this is the area behind the
header, found via forthcode({>PHA}) . },
{{Prefix_'},{>BODY},{HEADER}},
{{ "APE" (CREATE) HERE ' APE >DFA @ = .},{_T_}},
enddoc)
_HEADER({>DFA},{TDFA},{DOCOL})
        DC      LIT, _CELLS(D_HOFFSET)
        DC      PLUS
        DC      SEMIS
_C
worddoc( {DICTIONARY~},{>FFA},{to_flag_field_address},{dea --- addr},{},
{Given a dictionary entry addres return its
forthdefi({flag field address}) forthvar({addr}) .},
{{Prefix_'},{HEADER},{IMMEDIATE},{PREFIX}},
{{"FRED" (CREATE) ' FRED >FFA DUP @ . IMMEDIATE @ .},{0 4}},
enddoc)
_HEADER({>FFA},{TFFA},{DOCOL})
        DC      LIT, _CELLS(F_HOFFSET)
        DC      PLUS
        DC      SEMIS
_C
worddoc( {DICTIONARY~},{>LFA},{to_link_field_address},{dea --- addr},{},
{Given a dictionary entry addres return its
forthdefi({link field address}) forthvar({addr}). It contains
the forthdefi({dea}) of the previous word. },
{{Prefix_'},{HEADER}},
{{: FRED ; : WILMA ; ' WILMA >LFA @ ID.},{FRED}},
enddoc)
_HEADER({>LFA},{TLFA},{DOCOL})
        DC      LIT, _CELLS(L_HOFFSET)
        DC      PLUS
        DC      SEMIS
_C
worddoc( {DICTIONARY~},{>NFA},{to_name_field_address},{dea --- nfa},{},
{Given a dictionary entry addres return the
 forthdefi({name field address}).},
{{Prefix_'},{HEADER},{ID.}},
{{ ' WORDS >NFA @ $@ TYPE},{WORDS}},
enddoc)
_HEADER({>NFA},{TNFA},{DOCOL})
        DC      LIT,_CELLS(N_HOFFSET)
        DC      PLUS
        DC      SEMIS
_C
_SOURCEFIELD_({
worddoc( {DICTIONARY~},{>SFA},{to_source_field_address},{dea --- addr},{},
{Given a dictionary entry addres return the
 forthdefi({source field address}) forthvar({addr}).
If its content is higher than 1000, that is a pointer to
after the name of the definition in the source code.
This assumes that the source is still present in memory, which is true
during development.
If the content is zero, it is a kernel word and the source is not
available interactively.
Otherwise it is the block number from which the definition was compiled.
_VERBOSE_({No attempt is made to erase this information when it becomes
incorrect{,} for e.g. turnkey programs.})
},
{{Prefix_'},{HEADER}},
{{ ' WORDS >SFA @ .},{0}},
enddoc)
_C
_HEADER({>SFA},{TSFA},{DOCOL})
        DC      LIT,_CELLS(S_HOFFSET)
        DC      PLUS
        DC      SEMIS
},{dnl })_C{}_END_({_SOURCEFIELD_})
_C
_EXTRAFIELD_({
worddoc( {DICTIONARY~},{>XFA},{to_extra_field_address},{dea --- addr},{},
{Given a dictionary entry addres return the
 forthdefi({extra field address}) forthvar({addr}) .
This is a field in the header that is free for an application to use
for whatever purpose.
},
{{Prefix_'},{OPT},{HEADER}},
{{ ' WORDS >XFA @ .},{0}},
enddoc)
_C
_HEADER({>XFA},{TXFA},{DOCOL})
        DC      LIT,_CELLS(X_HOFFSET)
        DC      PLUS
        DC      SEMIS
},{dnl })_C{}_END_({_EXTRAFIELD_})
_C
worddoc( {DICTIONARY~},{>PHA},{past_header_address},{dea --- addr},{},
{Given a dictionary entry addres return the
forthdefi({past header address}). Here starts the area that no
longer belongs to the header of a dictionary entry, but most
often it is owned by it. },
{{Prefix_'},{HEADER},{>BODY}},
{{ "Q" (CREATE) ' Q >PHA HERE = .},{_T_} },
enddoc)
_HEADER({>PHA},{TPHA},{DOCOL})
        DC      LIT,_CELLS(PH_OFFSET)
        DC      PLUS
        DC      SEMIS
_C
worddoc( {DICTIONARY},{>BODY},{to_body},{dea --- addr},{ISO},
{Given the forthdefi({dictionary entry address}) forthvar({dea}) of a
definition created with a forthcode({CREATE}) /
forthcode({DOES>}) construct, return its forthdefi({data}) field (in the ISO sense)
forthvar({addr}).},
{{'},{>CFA},{>DFA},{>PHA},{BODY>},{DATA}},
{{ CREATE Q  ' Q >BODY HERE = .},{_T_} },
enddoc)
_HEADER({>BODY},{TOBODY},{DOCOL})
        DC      TDFA, FETCH
        DC      CELLP           _C{ Skip DOES> pointer.}
        DC      SEMIS
_C
worddoc( {DICTIONARY},{BODY>},{body_from},{addr --- dea},{},
{Convert the forthdefi({data field}) forthvar({addr}) of a definition created
with a forthcode({CREATE}) / forthcode({DOES>}) construct
to its forthvar({dea}).
_VERBOSE_({( forthvar({addr}) is not a header forthdefi({data field address}))})
Where forthcode({>BODY}) keeps working for a copy of the header,
forthcode({BODY>}) does not.
_VERBOSE_({{ There is some logic to this, because the
}forthdefi({dea}){ to which the body belongs is no longer
unique.}})
},
{{'},{>BODY}},
{{ CREATE QAQ HERE BODY> ID.},{QAQ}},
enddoc)
_HEADER({BODY>},{BODYF},{DOCOL})
        DC      LIT,_CELLS(BD_OFFSET)
        DC      LSUB
        DC      SEMIS
_C
worddoc( {DICTIONARY~},{>WID},{to_w_i_d},{dea --- wid},{},
{Given the dictionary entry addres forthvar({dea}) of a
namespace return its
forthdefi({WID}) forthvar({wid}), a dummy forthdefi({dea}) that serves as the start of a
dictionary search. },
{{NAMESPACE},{>VFA},{(FIND)}},
{{: APE ; ' FORTH >WID >LFA @ ID.},{APE}},
enddoc)
_HEADER({>WID},{TWID},{DOCOL})
        DC      TOBODY
        DC      CELLP _C{ Skip vfa link.}
        DC      SEMIS
_C
worddoc( {DICTIONARY~},{>VFA},{to_namespace_field_address},{dea --- cfa},{},
{Given the dictionary entry addres of a namespace
return the address of the link to the next namespace.
_VERBOSE_({{Traditionally this was called vocabulary, hence the} forthkey({V}).})
},{{NAMESPACE},{>CFA},{>WID}},
{{NAMESPACE APE NAMESPACE MONKEY dnl
'MONKEY >VFA @  ' APE = .},{_T_}},
enddoc)
_HEADER({>VFA},{TVFA},{DOCOL})
        DC      TOBODY
        DC      SEMIS
_C
_SECURITY_({
worddoc( {SECURITY},{!CSP},{store_c_s_p},{},{},
{Save the stack position in forthcode({CSP}). Used as part of the compiler
security.},{},
{{." Via ?CSP"},{Via ?CSP}},
enddoc)
_HEADER({!CSP},{SCSP},{DOCOL})
        DC      SPFET
        DC      LCSP
        DC      STOR
        DC      SEMIS
_C
})_C{}_END_({_SECURITY_})
worddoc( {ERRORS},{?ERROR},{question_error},{f n ---},{},
{
If the boolean flag is true, forthdefi({signal an error}) with
number forthvar({n}).
This means that an exception is thrown,
and it is remembered that this is the original place where the
exception originated.
If the exception is never caught, an error message is displayed
using forthcode({ERROR}) .
All errors signaled by the kernel go through this word.
},
{{ERROR},{?ERRUR},{THROW}},
{{0 12 ?ERROR},{},
 {0 WARNING !   1 12 ?ERROR},{ING !   1 12 ?ERROR ? ciforth ERROR # 18 },
 {CR},{} },
enddoc)
_HEADER({?ERROR},{QERR},{DOCOL})
        DC      SWAP
        _0BRANCH(QERR1) _C{IF}
        DC      PP, FETCH
        DC      SRC, FETCH
        DC      LWHERE, TSTOR
        DC      THROW
        _BRANCH(QERR2)  _C{ELSE}
QERR1:  DC      DROP    _C{THEN}
QERR2:  DC      SEMIS
_C
worddoc( {ERRORS},{?ERRUR},{query_error_Unix},{n ---},{},
{Handle the possible error forthvar({n}) in Unix fashion. If
it is zero or positive, this means okay. If it is negative, its
value identifies an error condition. This error is handled in
the same way as by forthcode({?ERROR}) . },
{{ERROR},{?ERROR}},
{
{0 ?ERRUR 1 ?ERRUR},{},
{0 WARNING ! -20 ?ERRUR },
{ARNING ! -20 ?ERRUR ? ciforth ERROR # -32 },
{CR 1 WARNING !},{},
},
enddoc)
_HEADER({?ERRUR},{QERRUR},{DOCOL})
        DC      ZERO, MIN, LDUP, QERR
        DC      SEMIS
_C
_SECURITY_({
worddoc( {SECURITY},{?DELIM},{question_delimiter},{},{},
{Parse a character and issue error message if it is not a blank
delimiter.},{},
{
{DECIMAL 0 WARNING !   ?DELIM   },{},
{0 WARNING !   ?DELIM 1}, {WARNING !   ?DELIM 1 ? ciforth ERROR # 10 },
 {CR 1 WARNING !},{} },
enddoc)
_HEADER({?DELIM},{QDELIM},{DOCOL})
        DC      PPFET
        DC      QBL
        DC      ZEQU
        DC      LIT, 10, QERR
        DC      DROP
        DC      SEMIS
_C
worddoc( {SECURITY},{?CSP},{question_c_s_p},{},{},
{Issue error message if stack position differs from value saved in
forthsamp({CSP}) .},{},
{{!CSP ?CSP},{},
{0 WARNING !   !CSP 1 ?CSP},{ING !   !CSP 1 ?CSP ? ciforth ERROR # 20 },
 {CR 1 WARNING !},{} },
enddoc)
_HEADER({?CSP},{QCSP},{DOCOL})
        DC      SPFET
        DC      LCSP
        DC      FETCH
        DC      LSUB
        DC      LIT, 20, QERR
        DC      SEMIS
_C
worddoc( {SECURITY},{?COMP},{question_compile},{},{},
{Issue error message if not compiling.},{{?ERROR}},
{{0 WARNING !   ?COMP},{0 WARNING !   ?COMP ? ciforth ERROR # 17 },
 {CR 1 WARNING !},{} },
enddoc)
_HEADER({?COMP},{QCOMP},{DOCOL})
        DC      STATE
        DC      FETCH
        DC      ZEQU
        DC      LIT, 17, QERR
        DC      SEMIS
_C
worddoc( {SECURITY},{?EXEC},{question_exec},{},{FIG,WANT},
{Issue an error message if not executing.},{{?ERROR}},
{{!CSP ?CSP},{},
dnl {0 WARNING ! ?EXEC},{}
},
enddoc)
_SUPPRESSED({{
_HEADER({?EXEC},{QEXEC},{DOCOL})
        DC      STATE
        DC      FETCH
        DC      LIT, 18, QERR
        DC      SEMIS
_C
}})_C{}_END_({ _SUPPRESSED})
worddoc( {SECURITY},{?PAIRS},{question_pairs},{n1 n2 ---},{},
{Issue an error message if forthvar({n1}) does not equal forthvar({n2}) . The message
indicates that compiled conditionals do not match.},{{?ERROR}},
{{ 1 1 ?PAIRS},{},
{0 WARNING !  1 2 ?PAIRS},{RNING !  1 2 ?PAIRS ? ciforth ERROR # 19 },
 {CR 1 WARNING !},{} },
{},
enddoc)
_HEADER({?PAIRS},{QPAIR},{DOCOL})
        DC      LSUB
        DC      LIT, 19, QERR
        DC      SEMIS
_C
_LOAD_({
worddoc( {SECURITY},{?LOADING},{question_loading},{},{FIG,WANT},
{Issue an error message if not loading},{{?ERROR}},
{
dnl {0 WARNING ! ?LOADING },{ WARNING ! ?LOADING ? ciforth ERROR # 22 },
dnl {CR 1 WARNING !},{}
},
enddoc)
_SUPPRESSED({{
_HEADER({?LOADING},{QLOAD},{DOCOL})
        DC      BLK
        DC      FETCH
        DC      ZEQU
        DC      LIT, 22, QERR
        DC      SEMIS
}})_C{}_END_({ _SUPPRESSED})
_C
})_C{}_END_({_LOAD_})
})_C{}_END_({_SECURITY_})
_C
worddocsafe( {PARSING},{[},{left_bracket},{},{ISO,FIG,I,},
{Used in a colon-definition in form:
forthexample({:  xxx    [  words   ]    more   ;})
Suspend compilation. The words after forthcode({[}) are executed, not compiled.
This allows calculation or compilation exceptions before resuming
compilation with forthcode({]})},{{LITERAL} ,{]}},
{{!CSP : GS1 LIT [ 2398 , ] ; ?CSP GS1 .},{2398}},
enddoc)
_HEADER({[},{LBRAC},{DOCOL}, , B_IMMED)
        DC      ZERO
        DC      STATE
        DC      STOR
        DC      SEMIS
_C
worddocsafe( {PARSING},{]},{righ_bracket},{},{ISO,FIG},
{Resume compilation, to the completion of a colon-definition.},
{{[}},
{{." Via ["},{Via [}},
enddoc)
_HEADER({]},{RBRAC},{DOCOL})
        DC      ONE
        DC      STATE
        DC      STOR
        DC      SEMIS
_C
worddoc( {DICTIONARY~},{HIDDEN},{hidden},{dea ---},{},
{Make the word with dictionary entry address forthvar({dea})
unfindable, by toggling the "smudge bit" in a definitions' flag
field. If however it was the forthvar({dea}) of an unfindable
word, it is made findable again.
_SECURITY_({{Used
during the definition of a colon word to prevents an
uncompleted definition from being found during dictionary
searches, until compiling is completed without error. It also
prevents that a word can be used recursively.}})
},
{{IMMEDIATE},{RECURSE}},
dnl NOTE: a word starting with e.g. C would be a denotation.
{{"ZXJEP" 2DUP (CREATE) 2DUP FOUND 0= .},{0},
{LATEST HIDDEN FOUND .},{0} },
enddoc)
_HEADER({HIDDEN},{HIDDEN},{DOCOL})
        DC      TFFA
        DC      LIT,B_INVIS
        DC      TOGGL
        DC      SEMIS
_C
worddoc( {FORMATTING},{HEX},{hex},{},{ISO,FIG},
{Set the numeric conversion forthcode({BASE}) for hexadecimal (base 16) input-output.},
{{DECIMAL}},
{{HEX BASE @ DECIMAL .},{16}},
enddoc)
_HEADER({HEX},{HEX},{DOCOL})
        DC      LIT,16
        DC      BASE
        DC      STOR
        DC      SEMIS
_C
worddoc( {FORMATTING},{DECIMAL},{decimal},{},{ISO,FIG},
{Set the numeric conversion forthcode({BASE}) for decimal input-output.},
{{HEX}},
{{." Via BASE"},{Via BASE}},
enddoc)
_HEADER({DECIMAL},{DECA},{DOCOL})
        DC      LIT,10
        DC      BASE
        DC      STOR
        DC      SEMIS
_C
worddocsafe( {DEFINING~},{(;CODE)},{paren_semicolon_code},{},{WANT,C},
{The run-time proceedure, compiled by forthcode({;CODE}), that rewrites the code
field of the most recently defined word to point to the following
machine code sequence. It is used after forthcode({CREATE}) instead of forthcode({DOES>}) if the code following
is assembler code instead of high level code.
},
{ {;CODE}},
{{." No test"},{No test} },
enddoc)
_HEADER({(;CODE)},{PSCOD},{DOCOL})
        DC      FROMR
        DC      LATEST
        DC      TCFA
        DC      STOR
        DC      SEMIS
_C
worddoc( {DEFINING~},{;CODE},{semicolon_code},{},{WANT,ISO,FIG,I,C},
{Used in the form:
  forthsamp({: cccc CREATE .... ;CODE assembly mnemonics })
Stop compilation and terminate a new defining word
forthsamp({cccc}) by compiling forthcode({(;CODE)}). Set
forthcode({ASSEMBLER}) to the top of the
forthdefi({search order}) order. Start assembling to machine
code the following mnemonics.

When forthsamp({cccc}) later executes in the form:
                     forthsamp({cccc nnnn})
the word forthsamp({nnnn}) will be created with its execution proceedure given by
the machine code following forthsamp({cccc}) .
That is, when forthsamp({nnnn}) is executed, it does so by
jumping to the code after forthsamp({nnnn}) .
Because of intimate relation to the
assembler, it is present in loadable form in the screens file
forthfile({forth.lab}) .
Machine code must end in forthcode({NEXT,}) also available with the assembler.
},
{{(;CODE)},{(CREATE)}},
{{." Not present"},{Not present} },
enddoc)
_C
worddoc( {DEFINING},{CREATE},{create},{},{ISO},
{A defining word used in the form:
     forthsamp({CREATE cccc})
Later execution of forthsamp({cccc}) returns its forthdefi({data field}) , i.e.
the value of forthcode({HERE}) immediately
after executing forthcode({CREATE}) .

It can be the base of a new defining word if used in the form:
     forthexample({: CREATOR CREATE aaaa DOES> bbbb ;
CREATOR cccc
})
The second line has the effect of creating a word forthsamp({cccc}) .
Its datastructure is build by the code forthsamp({aaaa}) and when
executing forthsamp({cccc}) , its data field is pushed on the stack,
then the code forthsamp({bbbb}) is executed.

_VERBOSE_({{Space in this forthdefi({data field}) has yet to
be allocated. The forthdefi({DFA})  (data field address) points to the
the execution action that can be changed by forthcode({DOES>}) .}})
ciforth is byte aligned, so no extra measures are needed.},
{{>BODY},{DOES>},{;CODE},{ALLOT},{,},{>DFA}},
{{ CREATE ZWY LATEST ID.},{ZWY},
{HERE ZWY = .},{_T_}},
enddoc)
_HEADER({CREATE},{LCREATE},{DOCOL})
        DC      LNAME
        DC      PCREAT
        DC      LIT, HLNOOP, COMMA
        DC      PSCOD
DODOE:  LEA     RPO,[RPO - _CELLS(1)] _C{Push HIP.}
        MOV     [RPO],HIP
        MOV     HIP,[WOR+_CELLS((D_HOFFSET))] _C{NEW IP }
        LEA     AX,[HIP+_CELLS(1)]
        MOV     HIP,[HIP]
        _PUSH
        DC      0       _C{ In behalf of FIND-HEAD in decompilation}
HLNOOP: DC      SEMIS
_C
worddoc( {DEFINING},{DOES>},{does},{},{ISO,FIG},
{A word which is used
in combination with forthcode({CREATE})
to specify the run-time action
within a high-level defining word. forthcode({DOES>}) modifies
the default behaviour of the created word so as to execute the sequence of
compiled word addresses following forthcode({DOES>}) .
When the
forthcode({DOES>}) part executes it begins with the address of
the forthdefi({data field}) of the word on the stack. This allows
interpretation using this area or its contents. _VERBOSE_({{
Typical uses include the Forth assembler,
arrays and matrices, and compiler generation.}})
},
{},
{{ !CSP : GS1 DOES> @ 1 + ;  : GS2 DOES> @ 2 + ; dnl
  CREATE MARY 0 , GS1 MARY . GS2 MARY . ?CSP},{1 2} },
enddoc)
_HEADER({DOES>},{DOES},{DOCOL})
        DC      FROMR
        DC      LATEST
        DC      TDFA
        DC      FETCH
        DC      STOR
        DC      SEMIS
_C
worddoc( {STRING},{COUNT},{count},{addr1 --- addr2 n},{ISO,FIG},
{Leave the byte address forthvar({addr2}) and byte count forthvar({n}) of a message text
beginning at address forthvar({addr1}) . It is presumed that the first byte at
forthvar({addr1}) contains the text byte count and the actual text starts with
the second byte. Alternatively stated, fetch a
forthdefin({string constant}) forthvar({addr2 n}) from
the brain damaged string variable at forthvar({addr1}) .
},{{TYPE}},
{{HERE 3 C, 45 C, 45 C, 45 C, COUNT . HERE - .},{3 -3}},
enddoc)
_HEADER({COUNT},{COUNT},{DOCOL})
        DC      LDUP
        DC      ONEP
        DC      SWAP
        DC      CFET
        DC      SEMIS
_C
worddoc( {STRING},{-TRAILING},{dash_trailing},{sc1 --- sc2},{ISO},
{Trim the forthdefin({string constant}) forthvar({sc1}) so as not to contain
trailing blank space and leave it as forthvar({sc2}) . },
{{?BLANK}},
{{ "    NUKES   " -TRAILING 41 EMIT TYPE 41 EMIT},{A   NUKESA}},
enddoc)
_HEADER({-TRAILING},{DTRAI},{DOCOL})
        DC      LDUP
        DC      ZERO
        _QDO(DTRA4)
DTRA1:  DC      OVER
        DC      OVER
        DC      PLUS
        DC      ONE
        DC      LSUB
        DC      CFET
        DC      QBL
        DC      ZEQU
        _0BRANCH(DTRA2) _C{IF}
        DC      LLEAV
DTRA2:  DC      ONE
        DC      LSUB    _C{ THEN}
        _LOOP(DTRA1)    _C{ LOOP}
DTRA4:
        DC      SEMIS
_C
_LOAD_({
worddocsafe( {STRING},{S"},{s_quote},{ --- addr1 n},{ISO},
{ Used in the form:
  forthsamp({S" cccc"})
Leaves an in-line string forthsamp({cccc}) (delimited by the
trailing forthkey({"})) as a constant string forthvar({addr1
n}) . In ciforth the number of characters has no limit and
using forthsamp({S"}) has always an effect on
forthcode({HERE}), even during interpretation.
In ciforth a forthkey({"}) can be embedded in a string by doubling it.
In non-portable code denotations are recommended.
},{{"}},
{{S" NUKES  " 41 EMIT TYPE 41 EMIT},{ANUKES  A},
{: GS1 S" NUKES  " 41 EMIT TYPE 41 EMIT ; GS1},{ANUKES  A},
{S" ""BD  " 41 EMIT TYPE 41 EMIT},{A"BD  A}},
enddoc)
_HEADER({S"},{SQUOT},{DOCOL}, , B_IMMED)
        DC      DENQ
        DC      SEMIS
_C
})_C{}_END_({_LOAD_})
worddocsafe( {OUTPUT},{."},{dot_quote},{},{ISO,FIG,I},
{Used in the form:
  forthsamp({." cccc"})
In a definition it compiles an in-line string forthsamp({cccc})
(as if the denotation forthcode({"cccc"}) was used)
followed by forthcode({TYPE}) .
In ciforth forthcode({."}) behaves the same way in interpret mode.
In ciforth the number of characters has no limit.
In ciforth forthcode({."}) always has an effect
on forthcode({HERE}) during interpretation.
In ISO programs you may only use this word during compilation.
_VERBOSE_({{We recommend that }forthsamp({." cccc"}){ is replaced by }forthsamp({"cccc" TYPE}){.}})
},
{{OUT}},
{{." the end" },{the end},
{: GS1 ." the end" ; GS1 },{the end},
{: GS2 ." ""the end"" he said" ; GS2 },{"the end" he said}
},
enddoc)
_HEADER({."},{DOTQ},{DOCOL}, , B_IMMED)
        DC      DENQ
        DC      STATE
        DC      FETCH
        _0BRANCH(DOTQ1) _C{ IF}
        DC      LIT, LTYPE, COMMA
        _BRANCH(DOTQ2)
DOTQ1:
        DC      LTYPE
DOTQ2:
        DC      SEMIS   _C{ THEN}
_C
worddocsafe( {OUTPUT},{.(},{dot_paren},{},{I},
{ In ciforth this is an alias for ." , except that the string is closed with forthkey({{)}})
_VERBOSE_({{instead of parsed as per }forthcode({"}){ }}).
In ISO programs you may only use this word while interpreting.
_VERBOSE_({{We recommend that }forthsamp({.( cccc)}){ is replaced by }forthsamp({"cccc" TYPE}){.}})
},
{{OUT},{."}},
{{.( the end)},{the end}},
enddoc)
_HEADER({.(},{DOTP},{DOCOL}, , B_IMMED)
        DC      LIT, ')'
        DC      PARSE
        DC      LTYPE
        DC      SEMIS
_C
worddocsafe( {PARSING},{SET-SRC},{set_source},{sc ---},{},
{Make the forthdefin({string constant}) forthvar({sc}) the
forthdefi({current input source}). This input is chained, i.e.
exhausting it has the same effect as exhausting the input that
called forthcode({SET-SRC}). _VERBOSE_({{In practice this word
is almost always surrounded by call's to forthcode({SAVE}) and
forthcode({RESTORE}) and then
followed by a call to }forthcode({INTERPRET}){or some such.}})},
{{SRC},{SAVE},{EVALUATE},{INTERPRET}},
{{ "1 2 3 . CR" SET-SRC . . .},{3},
{ . . },{2 1} },
enddoc)
_HEADER({SET-SRC},{SETSRC},{DOCOL})
        DC      OVER, PLUS
        DC      OVER, SRC, TSTOR
        DC      PP, STOR _C{  IN}
_ISO_IN_({       DC     SRC, FETCH, NEGATE, LDUP
        DC     SRC, CELLP, PSTOR
        DC     PP, PSTOR
})
_C{       DC      DOTS}
        DC      SEMIS
_C
worddoc( {PARSING}, {EVALUATE}, {evaluate}, {sc --- ??}, {ISO},
{Interpret the content of forthvar({sc}). Afterwards return to
the forthdefi({current input source}) .},
{{LOAD},{INCLUDE},{SET-SRC}},
{
{"865" EVALUATE .},{865},
{"8655 1+" EVALUATE U.},{8656},
{": GS1 856 ;" EVALUATE GS1 .},{856}
},
enddoc)
_HEADER({EVALUATE}, {EVALUATE},{DOCOL})
        DC      SAVE
        DC      SETSRC
        DC      LIT, INTER, CATCH
        DC      RESTO
        DC      THROW
        DC      SEMIS
_C
worddoc( {MEMORY},{FILL},{fill},{addr u b ---},{ISO,FIG},
{ If forthvar({u}) is not zero, store forthvar({b})
in each of forthvar({u}) consecutive bytes of memory beginning at
forthvar({addr}) . },
{{BLANK},{ERASE}},
{{ !CSP HERE 41 C, 41 C, 41 C, 41 C, DUP 3 23 FILL dnl
    COUNT . COUNT . COUNT . COUNT . DROP},{23 23 23 41} },
enddoc)
CODE_HEADER({FILL},{FILL})
_C{       Assume the extra segment points to the data segment }
        POP     AX      _C{ FILL CHAR}
        POP     CX      _C{ FILL COUNT}
        POP     DI      _C{ BEGIN ADDR}
        CLD             _C{ INC DIRECTION}
        REP     STOSB   _C{STORE BYTE}
        _NEXT
_C
worddoc( {MEMORY},{CORA},{CORA},{addr1 addr2 len  --- n},{CIF},
{Compare the memory areas at forthvar({addr1}) and forthvar({addr2})
over a length forthvar({len}) .
For the first bytes that differ, return -1 if the byte
from forthvar({addr1}) is less (unsigned) than the one from forthvar({addr2}),
and 1 if it is greater.
If all forthvar({len}) bytes are equal, return zero.
_VERBOSE_({{This is an abbreviation of }forthcode({COMPARE-AREA}){. }})
},
{},
{{ HEX 41 C, 42 C, 43 C, HERE 3 - DUP 3 CORA .},{0 },
{HERE 2 - HERE 3 - 2 CORA . },{1 },
{HERE 3 - HERE 2 - 2 CORA .},{-1 }},
enddoc)
CODE_HEADER({CORA},{CORA})
_C{       Assume the extra segment points to the data segment }
        MOV     DX,HIP   _C{SAVE}
        XOR     AX,AX   _C{ Result}
        POP     CX      _C{ count}
        POP     DI      _C{ addr2}
        POP     SI      _C{ addr1}
        CLD             _C{ INC DIRECTION}
        REPZ    CMPSB   _C{ Compare BYTE}
        JZ      CORA3
        MOV     AL,1    _C{Remainder is already 0}
        JNC     CORA3
        NEG     AX
CORA3:
        MOV     HIP,DX  _C{Restore}
        _PUSH
_C
worddoc( {STRING},{$^},{string_index},{sc c --- addr},{},
{Find the first forthvar({c}) in the forthdefin({string constant}) forthvar({sc}) and
return its forthvar({addr}) if present.
Otherwise return a forthdefin({nil pointer}).
A null string (0 0) or an empty string are allowed, and result in not found. },
{{$/},{CORA},{$@@}},
{{ 132 "ORANG" OVER >R &N $^ R> - . .},{3 132},
{ 132 "" &N $^ . .},{0 132},
{ 132 0 0 &N $^ . .},{0 132},
{ 132 "ORANG" &Z $^ 0= . .},{_T_ 132}},
enddoc)
CODE_HEADER({$^},{SINDEX})
_C{       Assume the extra segment points to the data segment }
        POP     AX      _C{ char}
        POP     CX      _C{ count}
        POP     DI      _C{ addr}
        OR      SI,SI   _C{Clear zero flag.}
        CLD             _C{ INC DIRECTION}
        REPNZ     SCASB   _C{ Compare BYTE}
        JZ      SINDEX1
        XOR     DI,DI    _C{Not found: 0}
        INC     DI
SINDEX1:
        DEC     DI
        PUSH    DI
        _NEXT
_C
worddoc( {STRING},{$/},{string_slash},{sc c --- sc1 sc2},{},
{Find the first forthvar({c}) in the forthdefin({string constant})
forthvar({sc}) and split it at that address. Return the strings
after and before forthvar({c}) into forthvar({sc1}) and
forthvar({sc2}) respectively. If the character is not present
forthvar({sc1}) is a null string _VERBOSE_({{(its address is
zero)}}) and forthvar({sc2}) is the original string.
_VERBOSE_({{Both }forthvar({sc1}){ and }forthvar({sc2}){ may be
empty strings (i.e. their count is zero), if }forthvar({c}){ is
the last or first character in }forthvar({sc}){ .}}) },
{{$^},{CORA},{$@@}},
{{ 132 "ORANG" &O $/ . DROP TYPE . },{0 RANG132},
{ "ORANG OETAN" BL $/ TYPE TYPE },{ORANGOETAN},
{ "ORANG" &G $/ TYPE 0 . TYPE },{ORAN0 },
{ 132 "ORANG" &Z $/ TYPE . . .},{ORANG0 0 132 }},
enddoc)
CODE_HEADER({$/},{SSLAS})
_C{       Assume the extra segment points to the data segment }
        POP     AX      _C{ char}
        POP     CX      _C{ count}
        MOV     BX,CX
        POP     DI      _C{ addr}
        OR      DI,DI   _C{Clear zero flag.}
        MOV     DX,DI   _C{ Copy}
        CLD             _C{ INC DIRECTION}
        REPNZ     SCASB   _C{ Compare BYTE}
        JZ      SSLAS1
_C{ Not present.}
        PUSH    CX   _C{ Nil pointer.}
        JMP SHORT SSLAS2
SSLAS1:
        PUSH    DI
        SUB     BX,CX
        DEC     BX      _C{Delimiter is not part of first string.}
SSLAS2:
        PUSH    CX   _C{Remaining length}
        PUSH    DX   _C{Start of first string.}
        PUSH    BX   _C{Skipped length.}
        _NEXT
_C
worddoc( {MEMORY},{ERASE},{erase},{addr n ---},{ISO},
{This is shorthand for forthsamp({0 FILL}).},
{{BLANK},{FILL}},
{{ !CSP HERE 41 C, 41 C, 41 C, 41 C, DUP 3 ERASE dnl
    COUNT . COUNT . COUNT . COUNT . DROP},{0 0 0 41} },
enddoc)
_HEADER({ERASE},{LERASE},{DOCOL})
        DC      ZERO
        DC      FILL
        DC      SEMIS
_C
_LOAD_({
worddoc( {MEMORY},{BLANK},,{addr count ---},{ISO},
{This is shorthand for ``forthcode({BL}) forthcode({FILL})''.},{},
{{ !CSP HERE 41 C, 41 C, 41 C, 41 C, DUP 3 BLANK dnl
    COUNT . COUNT . COUNT . COUNT . DROP},{20 20 20 41} },
enddoc)
_HEADER({BLANK},{BLANK},{DOCOL})
        DC      LBL
        DC      FILL
        DC      SEMIS
})_C{}_END_({_LOAD_})
_C
worddoc( {FORMATTING},{HOLD},{hold},{c ---},{ISO,FIG},
{Add the character forthvar({c}) to the beginning of the output
string. It must be executed for numeric formatting inside a
forthcode({<#}) and forthcode({#>}) construct . },
{{#},{DIGIT}},
{ { <# 1 0 # 41 HOLD # #> TYPE },{0A1} },
enddoc)
_HEADER({HOLD},{HOLD},{DOCOL})
        DC      LIT,-1
        DC      HLD
        DC      PSTOR
        DC      HLD
        DC      FETCH
        DC      CSTOR
        DC      SEMIS
_C
worddoc( {DICTIONARY},{PAD},{pad},{--- addr},{ISO,FIG},
{Leave the address of the text output buffer, which is a fixed offset
above forthcode({HERE}). The area growing downward from forthcode({PAD}) is used
for numeric conversion.
The use of forthcode({PAD}) is reserved for applications.
},{},
{{4321 PAD ! PAD @ .},{4321 } },
enddoc)
_HEADER({PAD},{PAD},{DOCOL})
        DC      HERE
_C{ Allow for a one line name, a double binary number and some hold char's}
        DC      LIT,84+128+64
        DC      PLUS
        DC      SEMIS
_C
_LOAD_({
worddoc( {PARSING},{WORD},{word},{c ---addr},{ISO,FIG,WANT},
{Parse the forthsamp({current input source}) using forthvar({c}) for a delimiter.
Skip leading delimiters then advance the input pointer to past
the next delimiter or past the end of the input source.
Leave at forthvar({addr}) a copy of the string,
that was surrounded by forthvar({c}) in the input source.
This is an oldfashioned string to be fetched by forthcode({COUNT}) , not forthcode({$@@}) .
In ciforth the character string is positioned
at the dictionary buffer forthcode({HERE}) .
forthcode({WORD}) leaves the character count in the first byte, the characters, and
ends with two or more blanks.
},
{{NAME},{PARSE},{BLK} ,{IN}},
{{1 LOAD  "WORD" WANTED : GS1 BL WORD COUNT . C@ EMIT ; GS1 CELLO},{5 C},
{ : GS2 5A WORD COUNT DUP . TYPE ; GS2 QQZ},{2 QQ},
{ : GS3 5A WORD COUNT DUP . TYPE ; GS3 ZZZQQZ},{2 QQ}
},
enddoc)
_SUPPRESSED({{
_HEADER({WORD},{IWORD},{DOCOL})
        DC      LDUP, LBL, EQUAL
        _0BRANCH(IWORD1)
         DC      DROP
         DC      LNAME
        _BRANCH(IWORD2)
IWORD1: DC      TOR
IWORD3:  DC      PPFET, RR, EQUAL
        _0BRANCH(IWORD4)
        DC      DROP
        _BRANCH(IWORD3)
IWORD4:
        DC      DROP
        DC      LIT, -1, PP, PSTOR _C{ Backtrace to first non-delimiter.}
        DC      FROMR, PARSE
_C{        DC      DOTS}
IWORD2:
        DC      HERE
        DC      LIT,0x22
        DC      BLANK
        DC      HERE
        DC      SSTORBD     _C{ FIXME}
        DC      HERE
_C{        DC      DOTS}
        DC      SEMIS
}})_C{}_END_({ _SUPPRESSED})
_C
})_C{}_END_({_LOAD_})
worddoc( {PARSING},{CHAR},{char}, {--- c},{ISO,I},
{Parse a word and
leave forthvar({c}) the first non blank char of that word in the
input source.
If compiled the searching is done while
the word being compiled is executed.
Because this is so confusing,
it is recommended that
one never compiles or postpones forthcode({CHAR}).
},
{{Prefix_&},{[CHAR]},{'}},
{{CHAR HELL .},{48 },
{CHAR X  .},{58 },
{: GS1 CHAR ; GS1 HELLO . },{48 },
{: GS2 CHAR ; GS2 X .},{58 }},
enddoc)
_HEADER({CHAR},{LCHAR},{DOCOL})
        DC      LNAME, DROP, CFET
        DC      SEMIS
_C
worddocsafe( {PARSING},{[CHAR]},{bracket_char_bracket}, {--- c},{ISO I},
{A compiling word. Parse a word.  Add the run time behaviour:
leave forthvar({c}), the first non blank char of that word in the
input source. In ciforth this word works also in interpret mode.},
{{Prefix_&},{CHAR}},
{},
{{: GS1 [CHAR] HELLO ; GS1 HEX . },{48 },
{: GS2 [CHAR] X ; GS2 HEX .},{58 }}, enddoc)
_HEADER({[CHAR]},{BCHAR},{DOCOL}, , B_IMMED)
        DC      LCHAR, LITER
        DC      SEMIS
_C
worddocsafe( {FORMATTING~},{(NUMBER)},{paren_number},{ --- d1},{},
{Convert the ASCII text at the
forthdefi({current input source}) with regard to forthcode({BASE}) .
The new value is
accumulated into double number forthvar({d1}) , being left. A
decimal point, anywhere, signifies that the input is to be
considered as a double. ISO requires it to be at the end of the
number. ciforth allows any number of decimal points with the
same meaning. ciforth also allows any number of comma's that
are just ignored, to improve readability. If the first
unconvertible digit is not a blank, this is an error.
This word is used by all number prefixes.
},
{{NUMBER},{?BLANK},{Prefix_7}},
{
{ (NUMBER) 1324 D.},{1324},
{ (NUMBER) 1abcdefgh D.},
{ (NUMBER) 1abcdefgh ? ciforth ERROR # 10 : NOT A WORD, NOR A NUMBER OR OTHER DENOTATION}
},
enddoc)
_HEADER({(NUMBER)},{PNUMB},{DOCOL})
        DC      ZERO, ZERO
        DC      ZERO, DPL, STOR
NPNUM1:  DC      PPFET   _C{ BEGIN}
        DC      LDUP, LIT, ADOT, EQUAL
        _0BRANCH(NPNUM2) _C{ case 1 }
        DC      DROP, DPL, STOR
        _BRANCH(NPNUM1) _C{ continue }
NPNUM2:
        DC      LDUP, LIT, ',', EQUAL
        _0BRANCH(NPNUM3) _C{ case 2 }
        DC      TDROP
        _BRANCH(NPNUM1) _C{ continue }
NPNUM3:
        DC      LDUP, QBL, ZEQU
        _0BRANCH(NPNUM5)  _C{ while }
        DC      NIP
        DC      BASE, FETCH, DIGIT
        DC      ZEQU
        DC      LIT, 10, QERR

        DC      SWAP
        DC      BASE
        DC      FETCH
        DC      USTAR
        DC      DROP
        DC      ROT
        DC      BASE
        DC      FETCH
        DC      USTAR
        DC      DPLUS
        _BRANCH(NPNUM1) _C{ repeat }
NPNUM5:
        DC      TDROP
        DC      SEMIS
_C
worddoc( {FORMATTING~},{NUMBER},{number},{ ---  s/d},{},
{
This word is intended to be called from (aliased as)
single character denotation
words, marked as forthcode({PREFIX}) forthcode({IMMEDIATE}).
Therefore it decrements the parse pointer to include this first
character.
Starting with this character, it converts characters from the current input source
into a number, and compiles or executes this number, depending on forthcode({STATE}).
If the string contains a decimal point it is a double else a single integer number.
If numeric conversion is not possible, an error message will be given.
Any comma's in the number are ignored, to help in structuring large numbers.
_VERBOSE_({{Traditionally comma's also signified double precision numbers.}})
_VERBOSE_({{Revectoring forthcode({NUMBER}) affects all applicable number prefixes.
In this way floating point numbers can be accomodated.
}})
},
{{BASE},{(NUMBER)}},
{{ (NUMBER) 1324 D.},{1324} },
enddoc)
_HEADER({NUMBER},{NUMB},{DOCOL})
LNUMB:
        DC      LIT, -1, PP, PSTOR
        DC      PNUMB, SDLITE
        DC      SEMIS
_C
_LOAD_({
worddoc( {FORMATTING},{>NUMBER},{to_number},
{ud1 addr1 u1 --- ud2 addr2 u2},
{ISO},
{
forthvar({ud2}) is the result of converting the characters
within the character string specified by forthvar({addr1 u1})
into digits, using the number in forthcode({BASE}) , and adding
each into ud1 after multiplying forthvar({ud1}) by the number
in forthcode({BASE}) . Conversion continues until a character
that is not convertible is encountered or the string is
entirely converted. forthvar({addr2}) is the location of the
first unconverted character or the first character past the end
of the string if the string was entirely converted.
forthvar({u2}) is the number of unconverted characters in the
string. If forthvar({ud2}) overflows, in ciforth
forthvar({ud2}) will be incorrect, but no crash will result.
_VERBOSE_({{Both
}forthkey({-}){ and }forthkey({+}){ are considered unconvertible
character's by }forthsamp({>NUMBER}){ .}})
},
{{NUMBER},{DIGIT},{DPL}},
{
{ 0. "1324" >NUMBER . 4 - 4 TYPE D.},{0 13241324},
{ 0. "1324.KL" >NUMBER DUP . TYPE D.},{3 .KL1324},
}, enddoc)
_HEADER({>NUMBER},{TONUMB},{DOCOL})
        DC      TDUP, PLUS, TOR     _C{ End available on return stack.}
        DC      ZERO
        _QDO(TONUM9)
TONUM1:
        DC      LDUP, CFET, BASE, FETCH, DIGIT
        DC      ZEQU
        _0BRANCH(TONUM4) _C{ IF}
        DC      DROP
        DC      LLEAV
TONUM4:
        DC      SWAP, TOR _C{ Address out of the way.}
        DC      SWAP
        DC      BASE
        DC      FETCH
        DC      USTAR
        DC      DROP
        DC      ROT
        DC      BASE
        DC      FETCH
        DC      USTAR
        DC      DPLUS
        DC      FROMR, ONEP     _C{ Address back.}
        _LOOP(TONUM1)
TONUM9:
        DC      FROMR
        DC      OVER, LSUB
        DC      SEMIS
_C
})_C{}_END_({_LOAD_})
worddoc( {DICTIONARY},{FOUND},{found},{sc --- dea},{},
{ Look up the string forthvar({sc}) in the dictionary observing
the current search order. If found, leave the dictionary
entry address forthvar({dea}) of the first entry found, else
leave a forthdefin({nil pointer}). If the first part of the string
matches a forthdefi({denotation}) word, that word is found, whether
the denotation is correct or not.
The forthcode({dea}) allows to retrieve all properties of the word
such as whether it is immediate.
},
{{PP},{FIND}, {PRESENT}, {CONTEXT}, {(FIND)},{PREFIX} },
{ { 123 : BONOBO ; "BONOBO" FOUND ' BONOBO = . .},{_T_ 123},
dnl 1ONNOBO is found as a misspelled number!
{ 243 "1ONNOBO" FOUND 0= . .},{0 243},
{ 541 "MYBONOBO" FOUND . .},{0 541}
},
enddoc)
_HEADER({FOUND},{FOUND},{DOCOL})
        DC      CONTEXT, TOR
FOUND1: DC      RR, FETCH
_C{        DC      DOTS}
        DC      PFIND, LDUP, ZEQU
        _0BRANCH(FOUND3)
        DC      DROP
        DC      RR, FETCH, LIT, ONLYBODY, LSUB _C{Was this ONLY?}
        _0BRANCH(FOUND2)
        DC      FROMR, CELLP, TOR
        _BRANCH(FOUND1)
FOUND2: DC      ZERO
FOUND3: DC      RDROP
        DC      NIP,NIP
        DC      SEMIS
_C
worddoc( {DICTIONARY},{PRESENT},{present},{sc --- dea},{},
{ If the string forthvar({sc}) is present as a word name in the
current search order, return its forthvar({dea}), else leave a
forthdefi({nil pointer}). For a forthdefi({denotation}) word, the
name must match forthvar({sc}) exactly.},
{{FOUND}, {CONTEXT}, {(FIND)},{NAMESPACE}, {FIND} },
{ { 123 : BONOBO ; "BONOBO" PRESENT ' BONOBO = . .},{_T_ 123},
dnl 1ONNOBO is not present though it is a misspelled number
{ 243 "1ONNOBO" PRESENT 0= . .},{-1 243},
{ 541 "MYBONOBO" PRESENT . .},{0 541}
},
enddoc)
_HEADER({PRESENT},{PRESENT},{DOCOL})
        DC      LDUP, TOR
        DC      FOUND
        DC      LDUP
        _0BRANCH(PRES1)
        DC      LDUP
        DC      TNFA, FETCH, FETCH _C{  Get precise length.}
        DC      RR, EQUAL
        DC      LAND
PRES1:
        DC      RDROP
        DC      SEMIS
_C

worddoc( {DICTIONARY},{FIND},{find},{addr ---xt 1/xt -1/addr 0},{ISO,WANT},
{For the forthdefi({old fashioned string}) _VERBOSE_({{(stored with a
preceding character count)}}) at forthvar({addr}) find a Forth
word in the current search order.
Return its
execution token forthvar({xt}). If the word is immediate, also
return 1, otherwise also return -1. If it is not found, leave
the original forthvar({addr}) and a zero.
In ciforth the alternative forthcode({FOUND}) is used,
that uses a regular string, hence this is a loadable extension.
},
{{FOUND},{CONTEXT},{PRESENT},{(FIND)}},
{
{ 1 LOAD  "FIND" WANTED : FIND: BL WORD FIND ; dnl
123 : BONOBO ; FIND: BONOBO . ' BONOBO = . .},{-1 _T_ 123},
{ IMMEDIATE 142 FIND: BONOBO . ' BONOBO = . .},{1 _T_ 142},
dnl don't find the next, though it is a denotation
{ 153 FIND: BONNOBO . HERE - ABS 30 U< . .},{0 _T_ 153},
},
enddoc)
_SUPPRESSED({{
_HEADER({FIND},{FIND},{DOCOL})
        DC      LDUP, COUNT, PRESENT
        DC      LDUP
        _0BRANCH(FIND1) _C{IF}
        DC      NIP _C{ The address.}
        _C{ Fine point, get xt by TCFA. Even if a NOOP.}
        DC      LDUP, TCFA, SWAP
        DC      TFFA, FETCH
        DC      LIT, B_IMMED, LAND
        DC      LIT, -1, SWAP
        _0BRANCH(FIND1) _C{IF}
        DC      NEGATE
FIND1:               _C{THEN THEN}
        DC      SEMIS
}})_C{}_END_({ _SUPPRESSED})
_C
_EXTRAFIELD_({
worddocsafe( {DICTIONARY~},{OPT},{optimiser},
{sc dea --- sc dea1},{},
{
This is a vector in behalf of optimisation,
that starts as a noop, and
can be filled in if the extra field is used for optimisation.
It must adhere to the following specification:
Search down from the forthdefi({dea}) forthvar({dea}) for a
word with name forthvar({sc}).
Replace forthvar({dea}) with forthvar({dea1}) if the dictionary
part between both could not contain the name searched for.
forthvar({dea1}) being a null pointer means that the dictionary
doesn't contain the name.
},
{{~MATCH},{FIND},{>XFA}},
{ { "WORDS" 'WORDS OPT ID. TYPE },{WORDS WORDS} },
enddoc)
_HEADER({OPT},{OPT},{DOCOL})
        DC      SEMIS
})
_C
worddocsafe( {DICTIONARY~},{(FIND)},{paren_find},
{sc wid --- sc dea},{},
{Search down from the forthdefi({WID}) forthvar({wid}) for a
word with name forthvar({sc}).
_VERBOSE_({{A }forthdefi({WID}){ is
mostly a dummy }forthdefi({dea}){ found in the
data field of a
namespace, fetched from }forthcode({CURRENT}){ or an other wid in the
}forthdefi({search order}){ }}). Leave the dictionary entry address
forthvar({dea}) of the first entry found, else leave a zero.
Do not consume the string forthvar({sc})_VERBOSE_({{,
as this is a repetitive action}}). },
{{~MATCH},{FOUND},{PRESENT},{>WID}},
{ { : BONOBO ; "BONOBO" CURRENT @ (FIND) ' BONOBO = .},{_T_},
 {TYPE},{BONOBO} },
enddoc)
_HEADER({(FIND)},{PFIND},{DOCOL})
_C{ The idea is to have a fast slim loop.}
_C{ The optimisation tries to skip, using the extra links.}
_C{ At all labels the stack is (sc, dea).}
_C{ PFIND0 : nothing known yet about dea}
_C{ PFINDM1 : dea has no optimisation possibilities any more}
_C{ PFINDM2 : dea has a possible match: ~MATCH returns 0(=equal)}
_C{ PFIND1 : dea is a match, inasfar name and prefix}
_C{ PFIND2 : dea is the match, or null.}

PFIND0:                       _C{Start of fast loop}.
        _EXTRAFIELD_({DC      OPT                   _C{ (Speed optimisation).}
        DC      LDUP
        _0BRANCH(PFIND2)
})        DC      NMATCH
        _0BRANCH(PFINDM2)
PFINDM1:
        DC      TLFA, FETCH
        DC      LDUP, ZEQU
        _0BRANCH(PFIND0)      _C{End of fast loop}.

_C{ Exit for end of chain (fall through)}
        _BRANCH(PFIND2)
_C{ Exit for possible match}
_C{ ~MATCH is sure in determining a no-match,}
_C{ a possible match must be investigated closely.}
PFINDM2:
_C
_C{ Discard, because name too short to match dea, can't be a denotation.}
        DC      TDUP, TNFA, FETCH, FETCH
        DC      LESS, ZEQU
        _0BRANCH(PFINDM1)
_C
_C{ Equal: found, barring invisibility and dummy entries.}
        DC      TDUP, TNFA, FETCH, FETCH
        DC      LSUB
        _0BRANCH(PFIND1)
_C
_C{ Discard, unless dea is a denotation ("prefix")}
        DC      LDUP, TFFA, FETCH
        DC      LIT, B_DENOT, LAND
        _0BRANCH(PFINDM1)

_C{ Discard still, if invisible ("smudged") or dummy.}
PFIND1:
        DC      LDUP, TFFA, FETCH
        DC      LIT, B_INVIS _OR_ B_DUMMY, LAND
        DC      ZEQU
        _0BRANCH(PFINDM1)

PFIND2:
        DC      SEMIS
_C
worddoc( {ERRORS},{ERROR},{error},{n ---},{},
{Notify the user that an uncaught exception or
error with number forthvar({n}) has occurred.
The word that caused it is found using forthcode({WHERE}) and displayed .
Also forthvar({n}) is passed to forthcode({MESSAGE}) in order to give a description
 of the error, clamped to the range [M4_ERRORMIN, M4_ERRORMAX].
This word is executed by forthcode({THROW}) before restarting the interpreter
and can be revectored to give more elaborate diagnostics,
or even do a last minute recovery. },
{{MESSAGE},{?ERROR},{WARNING}},
{ {0 WARNING ! 0. WHERE 2! 12 ERROR},{ ? ciforth ERROR # 18 },
 {CR},{} },
enddoc)
_HEADER({ERROR},{LERROR},{DOCOL})
_C{ Make sure the whole word is shown in case of denotations. }
        DC      LWHERE, TFET
        DC      OVER
        _0BRANCH( ERR2)      _C{ Virgin: print empty string.}
        DC      OVER, LIT, 20, LSUB
        DC      MAX
        DC      SWAP
        DC      ONEM         _C{Backup for if we are at next word.}
ERR1:   DC      LDUP, CFET, QBL, ZEQU  _C{Show whole word!}
        _0BRANCH( ERR2 )
        DC      ONEP
        _BRANCH( ERR1 )
ERR2:
        DC      OVER, LSUB
        DC      ETYPE
        _STRINGINLINE({ ? ciforth ERROR # })
        DC      ETYPE
        DC      BASE, FETCH
        DC      DECA
        DC      OVER
        DC      STOD, ZERO, PDDOTR      _C{This is about (.) }
        DC      ETYPE
        DC      BASE, STOR
        DC      LIT, M4_ERRORMIN, MAX
        DC      LIT, M4_ERRORMAX, MIN
        DC      LIT, MESS, CATCH, DROP  _C{Prevent error loops }
        DC      SEMIS
_C
worddoc( {ERRORS},{CATCH},{catch},{... xt --- ... tc },{ISO},
{Execute forthvar({xt}). If it executes successfully, i.e. no
forthcode({THROW}) is executed by forthvar({xt}), leave a zero
into forthvar({tc}) in addition to any stack effect
forthvar({xt}) itself might have. Otherwise in forthvar({tc})
the non-zero throw code is left, and the stack depth is
restored. The values of the parameters for
forthvar({xt}) could have been modified. _VERBOSE_({{In
general, there is nothing useful that can be done with those
stack items.}}) Since the stack depth is known, the application
may forthcode({DROP}) those items.},
{{THROW},{QUIT},{HANDLER}},
{{' NOOP CATCH .},{0},
{: GS1 1 2 3 12 THROW ; 33 ' GS1 CATCH 44 . . .},{44 12 33}
},
enddoc)
_HEADER({CATCH},{CATCH},{DOCOL})
        DC      SPFET, CELLP, TOR
        DC      HANDLER, FETCH, TOR
        DC      RPFET, HANDLER, STOR
        DC      EXEC
        DC      FROMR, HANDLER, STOR
        DC      RDROP, ZERO
        DC      SEMIS
_C
worddoc( {ERRORS},{THROW},{throw},{... tc --- ... / ... tc},{ISO},
{If forthvar({tc}) is zero, it is merely discarded. If we are
executing under control of a forthcode({CATCH}) , see
forthcode({CATCH}) for the effect of a non-zero
forthvar({tc}). If we are executing not under control of a
forthcode({CATCH}), a non-zero forthvar({tc}) gives a message to the effect
that this exception has occurred and starts Forth anew.
},
{{CATCH},{QUIT},{HANDLER},{?ERROR},{ERROR}},
{{: GS1 PP @ SRC @ WHERE 2! 1 2 3 12 THROW ; GS1 },
{ 2 3 12 THROW ; GS1 ? ciforth ERROR # 18 },
 {CR},{} },
enddoc)
_HEADER({THROW},{THROW},{DOCOL})
        DC      LDUP
        _0BRANCH(THROW1)
        DC      HANDLER, FETCH, ZEQU
        _0BRANCH(THROW2)
        DC      LERROR
        DC      SZERO, FETCH, SPSTO
        DC      QUIT
THROW2:
        DC      HANDLER, FETCH, RPSTO
        DC      FROMR, HANDLER, STOR
        DC      FROMR, SWAP, TOR
        DC      SPSTO
        DC      FROMR
        DC      X
THROW1:
        DC      DROP
        DC      SEMIS
_C
_LOAD_({
worddocsafe( {ERRORS~},{(ABORT")},{paren_abort_quote},{f ---},{},
{The run time action of forthcode({ABORT"}) .},
{},
{{( See abort_quote)},{}},
enddoc)
_HEADER({(ABORT")},{PABORTQ},{DOCOL})
        DC      ROT
        _0BRANCH(PABQ1) _C{IF}
        DC      ETYPE
        DC      ABORT
        _BRANCH(PABQ2) _C{ELSE}
PABQ1:  DC       TDROP
PABQ2:   DC      SEMIS
_C
worddocsafe( {ERRORS},{ABORT"},{abort_quote},{f ---},{ISO,I,C},
{Usage is forthsamp({: <SOME> ... ABORT" <message>" ... ;}). If
ABORT" finds a non-zero forthvar({f}) on the stack, the
forthsamp({<message>}) is displayed and an
forthcode({ABORT}) is executed. Otherwise proceed with the
words after forthsamp({<message>}). This word can only be used
in compile mode.
},
{{?ERROR}},
{{ 0 WARNING ! 1  ABORT" APE" }, {WARNING ! 1 ABORT" ? ciforth ERROR # 17 },
{CR : GS1 0 ABORT" APE" 123 ; GS1 .},{123},
dnl The warm start message is filtered away!
{: GS2 1 ABORT" APE" 123 ; GS2 .},{APE}
},
enddoc)
_HEADER({ABORT"},{ABORTQ},{DOCOL},,B_IMMED)
        DC      QCOMP
        DC      DENQ
        DC      LIT, PABORTQ, COMMA
        DC      SEMIS
_C
})_C{}_END_({_LOAD_})
worddoc( {DICTIONARY},{ID.},{i_d_dot},{dea ---},{},
{Print a definition's name from its dictionary entry address.
For dummy entries print nothing. },
{{'},{>FFA},{>NFA}},
{ { : GORILLA ; ' GORILLA ID.},{GORILLA} },
enddoc)
_HEADER({ID.},{IDDOT},{DOCOL})
        DC      LDUP, TFFA, FETCH
        DC      LIT, B_DUMMY, LAND
        _0BRANCH(IDDOT1)
        DC      DROP
        _BRANCH(IDDOT2)
IDDOT1:
        DC      TNFA
        DC      FETCH
        DC      SFET
        DC      LTYPE
        DC      SPACE
        DC      SPACE
        DC      SPACE
IDDOT2:
        DC      SEMIS
_C
_C
worddoc( {DEFINING~},{HEADER},{header},{sc --- dea},{},
{Create a dictionary entry structure for the word forthvar({sc}) and
returns its address into forthvar({dea}).
_VERBOSE_({A pointer to each of its fields is called a "field address" for
code data flag line name _SOURCEFIELD_({source}) _EXTRAFIELD_({extra}).
In particular note that a data field address is not a forthdefi({data field})
in the ISO sense.})
 forthcode({HEADER}) initializes the forthdefi({code field addres}) and
forthdefi({data field address}) to contain a same pointer
to the area owned by this header,
i.e. immediately following the completed header _VERBOSE_({{as
appropriate for a low level (assembler) definition}}).
The flag and link fields are initialised to
zero _VERBOSE_({{, so not }forthcode({HIDDEN}){}}).
The name forthvar({sc}) is laid down in the dictionary before
the header and filled in into the name field.
_SOURCEFIELD_({{The source field is filled in to best knowledge.}})
},
{{(CREATE)},{>CFA},{>DFA},{>FFA},{>LFA},{>NFA},{>SFA},{>XFA},{LINK}},
{{"FRED" HEADER >NFA @ $@ TYPE},{FRED}},
enddoc)
_HEADER({HEADER},{LHEAD},{DOCOL})
        DC      LDUP
        DC      ZEQU
        DC      LIT, 5, QERR
        DC      TDUP
        DC      PRESENT
        DC      LDUP
        _0BRANCH(CREA1) _C{IF}
        DC      TNFA, FETCH, SFET
        DC      ETYPE
        DC      LIT,4
        DC      MESS
        DC      X       _C{THEN}
CREA1:  DC      DROP
_ALIGNED_({ DC      LALIGN},{dnl})
        DC      SCOMMA
_ALIGNED_({ DC      LALIGN},{dnl})
        DC      HERE,TOR

        DC      RR, TPHA, COMMA         _C{Code field.}
        DC      RR, TPHA, COMMA         _C{Data field.}
        DC      ZERO, COMMA _C{Flag field.}
        DC      ZERO, COMMA _C{Link field.}
        DC      COMMA   _C{Name field.}

_SOURCEFIELD_({
        DC      BLK, FETCH, LDUP, ZEQU
        _0BRANCH(CREA2)
        DC      DROP, PP, FETCH
CREA2:  DC      COMMA  _C{Source field.}
},{dnl})
        _EXTRAFIELD_({DC      ZERO, COMMA
})        DC      FROMR
        DC      SEMIS
_C
worddoc( {DEFINING~},{LINK},{link},{dea wid ---},{},
{Links the Forth word represented by forthvar({dea}) into the wordlist
represented by forthvar({wid}) as the latest entry.
_VERBOSE_({Alternatively{,} consider forthvar({wid}) as an other
forthvar({dea2}). Link forthvar({dea}) between the forthvar({dea2})
and its successor in the linked list.})
},
{{HEADER},{(CREATE)}},
{{"FRED" HEADER CURRENT @ LINK ' FRED LATEST = .},{_T_}},
enddoc)
_HEADER({LINK},{LLINK},{DOCOL})
        DC      TLFA
        DC      TDUP
        DC      FETCH
        DC      SWAP, TLFA, STOR
        DC      STOR
        DC      SEMIS
_C
worddocsafe( {DEFINING~},{(CREATE)},{paren_create},{sc ---},{},
{This is the basis for all defining words, including
_VERBOSE_({those which lack a data field in the ISO sense: })dnl
forthcode({:}) forthcode({USER}) forthcode({VARIABLE})
forthcode({NAMESPACE}) forthcode({CONSTANT}) forthcode({DATA}) .
It creates a header with name forthvar({sc}) in the dictionary and
links it into the forthcode({CURRENT}) word list.
},
{{HEADER},{LINK},{CREATE}},
{{"FRED" (CREATE) ' FRED LATEST = .},{_T_}},
enddoc)
_HEADER({(CREATE)},{PCREAT},{DOCOL})
        DC      LHEAD
        DC      CURR, FETCH
        DC      LLINK
        DC      SEMIS
_C
worddocsafe( {COMPILING},{[COMPILE]},{bracket_compile},{},{ISO,I,C},
{Used in a colon-definition in the form:
forthexample({:  xxx ... [COMPILE] IF ...  ;})
forthcode({[COMPILE]}) will force the compilation of an immediate definition,
that would otherwise execute during compilation.
The above example will perform forthcode({IF}) when forthsamp({xxx})
executes, rather than introducing conditional code in forthsamp({xxx})
itself.
},{{POSTPONE}},
{ {: MY-IF [COMPILE] IF ; IMMEDIATE dnl
 : JAN MY-IF 1 ELSE 2 THEN . ; ?CSP 0 JAN 1 JAN},{2 1},
{ [COMPILE] NON-EXISTING },
{MPILE] NON-EXISTING ?  ciforth ERROR # 16},
{CR 0 WARNING !   IF},{CR 0 WARNING !   IF ? ciforth ERROR # 17 },
 {CR 1 WARNING !},{}
},
enddoc)
_HEADER({[COMPILE]},{BCOMP},{DOCOL}, , B_IMMED)
        DC      LNAME
        DC      PRESENT
        DC      LDUP
        DC      ZEQU
        DC      LIT, 16, QERR
        DC      TCFA
        DC      COMMA
        DC      SEMIS
_C
worddoc( {COMPILING},{POSTPONE},{postpone},{},{ISO,I,C},
{Used in a colon-definition in the form:
    forthexample({: xxx POSTPONE SOME-WORD })
forthcode({POSTPONE}) will postpone the
compilation behaviour of forthsamp({SOME-WORD}) to the
definition being compiled. If forthsamp({SOME-WORD}) is an immediate word
this is similar to forthsamp({[COMPILE] SOME-WORD}). },
{{[COMPILE]}},
{
{!CSP : GS1 POSTPONE BL ; : GS2 [ GS1 ] ; GS2 .},{20},
{: MY-IF POSTPONE IF ; IMMEDIATE dnl
: IAN MY-IF 1 ELSE 2 THEN . ; ?CSP 0 IAN 1 IAN},{2 1},
{ 0 WARNING ! POSTPONE NON-EXISTING }, {STPONE NON-EXISTING ?  ciforth ERROR # 15},
dnl This must not find 7 in the ONLY wordlist
{CR POSTPONE 7F89 .}, {CR POSTPONE 7F89 ? ciforth ERROR # 15}
},
enddoc)
_HEADER({POSTPONE},{POSTP},{DOCOL}, , B_IMMED)
        DC      LNAME
        DC      PRESENT
        DC      LDUP
        DC      ZEQU
        DC      LIT, 15, QERR
        DC      LDUP, TFFA, FETCH
        DC      LIT, B_IMMED, LAND, ZEQU
        _0BRANCH(POSTP1)
         DC      LIT, LIT, COMMA
         DC      COMMA
         DC      LIT, COMMA
POSTP1:
         DC      COMMA
        DC      SEMIS
_C
worddoc( {COMPILING},{LITERAL},{literal},{n --- n (executing) n --- (compiling)}, {ISO,I,C},
{If compiling, then compile the stack value forthvar({n}) as a
_BITS_ bit literal.
_VERBOSE_({{The intended use is:
     }forthsamp({: xxx    [ calculate ]  LITERAL  ;}){
Compilation is suspended for the compile time calculation of a
value. Compilation is resumed and }forthcode({LITERAL}){ compiles
this value.}}) Later execution of the definition containing the literal will
push it to the stack. If executing, the number will just remain on
the stack.},
{{LIT},{SDLITERAL},{STATE}},
{ {: GS3 [ 45 ] LITERAL EMIT ; GS3},{E} },
enddoc)
_HEADER({LITERAL},{LITER},{DOCOL}, , B_IMMED)
        DC      STATE
        DC      FETCH
        _0BRANCH(LITE1) _C{IF}
        DC      LIT, LIT, COMMA
        DC      COMMA   _C{THEN}
LITE1:  DC      SEMIS
_C
worddoc( {COMPILING},{DLITERAL},{dliteral},{d --- d (executing) d --- (compiling)},{I},
{If compiling, compile a stack double number into a literal.
Later execution of the definition containing the literal will
push it to the stack. If executing, the number will just remain on
the stack.},{{LITERAL},{LIT},{STATE}},
{ {: GS3 [ 0.46 ] DLITERAL DROP EMIT ; GS3},{F} },
enddoc)
_HEADER({DLITERAL},{DLITE},{DOCOL}, , B_IMMED)
        DC      STATE
        DC      FETCH
        _0BRANCH(DLIT1) _C{ IF}
        DC      SWAP
        DC      LITER
        DC      LITER   _C{ THEN}
DLIT1:  DC      SEMIS
_C
_C
worddoc( {COMPILING~},{SDLITERAL},{sdliteral},
{d --- s/d (executing) / d --- (compiling)},{I},
{If compiling, compile a stack double number into a literal or
double literal, depending on whether forthcode({DPL}) contains a
forthdefi({nil pointer}) or points into the input. Later execution of the
definition containing the literal will push it to the stack. If
executing, the number will remain on the stack.},
{{LITERAL},{DLITERAL},{STATE}},
{
{: GS1 [ 45 0 ] SDLITERAL EMIT ; GS1},{E},
{: GS2 [ 0.46 ] SDLITERAL DROP EMIT ; GS2},{F},
},
enddoc)
_HEADER({SDLITERAL},{SDLITE},{DOCOL}, , B_IMMED)
        DC      DPL
        DC      FETCH
        _0BRANCH(SDLIT1) _C{ IF}
        DC      DLITE
        _BRANCH(SDLIT2) _C{ IF}
SDLIT1:
        DC      DROP, LITER
SDLIT2:
        DC      SEMIS
_C
_SECURITY_({
worddoc( {SECURITY},{?STACK},{question_stack},{},{},
{Issue an error message if the stack is out of bounds.},
{{?ERROR}},
{{ S0 @ DSP! ?STACK},{},
{0 WARNING ! : GS1 DROP ?STACK ;},{},
dnl Do not use the part of TIB that is corrupted!
 {                               GS1},{      GS1 ? ciforth ERROR # 1 },
 {CR},{} },
enddoc)
_HEADER({?STACK},{QSTAC},{DOCOL})
        DC      SPFET
        DC      SZERO
        DC      FETCH
        DC      SWAP
        DC      ULESS
        DC      ONE, QERR
        DC      SPFET
        DC      HERE
        DC      LIT,0x80
        DC      PLUS
        DC      ULESS
        DC      LIT, 7, QERR
        DC      SEMIS
        PAGE
})_C{}_END_({_SECURITY_})
_C
worddoc( {PARSING},{INTERPRET},{interpret},{?? --- ??},{},
{Repeatedly fetch the next text word from the
forthdefi({current input source}) and
execute it (forthcode({STATE}) is 0) or compile it
(forthcode({STATE}) is 1). A word is blank-delimited and looked
up in the vocabularies of forthdefi({search-order}).
It can be either matched exactly, or it can match a prefix.
If it is matched regularly the parse pointer remains after the
blank delimiter as required by ISO.
If a word matches a prefix, forthcode({INTERPRET}) sets back the
parse pointer to immediately after the prefix,
A word that matches a prefix is called a forthdefi({denotation});
mostly this is a number.
If it is not found at all, it is an forthcode({ERROR}).
Prefixes are present in forthcode({ONLY}) which
comprises the minimum search order and is always present as
the last wordlist in the search order.
An application can add prefixes in whatever namespace is suitable.
A forthdefi({denotation}) is a number, a double number, a
character or a string etc. Denotations are handled
respectively by the words
forthcode({0}) ... forthcode({F}) forthcode({&}) forthcode({"}) and
any other word of the
forthcode({ONLY}) wordlist, depending on the first characters.
The denotation parsing is extendable, e.g. after loading a floating
point package floating point numbers are recognized.
character or characters.
_VERBOSE_({{
A number is converted according to the current base.
If a decimal point is found as part of a number, the number
value that is left is a double number, otherwise it is a single
number.
Comma's in numbers are ignored by ciforth.}})
},
{{NAME},{(NUMBER)},{NUMBER},{BLK},{DPL}},
{{( No test)},{}},
enddoc)
_HEADER({INTERPRET},{INTER},{DOCOL})
INTE1:
        DC      LNAME
        DC      LDUP      _C{ Zero length.}
        _0BRANCH(INTE8) _C{WHILE}
_C{       DC      DOTS}
_C{       DC      TDUP, LTYPE}
        DC      OVER, TOR       _C{ Save old parse pointer.}
        DC      FOUND
        DC      LDUP, ZEQU
        DC      LIT, 12, QERR
        DC      LDUP, TFFA, FETCH
        DC      LDUP, LIT, B_DENOT, LAND _C{Retain copy of flags.}
        _0BRANCH(INTE3B) _C{IF}
        DC      OVER, TNFA, FETCH, FETCH
        DC      RR, PLUS, PP, STOR  _C{Skip over prefix.}
INTE3B:                  _C{THEN }
        DC      RDROP           _C{ Drop old parse pointer.}
        DC      LIT, B_IMMED, LAND
        DC      STATE, FETCH, ZEQU, LOR
        _0BRANCH(INTE3) _C{IF}
        DC      EXEC
        _BRANCH(INTE4) _C{IF}
INTE3:
        DC      COMMA
                        _C{THEN}
INTE4:
        _SECURITY_({DC      QSTAC})
        _BRANCH(INTE1)  _C{AGAIN}
INTE8:  DC      DROP, DROP
        DC      SEMIS
_C
worddoc( {DICTIONARY},{IMMEDIATE},{immediate},{},{},
{Mark the most recently made definition so that when encountered at
compile time, it will be executed rather than being compiled, i.e.
the immediate bit in its header is set.
This method allows definitions to handle special compiling
situations, rather than build them into the fundamental compiler.
The user may force compilation of an immediate definition by
preceding it with forthcode({POSTPONE}) .},{},
{ { : GS1 &Z EMIT ; IMMEDIATE : GS2 GS1 ;},{Z}},
enddoc)
_HEADER({IMMEDIATE},{IMMED},{DOCOL})
        DC      LATEST
        DC      TFFA
        DC      LIT, B_IMMED
        DC      TOGGL
        DC      SEMIS
_C
worddoc( {DICTIONARY},{PREFIX},{prefix},{},{},
{Mark the most recently made definition a forthdefi({prefix}).
If searching the wordlists for a name that starts with the prefix,
the prefix is a match for that name.
This method allows to define numbers, and other
forthdefi({denotation})'s such as strings, in a modular and extensible
fashion.
A prefix word finds the interpreter pointer pointing to
the remainder of the name (or number) sought for, and must compile
that remainder. Some prefixes, like forthcode({Prefix_7}), decrement the
parse pointer by one before starting to parse.
Prefix words are mostly both immediate and forthdefi({smart}),
i.e. they behave differently when compiled, than interpreted.
The result is that the compiled code looks the same and behaves the
same than the interpreted code.
Postponing prefix words voids your warranty.
 _VERBOSE_({It is recommended that the only smart words present are
 prefix words.}) },
{{PP@@@@}, {IMMEDIATE},{Prefix_0},{ONLY}},
{ { : Q &Z EMIT NAME TYPE ; PREFIX QPO},{ZPO}},
enddoc)
_HEADER({PREFIX},{PREFX},{DOCOL})
        DC      LATEST
        DC      TFFA
        DC      LIT, B_DENOT
        DC      TOGGL
        DC      SEMIS
_C
worddoc( {DEFINING},{NAMESPACE},{namespace},{},{},
{A defining word used in the form:
forthcode({NAMESPACE}) forthsamp({cccc}) to create a
namespace definition forthsamp({cccc}) . It will create a
forthdefi({word list})in the ISO sense. Subsequent use of
forthsamp({cccc}) will push this word list (the
forthdefi({word list associated with}) forthsamp({cccc})) to the top of
the search order in forthcode({CONTEXT}). So it will be
searched first by forthcode({INTERPRET}) .
A word create by forthcode({NAMESPACE}) is not immediate.
_VERBOSE_({This is also different among Forth implementations.})

A namespace 's data content field contains at first the dovoc
pointer (like for any forthcode({DOES>}) word) , then follows
its body. The body contains the namespace ("vocabulary") link
field address ( forthdefi({VLFA}) ). The VLFA points to the VLFA
of the next namespace  or  a forthdefi({nil pointer}) for the end.
Then follows a dummy dea that serves
as forthdefi({word list identifier}) or forthdefi({WID}) in the sense of the ISO standard.
It has empty fields, except for the link field.
The forthdefi({link field address}) contains the forthdefi({dea}) of the latest word of
the namespace or a forthdefin({nil pointer}) if empty. Executing the
namespace means pushing its WID on top of the
forthcode({CONTEXT}) order. In ciforth when there can be
at most M4_MAXWORDLIST word list 's in the search order, the
oldest one gets lost. The vocabularies generated are
forthcode({IMMEDIATE}) words.},
{{VOC-LINK},{DEFINITIONS},{FOR-VOCS},{>WID}},
{{123 NAMESPACE JOHN .},{123},
{123 JOHN . ONLY FORTH},{123}},
enddoc)
_HEADER({NAMESPACE},{VOCAB},{DOCOL})
        DC      LCREATE
        DC      LATEST   _C{ Link this DEA into VOC-LINK chain.}
        DC      VOCL
        DC      FETCH
        DC      COMMA
        DC      VOCL
        DC      STOR
        DC      ZERO, COMMA   _C{ Dummy code field}
        DC      ZERO, COMMA   _C{ Dummy data field}
        DC      LIT, B_DUMMY, COMMA _C{ Dummy flag field}
        DC      ZERO, COMMA _C{Link field: empty chain}
        DC      LIT, _DATA_FIELD(ZERO), COMMA _C{Empty string for name.}
        _SOURCEFIELD_({DC      ZERO, COMMA}, {dnl})
        _EXTRAFIELD_({DC      ZERO, COMMA}, {dnl})
        DC      DOES
DOVOC:
        DC      ALSO
        DC      CELLP   _C{ Make it a WID. }
        DC      CONTEXT
        DC      STOR
        DC      SEMIS
        PAGE
_C
_C{   The link to task is a cold start value only.}
_C{   It is updated each time a definition is}
_C{   appended to the 'FORTH' namespace.}
_C
worddoc( {WORDLISTS},{ASSEMBLER},{assembler},{},{WANT,NISO,FIG},
{The name of the namespace that contains machine code definitions.
In ciforth execution it pushes the associated word list to the
top of the forthcode({CONTEXT}) stack. (A traditional forthcode({VOCABULARY})
would replace the top.)
This word makes only sense in combination with the words that
belong to it. So it is present in loadable form in the screens
file forthfile({forth.lab}) .},
{{NAMESPACE},{LOAD}},
{{( No test) },{}},
enddoc)
_C
worddoc( {WORDLISTS},{DEFINITIONS},{definitions},{},{ISO},
{Used in the form:
           forthsamp({cccc DEFINITIONS})
Make the top most forthdefi({search order}) word list, (context),
the compilation word list (current).
In the example, executing
namespace name forthsamp({cccc}) add it to the top of the
forthdefi({search order}) and executing
forthcode({DEFINITIONS}) will result in new definitions added to
forthsamp({cccc}) .},
{{CONTEXT},{NAMESPACE}},
{
  { NAMESPACE JOHN JOHN DEFINITIONS : ORAN ; dnl
  ' FORTH >WID >LFA @ ' ORAN = .},{0},
  {' JOHN >WID >LFA @ ' ORAN = .},{_T_},
  {FORTH DEFINITIONS},{}
},
enddoc)
_HEADER({DEFINITIONS},{DEFIN},{DOCOL})
        DC      CONTEXT
        DC      FETCH
        DC      CURR
        DC      STOR
        DC      SEMIS
_C
worddoc( {WORDLISTS},{ALSO},{also},{},{ISO},
{Duplicate the topmost forthdefi({WID}) in the search order stack.
If there were already M4_MAXWORDLIST WID 's,
ciforth looses the last one.
This is not counting
the forthcode({ONLY}) search order.
_VERBOSE_({{You seldomly need to use this word, because in ciforth
by executing a namespace you add it to the order.
This is different than the words defined by the customary
forthcode({VOCABULARY}) that replaces the topmost wordlist.
}})},
{{CONTEXT},{NAMESPACE}},
{
  { NAMESPACE JOHN ALSO ' JOHN >WID CONTEXT ! DEFINITIONS dnl
  : ORAN ; ' FORTH >WID >LFA @ ' ORAN = .},{0},
  {' JOHN >WID >LFA @ ' ORAN = .},{_T_},
  {FORTH DEFINITIONS},{}
},
enddoc)
_HEADER({ALSO},{ALSO},{DOCOL})
        DC      CONTEXT, LDUP, CELLP
        DC      LIT, _CELLS(M4_MAXWORDLIST-1)
        DC      LMOVE
        DC      LIT, ONLYBODY  _C{End sentinel for array of word lists.}
        DC      CONTEXT, LIT, _CELLS(M4_MAXWORDLIST), PLUS
        DC      STOR _C{Trim sets of wordset.}
        DC      SEMIS
_C
worddoc( {WORDLISTS},{PREVIOUS},{PREVIOUS},{},{ISO},
{Pop the topmost forthdefi({WID}) from the search order stack.
If empty still the forthcode({ONLY}) search order is left.},
{{CONTEXT},{NAMESPACE}},
{
  { CONTEXT @ NAMESPACE JOHN JOHN DUP CONTEXT @ = .},{0},
  { PREVIOUS CONTEXT @ = .},{_T_}
},
enddoc)
_HEADER({PREVIOUS},{PREVI},{DOCOL})
        DC      CONTEXT, LDUP, CELLP, SWAP
        DC      LIT, _CELLS(M4_MAXWORDLIST)
        DC      LMOVE
        DC      SEMIS
_C
dnl _left_parenthesis_ is replaced by ')' in the makefiles.
worddocsafe( {PARSING},{_left_parenthesis_},{paren},{},{ISO,FIG,I},
{Used in the form: forthsamp({{_left_parenthesis_ cccc)}}). Ignore a comment that
will be delimited by a right parenthesis that must be in the
same input source, i.e. on the same line for terminal input, or
in the same string, block or file, when that is the input. It
is an immediate word. _VERBOSE_({So colon definitions can
be commented too}).
A blank after the word forthsamp({{_left_parenthesis_}}) is required.},
{{\}},
{{( Nothing to be seen) 8374 U.},{8374} },
enddoc)
_HEADER({(},{PAREN},{DOCOL}, , B_IMMED)
        DC      LIT,')'
        DC      PARSE
        DC      TDROP
        DC      SEMIS
_C
_C
worddocsafe( {PARSING},{\},{backslash},{},{ISO,I},
{Used in the form:
forthsamp({\ cccc})
Ignore a comment that will be delimited by the end of the current line.
May occur during execution or in a colon-definition.
Blank space after the word forthcode({\}) is required.},
{{(}},
{{\ Nothing to be seen 8374 .
},{} },
enddoc)
_HEADER({\},{BACKS},{DOCOL}, , B_IMMED)
_C{ Backup one character, just in case we are at the end of a line.}
        DC      LIT, -1, PP, PSTOR
        DC      LIT,ALF
        DC      PARSE
        DC      TDROP
        DC      SEMIS
_C
worddoc( {INITIALISATIONS},{QUIT},{quit},{},{ISO,FIG},
{Restart the interpreter. Clear the return stack, stop
compilation, and return control to the operators terminal,
or to the redirected input stream.
This means forthcode({(ACCEPT)}) user input to somewhere in the
terminal input buffer, and
then forthcode({INTERPRET}) with that as a forthcode({SOURCE}) .
No message is given.},
{{TIB},{ABORT}},
{{1243 QUIT
  . },{1243} },
enddoc)
_HEADER({QUIT},{QUIT},{DOCOL})
        DC      LBRAC
QUIT1:                  _C{BEGIN}
        DC      RZERO
        DC      FETCH
        DC      RPSTO
        DC      LIT
        DC      PACCEP
        DC      CATCH
        DC      LDUP, LIT, -EPIPE, EQUAL
        _0BRANCH(ENDIF7)
        DC      BYE     _C{End of input, no error!}
ENDIF7:
        DC      QERRUR
        DC      ONEP
        DC      SETSRC
        DC      INTER
        DC      OK
        _BRANCH(QUIT1)  _C{AGAIN}
        DC      SEMIS   _C{Unnecessary, but helpful for decompilation.}
_C
worddoc( {INITIALISATIONS},{OK},{ok},{},{ISO,FIG},
{Takes care of printing the okay-message, after interpreting
a line. Default it prints ``OK'' only for an interactive session
in interpret forthcode({STATE}).
_VERBOSE_({It can be revectored to show debugging info or give a prompt.})
},
{{QUIT},{COLD}},
{{OK ( Gives OK unless interpreted from stream)},{},
{: GS1 STATE @ 1 STATE ! OK STATE ! ; GS1},{}},
enddoc)
_HEADER({OK},{OK},{DOCOL})
        DC      STATE
        DC      FETCH
        DC      ZEQU
        _0BRANCH(OK2) _C{IF}
        _STRINGINLINE({ OK})   _C{THEN}
        DC      LTYPE
        DC      CR
OK2:
        DC      SEMIS
_C
worddoc( {INITIALISATIONS},{ABORT},{abort},{},{ISO,FIG},
{Restart the interpreter. In addition and before the actions of
forthcode({QUIT}), clear also the data stack and
reset the exception mechanism.
_VERBOSE_({{This word is silent. This may be confusing
at times, because you can't tell the difference between a word
that is still busy or that has aborted.}})
},{{WARM},{_INIT}},
{{( No test)},{}},
enddoc)
_HEADER({ABORT},{ABORT},{DOCOL})
        DC      SZERO, FETCH, SPSTO
        DC      ZERO, HANDLER, STOR
        DC      QUIT
        DC      SEMIS   _C{Unnecessary, but helpful for decompilation.}
_C
_C{      WARM START VECTOR COMES HERE}
_C{      For booting code we enter here, real mode and using the switchsegment.}
_C{      BY control BREAK.}
WARM_ENTRY:
_BOOTED_({
SET_16_BIT_MODE         _C{Pops back at next _SWITCH_}
        MOV     SPO,_CELL_PTR[USINI+_CELLS(2)]    _C{PARAM. STACK}
        MOV     RPO,_CELL_PTR[USINI+_CELLS(3)]    _C{RETURN STACK}
_C{Without this clearing of the disk status, the system hangs too.}
        XOR     {AX},{AX}
        MOV     DL, DRIVE
        INT     0x13     _C{Reset floppy disk system.}
        XOR     {AX},{AX}
        MOV     DL, 0x80
        INT     0x13     _C{Reset hard disk system.}
_C{Without this clearing of the keyboard status, the system hangs at}
_C{the next call of KEY (INT 0x10 function 0x0E)}
        XOR     {AX},{AX}
        MOV     DS,{AX}
        MOV     [0x417],{AX}
        MOV     [0x496],{AX} _C{This should improve things, but doesn't.}
})_C{}_END_({ _BOOTED_})

        _SWITCH_({JMPHERE_FROM_OS})
        JMP USINI+_CELLS(-2)
_C
worddoc( {INITIALISATIONS},{WARM},{warm},{},{FIG},
{Perform a so called "warm" start.
Reinitialise the system as per forthcode({INIT}).
Show the signon message and restart via forthcode({ABORT}) .
},{{ABORT}},
{{( No test)},{}},
enddoc)
_HEADER({WARM},{WARM},{DOCOL})
        DC      INIT
        DC      SIGNON
        DC      ABORT
        DC      SEMIS   _C{Unnecessary, but helpful for decompilation.}
_C
_HOSTED_({
worddoc( {INITIALISATIONS},{OPTIONS},{options},{ft --- f2},{CI},
{Handle command line option.
If an option is given at startup, execute the screen corresponding
to the option letter and return a false flag into forthvar({f2}),
otherwise leave a true flag.
This is used to suppress the signon message if there is an option.
_VERBOSE_({ An option screen can always decide to execute
forthcode({.SIGNON}). By redefining forthcode({OPTIONS}) as
forthsamp({DROP 0}){,} the handling of options during cold boot is
suppressed{,} useful for turnkey applications. }) },{{COLD}},
{{( No test)},{}},
enddoc)
_HEADER({OPTIONS},{OPTIONS},{DOCOL})
_C{       Execute option.}
_HOSTED_X_(
{        DC      ARGS, FETCH, CELLP, CELLP, FETCH, LDUP
        _0BRANCH(OPT4) _C{ No options}  })
_DLL_(
{       DC      ARGS, FETCH
        DC     ZERO, INVERT
        DC     ZERO, SSLAS, SETSRC
        DC     LNAME, TDROP
        DC     LNAME
        _0BRANCH(OPT4) _C{ No options}
})
_PC_(
{        DC      LIT, 0x81
OPT1:
        DC      LDUP, CFET, LBL, EQUAL
        _0BRANCH(OPT2)            _C{ Skip blanks.}
        DC      ONEP
        _BRANCH(OPT1)
OPT2:   DC      LDUP, CFET, LIT, ACR, UNEQ
        _0BRANCH(OPT4) _C{ No options}  })

_C{Supposedly on the stack is now a pointer to the option.}
        DC      COUNT
_PC_(
{       DC      LIT, 0x0FD, LAND    _C{Accept / as well as -.}})
        DC      LIT, '-', UNEQ
        _0BRANCH(OPT3)
        DC      LIT, 3, LDUP, LERROR
        DC      XCODE, STOR, BYE
OPT3:
        DC      CFET
        DC      LIT, 0x1F, LAND
        DC      LLOAD       _C{Supposedly stack-neutral.}
        DC      ZERO, SWAP _C{ Sign on suppressed.}
OPT4:
        DC      DROP
        DC      SEMIS
})_C{}_END_({_HOSTED_})

worddoc( {INITIALISATIONS},{COLD},{cold},{},{FIG},
{Initialise all user variables to their boot up values values,
i.a. the stacks and the forthdefin({dictionary pointer}) .
Initialise the system as per forthcode({_INIT}).
Handle command line options, if any, as per forthcode({OPTIONS}).
Show signon message and restart via forthcode({ABORT}) .
May be called from the terminal to remove application
programs and restart, as long as there are no
new vocabularies with definitions.
_HOSTED_({But it is better to say forthcode({BYE}) to Forth and start again.})
_BOOTED_({But it is better to reboot.})
},{{WARM},{_INIT},OPTIONS},
{{( No test)},{}},
enddoc)
_HEADER({COLD},{COLD},{DOCOL})
_C{ Fill user area for single task.}
        DC      LIT, USINI      _C{ Fails if SP/RP are not usable!}
        DC      LIT, USINI+_CELLS(1), FETCH
        DC      LIT, US
        DC      LCMOVE
        DC      INIT
        DC      ONE            _C{ Sign on wanted.}
_DLL_({
        DC      LCOMMAND, DROP, ARGS, STOR
})_C{}_END_({_DLL_})
_HOSTED_X_({
        DC      ZERO, LIT, TCGETS, TERMIO
        DC      LIT, ioctl, XOS, ZLESS
        _0BRANCH(COLD1)
        _C{ Not a terminal. Cannot set the terminal, get rid of "OK".}
        DC      DROP, ZERO      _C{ Sign on suppressed.}
        DC      LIT,TASK  _C{ Suppress OK for pipes.}
        DC      LIT,OK
        DC      LIT, _CELLS(3), LCMOVE
COLD1:
})_C{}_END_({_HOSTED_X_})
_HOSTED_(
{        DC      OPTIONS})
        _0BRANCH(COLD5)
        DC      SIGNON    _C{ Suppressed for scripting! Or any options.}
COLD5:
        DC      ABORT
        DC      BYE     _C{ In case of turnkey programs.}
        DC      SEMIS   _C{ Unnecessary, but helpful for decompilation.}
_C
worddoc( {INITIALISATIONS},{_INIT},{init},{},{FIG},
{Initialise or reinitialise the system.
Reset the data stack, the search order, the number base and the
exception mechanism.
Initialise the block mechanism.
Any blocks that have not yet been
written back to mass storage are discarded.
_BLOCKSINFILE_({Now open the file that contains the blocks{,} in read-only mode.})
_VERBOSE_({After forthcode({_INIT}) we have the following situation.
The search order contains the forthcode({FORTH}) words{,}
plus forthcode({ONLY}) with i.a. number handling.
Definitions are added to the forthcode({FORTH}) forthdefi({namespace}).
The number base is decimal.   })
},{{WARM},{COLD},{FORTH},{BLOCK-INIT},{BASE},{S0}},
{{( No test)},{}},
enddoc)
_HEADER({_INIT},{INIT},{DOCOL})
        DC      SZERO, FETCH, SPSTO
        DC      ZERO, HANDLER, STOR
        DC      DECA
        DC      ONLY, FORTH, DEFIN
_BLOCKSINFILE_({
        DC      LIT, 0, BLINI  _C{Default, open library file read-only!}},{
        DC      MTBUF
})_C{}_END_({_BLOCKSINFILE_})
_DLL_({
        DC      CALLOPEN, LIT, STD_INPUT_HANDLE, PAR1, LIT, _GetStdHandle@4, ICALLCLOSE
        DC      LIT, STDIN+(CW*(D_HOFFSET)), STOR
        DC      CALLOPEN, LIT, STD_OUTPUT_HANDLE, PAR1, LIT, _GetStdHandle@4, ICALLCLOSE
        DC      LIT, STDOUT+(CW*(D_HOFFSET)), STOR
        DC      CALLOPEN, LIT, STD_ERROR_HANDLE, PAR1, LIT, _GetStdHandle@4, ICALLCLOSE
        DC      LIT, STDERR+(CW*(D_HOFFSET)), STOR
})_C{}_END_({_DLL_})
        DC      SEMIS
_C{}
_DLL_({
worddoc( {OPERATINGSYSTEM},{LOAD-DLL},{load_dll},{ sc --- n},{},
{forthvar({n}) is the handle of a DLL library with name forthvar({sc}).
Warning: for a compiled program you must postpone fetching this handle
until the program is run, you can't do it at compile time.
},
{DLL-ADDRESS},
{{ "kernel32.dll" LOAD-DLL DUP 0= . CONSTANT K32},{0},
 { "GetLastError" K32 DLL-ADDRESS 0= . },{0} },
enddoc)
_HEADER({LOAD-DLL},{LOLI},{DOCOL} )
        DC      CALLOPEN, ZEN, PAR1
        DC      LIT, _LoadLibraryA@4, ICALLCLOSE
        DC      LDUP, TOERR, THROW
        DC      SEMIS
_C
worddoc( {OPERATINGSYSTEM},{COMMAND-LINE},{command_line},{ --- sc },{},
{forthvar({sc}) is the command line with which this forth is invoked. },
{},
_BITS32_({
{{ COMMAND-LINE TYPE }, {wina.exe},
 { LAST-ERROR .}, {0} },
})
_BITS64_({
{{ COMMAND-LINE TYPE }, {wina64.exe},
 { LAST-ERROR .}, {0} },
})
enddoc)
_HEADER({COMMAND-LINE},{LCOMMAND},{DOCOL} )
        DC      CALLOPEN, LIT, _GetCommandLineA@0, ICALLCLOSE
        DC      ZERO, INVERT, ZERO
        DC      SSLAS, TSWAP, TDROP
        DC      SEMIS
_C
worddoc( {OPERATINGSYSTEM},{DLL-ADDRESS},{dll_address},{ sc u --- addr},{},
{Return the address forthvar({addr}) of the procedure with name forthvar({sc})
from dll library with handle forthvar({u}).
Provide it with correct parameters and you can use it with forthcode({CALL}).
},{LOAD-DLL},
{ {." See LOAD-DLL"},{See LOAD-DLL} },
enddoc)
_HEADER({DLL-ADDRESS},{DLLADR},{DOCOL})
        DC      CALLOPEN, PAR1, ZEN, PAR2
        DC      LIT, _GetProcAddress@8, ICALLCLOSE
        DC      LDUP, TOERR, THROW
        DC      SEMIS
_C
_C
worddoc( {OPERATINGSYSTEM},{LAST-ERROR},{last_error},{ --- n},{},
{Get the last error from MS-windows, the value of a global variable.
Windows functions can indicate this global variable is set,
by returning a -1, a 0, or a NULL.
It can indicate success, by returning a positive value,
or a non-zero value, or by resetting this global variable to zero.
},{CALL},
{{ LAST-ERROR .},{0} },
enddoc)
_HEADER({LAST-ERROR},{GLE},{DOCOL})
        DC      CALLOPEN, LIT, _GetLastError@0, ICALLCLOSE
        DC      SEMIS
_C
worddoc( {ERRORS},{>ERROR},{query_error_windows},{n --- err},{},
{
Assuming forthvar({n}) was returned by a windows forthcode({CALL})
turn it into a ciforth error code.
If forthsamp({n}) is zero or positive, this may mean okay.
If it is negative, it is indicates an error condition.
This error is now combined with
that fetched by forthcode({LAST-ERROR}) and negated.
If this indicates no error, the original error is returned.
If a library function looks like c-compatible it probably follows
this convention, but you have to look this up for each call.
A mnemonic for it is typed using forthsamp({MESSAGE}).
},
{{CALL},{ERROR},{?ERROR}, {MESSAGE}},
{
{0 >ERROR .},{0},
{0 WARNING ! -20 >ERROR . },{-20},
},
enddoc)
_HEADER({>ERROR},{TOERR},{DOCOL})
        DC      ZERO, MIN, LDUP
        _0BRANCH(ERI1)
        DC      GLE, NEGATE, MIN
ERI1:
        DC      SEMIS
_C
worddoc( {OUTPUT},{STDIN},{standard_in},{ --- n},{},
{The handle to the file input buffer for the console.
},{},
_BITS32_({ {{ STDIN 100 < . },{_T_} }, })
_BITS64_({ {{ STDIN 1000 < . },{_T_} }, })
enddoc)
_HEADER({STDIN},{STDIN},{DOCON}, 0)
_C
worddoc( {OUTPUT},{STDOUT},{standard_out},{ --- n},{},
{The file descriptior for standard output at the console.},{},
_BITS32_({ {{ STDOUT 100 < . },{_T_} }, })
_BITS64_({ {{ STDOUT 1000 < . },{_T_} }, })
enddoc)
_HEADER({STDOUT},{STDOUT},{DOCON}, 1 )
_C
worddoc( {OUTPUT},{STDERR},{standard_err},{ --- n},{},
{The file descriptior for standard error output at the console.},{},
_BITS32_({ {{ STDERR 100 < . },{_T_} }, })
_BITS64_({ {{ STDERR 1000 < . },{_T_} }, })
enddoc)
_HEADER({STDERR},{STDERR},{DOCON}, 2)
})_C{}_END_({_DLL_})
worddoc( {DOUBLE},{S>D},{s_to_d},{n --- d},{ISO},
{Sign extend a single number to form a double number.},{},
{{ 0 S>D D.},{0},
 { 1 S>D D.},{1},
 { -1 S>D D.},{-1} },
enddoc)
CODE_HEADER({S>D},{STOD})
        POP     DX      _C{S1}
        SUB     AX,AX
        OR      DX,DX
        JNS     STOD1   _C{POS}
        DEC     AX      _C{NEG}
STOD1:
        _2PUSH
_C
worddoc( {OPERATOR},{ABS},{abs},{n --- u},{ISO,FIG},
{Leave the absolute value of forthvar({n}) as forthvar({u}) .},
{{DABS}},
{
{ 0  ABS .},{0 },
{ 1  ABS .},{1 },
{ -1 ABS .},{1}
},
enddoc)
_HEADER({ABS},{LABS},{DOCOL})
        DC      LDUP
        DC      ZLESS
        _0BRANCH(PM1)   _C{IF}
        DC      NEGATE   _C{THEN}
PM1:
        DC      SEMIS
_C
worddoc( {DOUBLE},{DABS},{d_abs},{d --- ud},{ISO,FIG},
{Leave the absolute value forthvar({ud}) of a double number forthvar({d}) .},
{{DNEGATE},{ABS}},
{
{ 0.  DABS D.},{0},
{ 1.  DABS D.},{1},
{ -1. DABS D.},{1}
},
enddoc)
_HEADER({DABS},{DABS},{DOCOL})
        DC      LDUP
        DC      ZLESS
        _0BRANCH(DPM1)  _C{IF}
        DC      DNEGA   _C{THEN}
DPM1:
        DC      SEMIS
_C
worddoc( {OPERATOR},{MIN},{min},{n1 n2 --- min},{ISO,FIG},
{Leave the smaller of two numbers.},{{MAX}},
{{ 204 240 MIN .},{204},
 { -204 -240 MIN .},{-240} },
enddoc)
_HEADER({MIN},{MIN},{DOCOL})
        DC      TDUP
        DC      GREAT
        _0BRANCH(MIN1)  _C{IF}
        DC      SWAP    _C{THEN}
MIN1:   DC      DROP
        DC      SEMIS
_C
worddoc( {OPERATOR},{MAX},{max},{n1 n2 --- max},{ISO,FIG},
{Leave the greater of two numbers.},{{MIN}},
{{ 204 240 MAX .},{240},
 { -204 -240 MAX .},{-204} },
enddoc)
_HEADER({MAX},{MAX},{DOCOL})
        DC      TDUP
        DC      LESS
        _0BRANCH(MAX1)  _C{IF}
        DC      SWAP    _C{THEN}
MAX1:   DC      DROP
        DC      SEMIS
_C
worddoc( {OPERATOR},{LSHIFT},,{u1 n --- u2},{ISO},
{Perform a forthemph({{logical {{{shift}}} }}) of the bits of
forthvar({u1}) to the left by forthvar({n}) places.
_VERBOSE_({{Put zero into the places uncovered by the {{{{shift}}}}.}}) },
{{RSHIFT},{2*}},
{{1 2 LSHIFT .},{4}},
enddoc)
CODE_HEADER({LSHIFT},{LSHIFT},{DOCOL})
        POP     CX
        POP     AX
        SHL     AX,CL
        _PUSH
_C
worddoc( {OPERATOR},{RSHIFT},,{u1 n --- u2},{ISO},
{Perform a forthemph({{logical {{{shift}}} }}) of the bits of
forthvar({u1}) to the right by forthvar({n}) places.
_VERBOSE_({{Put zero into the places uncovered by the {{{{shift}}}}.}}) },
{{LSHIFT},{2/}},
{{4 2 RSHIFT .},{1}},
enddoc)
CODE_HEADER({RSHIFT},{RSHIFT},{DOCOL})
        POP     CX
        POP     AX
        SHR     AX,CL
        _PUSH
_C
worddoc( {MULTIPLYING},{M*},{m_star},{n1 n2 --- d},{ISO,FIG},
{A mixed magnitude math operation which leaves the double
number forthvar({d}) : the signed product of two signed number
forthvar({n1}) and forthvar({n2}) .},
{{M/MOD},{SM/REM},{*}},
{ { -1 -1 M* D. },{1},
  {DECIMAL 240 204 M* D.},{48960} },
enddoc)
CODE_HEADER({M*},{MSTAR})
        POP     AX
        POP     BX
        IMUL     BX      _C{SIGNED}
        XCHG    AX,DX   _C{AX NOW = MSW}
        _2PUSH          _C{STORE DOUBLE CELL}
_C
worddoc( {MULTIPLYING},{SM/REM},{m_slash},{d n1 --- n2 n3},{ISO},
{A mixed magnitude math operator which leaves the signed
remainder forthvar({n2}) and signed quotient forthvar({n3})
from a double number dividend forthvar({d}) and divisor
forthvar({n1}). This is a symmetric division{{}}_VERBOSE_({{, i.e.
the remainder takes its sign from the
dividend.}})},
{{M/MOD}, {FM/MOD},{/},{M*}},
{
{  7 S>D  3 SM/REM . . },{2   1},
{  7 S>D -3 SM/REM . . },{-2   1},
{ -7 S>D  3 SM/REM . . },{-2  -1},
{ -7 S>D -3 SM/REM . . },{2  -1}
},
enddoc)
CODE_HEADER({SM/REM},{MSLAS})
        POP     BX      _C{DIVISOR}
        POP     DX      _C{MSW OF DIVIDEND}
        POP     AX      _C{LSW OF DIVIDEND}
        IDIV     BX      _C _BITS_ {BIT DIVIDE}
        _2PUSH          _C{STORE QUOT/REM}
_C
worddoc( {SUPERFLUOUS},{2/},{two_slash},{n1 --- n2},{ISO},
{Perform an arithmetical {{shift}} right.
The bit pattern of forthvar({n1}) is shifted to the right, except that
the left most bit (``sign bit'') remains the same, called "arithmetic shift".
_VERBOSE_({{ On this 2-complement machine this is the same as
}forthsamp({2 /}) {.}})},
{{2*} },
{
{2 2/ . },{1},
{-2 2/ . },{-1},
{-1 2/ . },{-1},
},
enddoc)
_SUPPRESSED({
_HEADER({2/},{TWOSL},{DOCOL})
        DC      STOD, TWO, FMSLAS
        DC      NIP
        DC      SEMIS
})_C{}_END_({_SUPPRESSED})
CODE_HEADER({2/},{TWOSL})
        POP     AX      _C{(S1) <- (S1) + (S2)}
        SAR     AX,1
        _PUSH

_C
worddoc( {SUPERFLUOUS},{2*},{two_star},{n1 --- n2},{ISO},
{Perform an arithmetical {{shift}} left.
The bit pattern of forthvar({n1}) is shifted to the left,
with a result identical to forthsamp({1 LSHIFT}).},
{{2/} },
{
{  2 2* . },{4},
{  -2 2* . },{-4},
},
enddoc)
_SUPPRESSED({
_HEADER({2*},{TWOST},{DOCOL})
        DC      TWO, STAR
        DC      SEMIS
})_C{}_END_({_SUPPRESSED})
CODE_HEADER({2*},{TWOST})
        POP     AX      _C{(S1) <- (S1) + (S2)}
        SAL     AX,1
        _PUSH
_C
worddoc( {SUPERFLUOUS},{1-},{one_minus},{n1 --- n2},{ISO},
{ This is shorthand for forthsamp({1 -}). },
{{1+} },
{
{  2 1- . },{1},
{  -2 1- . },{-3},
},
enddoc)
_HEADER({1-},{ONEM},{DOCOL})
        DC      ONE, LSUB
        DC      SEMIS
_C
worddoc( {MULTIPLYING},{FM/MOD},{floored_slash},{d n1 --- n2 n3},{ISO},
{A mixed magnitude math operator which leaves the signed
remainder forthvar({n2}) and signed quotient forthvar({n3})
from a double number dividend forthvar({d}) and divisor
forthvar({n1}). This is floored division{{}}, i.e.
the remainder takes its sign from the divisor.},
{{SM/REM}, {M/MOD},{/},{M*}},
{
{  7 S>D  3 FM/MOD . . },{2   1},
{  7 S>D -3 FM/MOD . . },{-3   -2},
{ -7 S>D  3 FM/MOD . . },{-3  2},
{ -7 S>D -3 FM/MOD . .     6 S>D -3 FM/MOD . .},
{2  -1 -2   0}
},
enddoc)
_HEADER({FM/MOD},{FMSLAS},{DOCOL})
        DC      LDUP, TOR
        DC      TDUP, LXOR, TOR
        DC      MSLAS
        DC      FROMR, ZLESS
        _0BRANCH(FMMOD1)
        DC      OVER
        _0BRANCH(FMMOD1)
        DC      ONE, LSUB
        DC      SWAP, FROMR, PLUS, SWAP
        _BRANCH(FMMOD2)
FMMOD1:
        DC      RDROP
FMMOD2:
        DC      SEMIS
_C
worddocsafe( {OPERATOR},{*},{star},{n1 n2 --- n3},{ISO,FIG},
{Leave the signed product forthvar({n3}) of two signed numbers
forthvar({n1}) and forthvar({n2}) .},
{{+},{-},{/},{MOD}},
{
  {DECIMAL 24 204 * .},{4896},
  {DECIMAL -24 204 * .},{-4896}
},
enddoc)
_HEADER({*},{STAR},{DOCOL})
        DC      MSTAR
        DC      DROP
        DC      SEMIS
_C
worddoc( {OPERATOR},{/MOD},{slash_mod},{n1 n2 --- rem quot},{ISO,FIG},
{Leave the remainder and signed quotient of forthvar({n1}) and forthvar({n2}) .
The remainder has the sign of the dividend
(i.e. forthdefi({symmetric division})). },
{{*/MOD},{*/},{SM/REM}},
{
{  7  3 /MOD . . },{2   1},
{  7 -3 /MOD . . },{-2   1},
{ -7  3 /MOD . . },{-2  -1},
{ -7 -3 /MOD . . },{2  -1}
},
enddoc)
_HEADER({/MOD},{SLMOD},{DOCOL})
        DC      TOR
        DC      STOD
        DC      FROMR
        DC      MSLAS
        DC      SEMIS
_C
worddoc( {OPERATOR},{/},{slash},{n1 n2 --- quot},{ISO,FIG},
{Leave the signed quotient of forthvar({n1}) and forthvar({n2}) .
(using forthdefi({symmetric division})). },
{{+},{-},{*},{MOD},{*/MOD}},
{
{  7  3 / . },{2  },
{  7 -3 / . },{-2 },
{ -7  3 / . },{-2 },
{ -7 -3 / . },{2  }
},
enddoc)
_HEADER({/},{SLASH},{DOCOL})
        DC      SLMOD
        DC      NIP
        DC      SEMIS
_C
worddoc( {OPERATOR},{MOD},{mod},{n1 n2 --- mod},{ISO,FIG},
{Leave the remainder of forthvar({n1}) divided by forthvar({n2}) , with the same sign
as forthvar({n1}) (i.e. forthdefi({symmetric division})).},
{{+},{-},{*},{/},MOD,{*/MOD}},
{
{  7  3 MOD . },{1},
{  7 -3 MOD . },{1},
{ -7  3 MOD . },{-1},
{ -7 -3 MOD . },{-1}
},
enddoc)
_HEADER({MOD},{LMOD},{DOCOL})
        DC      SLMOD
        DC      DROP
        DC      SEMIS
_C
worddoc( {MULTIPLYING},{*/MOD},{start_slash_mod},{n1 n2 n3 --- n4 n5},{ISO,FIG},
{Leave the quotient forthvar({n5}) and remainder
forthvar({n4}) of the operation forthsamp({n1*n2/n3}) (using forthdefi({symmetric division})).
A double precision
intermediate product is used giving correct results, unless
forthvar({n4}) overflows. Then ciforth will give a floating point exception.
dnl The following is probably incorrect.
dnl _VERBOSE_({{ }forthsamp({n1 n2 * n3 /}){ gives an incorrect answer
dnl as soon as }forthsamp({n1 n2 *}){ overflows.}})
},
{{*/},{/MOD}},
{
{ 7 2 3   */MOD . . },{4  2 },
{ 7 2 -3  */MOD . . },{-4 2 },
{ -7 2 3  */MOD . . },{-4 -2 },
{ -7 2 -3 */MOD . . },{4 -2 }
},
enddoc)
_HEADER({*/MOD},{SSMOD},{DOCOL})
        DC      TOR
        DC      MSTAR
        DC      FROMR
        DC      MSLAS
        DC      SEMIS
_C
worddoc( {MULTIPLYING},{*/},{star_slash},{n1 n2 n3 --- n4},{ISO,FIG},
{Leave the ratio forthsamp({n4 = n1*n2/n3}) where all are signed
numbers(using forthdefi({symmetric division})).
A double precision
intermediate product is used giving correct results, unless
forthvar({n4}) overflows. Then ciforth will give a floating point exception.
},
{{*/MOD},{/MOD}},
{
{ 7 2 3   */ . },{4 },
{ 7 2 -3  */ . },{-4 },
{ -7 2 3  */ . },{-4 },
{ -7 2 -3 */ . },{4 },
}, enddoc)
_HEADER({*/},{SSLA},{DOCOL})
        DC      SSMOD
        DC      NIP
        DC      SEMIS
_C
worddoc( {MULTIPLYING},{M/MOD},{m_slash_mod},{ud1 u2 --- u3 ud4},{CIF,FIG},
{An unsigned mixed magnitude math operation which leaves a
double quotient forthvar({ud4}) and remainder forthvar({u3}) ,
from a double dividend forthvar({ud1}) and single divisor
forthvar({u2}).
},
{{UM/MOD},{SM/REM},{M*}},
_BITS16_({
{
{-1. -1 M/MOD D. .},{10001 0},
{ 88812.34 100 M/MOD D. .},{88812 34},
{DECIMAL 12.34 100 M/MOD D. .},{12 34},
} })
_BITS32_({
{
{-1. -1 M/MOD D. .},{100000001 0},
{ 8888812.34 100 M/MOD D. .},{8888812 34},
{DECIMAL 12.34 100 M/MOD D. .},{12 34},
} })
_BITS64_({
{
{-1. -1 M/MOD D. .},{10000000000000001 0},
{ 8888888812.34 100 M/MOD D. .},{8888888812 34},
{DECIMAL 12.34 100 M/MOD D. .},{12 34},
} })
,
enddoc)
_HEADER({M/MOD},{MSMOD},{DOCOL})
        DC      TOR
        DC      ZERO
        DC      RR
        DC      USLAS
        DC      FROMR
        DC      SWAP
        DC      TOR
        DC      USLAS
        DC      FROMR
        DC      SEMIS
_C
worddocsafe( {SCREEN},{(LINE)},{paren_line},{n1 n2 --- sc },{},
{Convert the line number forthvar({n1}) and the screen
forthvar({n2}) to a string forthvar({sc}) the content of the
line (without the trailing new line). },
{{LINE}},
{
{1 0 (LINE) TYPE}, { LICENSE }
},
enddoc)
_HEADER({(LINE)},{PLINE},{DOCOL})
        DC      TOR
        DC      LIT,64
        DC      MSTAR
        DC      BBUF
        DC      FMSLAS
        DC      FROMR _C{ This blocks, so is screens.}
        DC      PLUS
        DC      BLOCK
        DC      PLUS
        DC      LIT,63
        DC      SEMIS
_C
worddoc( {ERRORS},{ERRSCR},{error_screen},{--- addr},{},
{A variable containing the address of the number of the screen
from which messages are offset. Messages
correspond with lines and the offset
may be positive or negative.
forthsamp({0 MESSAGE}) prints the first line of this screen.
_VERBOSE_({{Traditionally this was screen 4, but the negative
Unix error numbers makes this infeasible.}})
},{{C/L},{MESSAGE}},
{{HEX ERRSCR ?},{30}},
enddoc)
_HEADER({ERRSCR},{ERRSCR},{DOVAR}, )
        DC ERRORSCREEN
_C
worddoc( {ERRORS},{MESSAGE},{message},{n ---},{},
{ forthcode({MESSAGE}) is generally used to print error and
warning messages.
If forthcode({WARNING}) is zero (disc unavailable), this is a noop.
Print on the _HOSTED_X_({standard error channel}) _PC_({output device})
the text of line
forthvar({n}) relative to screen forthcode({ERRSCR}) . forthvar({n}) may be
positive or negative and beyond just screen forthcode({ERRSCR}).
A certain range around 0 is reserved.
The messages with small positive offset contain ciforth error messages.
The messages with small negative offset contain
the strings belonging to the return values for _HOSTED_X_({_OS_ system calls}) _PC_({BDOS calls}).
forthsamp({0 MESSAGE}) will print version information about the library file
where the messages sit in.
},
{{ERROR},{BLOCK-FILE}},
{
{1 WARNING ! -180 MESSAGE}, {( -x :_This_option_is_available )},
{1 WARNING ! HEX 12 MESSAGE},{ : EXECUTION ONLY },
{0 WARNING ! HEX 12 MESSAGE},{}
},
enddoc)
_HEADER({MESSAGE},{MESS},{DOCOL})
        DC      LWARN
        DC      FETCH
        _0BRANCH(MESS1) _C{IF}
        DC      ERRSCR, FETCH
        DC      PLINE, ONEP     _C{ Also print the '\n' !}
        DC      ETYPE
        DC      X
MESS1:                  _C{THEN}
        DC      DROP
        DC      SEMIS
_C
worddocsafe( {MEMORY},{PC@@},{port_char_fetch},{port --- b},{},
{Fetch a byte forthvar({b}) from the port address
_HOSTED_X_({You can use ports only after asking permission
(using e.g. forthvar({ioperm}) ) and being super user.})
},
{{PC!},{PW@@},{PW!},{@@}},
{{( No test)},{}},
enddoc)
CODE_HEADER({PC@},{PCFET})
_C{ FETCH CHARACTER (BYTE) FROM PORT}
        POP     DX      _C{ PORT ADDR}
        XOR     AX,AX
        IN      AL,_DX16  _C{ BYTE INPUT}
        _PUSH
_C
worddoc( {MEMORY},{PC!},{port_char_store},{b port ---},{},
{Store a byte forthvar({b}) to the port address
forthvar({port}).
_HOSTED_X_({You can use ports only after asking permission
(using e.g. forthvar({ioperm}) ) and being super user.})
},
{{PC@@},{PW!},{P@@},{!}},
{{( No test)},{}},
enddoc)
CODE_HEADER({PC!},{PCSTO})
        POP     DX      _C{PORT ADDR}
        POP     AX      _C{DATA}
        OUT     _DX16,AL   _C{ BYTE OUTPUT}
        _NEXT
_C
worddocsafe( {MEMORY},{PW@@},{port_fetch},{port --- n},{},
{Fetch the 16-bit contents forthvar({n}) from the port address
forthvar({port}).
_HOSTED_X_({You can use ports only after asking permission
(using e.g. forthvar({ioperm}) ) and being super user.})
},
{{PW!},{PC@@},{PC!},{@@}},
{{( No test)},{}},
enddoc)
CODE_HEADER({PW@},{PFET})
        POP     DX      _C{PORT ADDR}
        IN      _AX16,_DX16  _C{WORD INPUT}
        _PUSH
_C
worddoc( {MEMORY},{PW!},{port_word_store},{n port ---},{},
{Store the 16-bit data forthvar({n}) to the 16-bits port address
forthvar({port}).
_HOSTED_X_({You can use ports only after asking permission
(using e.g. forthvar({ioperm}) ) and being super user.})
},
{{PW@@},{PC!},{PC@@},{!}},
{{( No test)},{}},
enddoc)
CODE_HEADER({PW!},{PSTO})
        POP     DX      _C{PORT ADDR}
        POP     AX      _C{DATA}
        OUT     _DX16,_AX16   _C{WORD OUTPUT}
        _NEXT
_C
worddoc( {BLOCKS~},{_PREV},{prev},{--- addr},{},
{A variable containing the address of the disc buffer (not its
content field!) most recently referenced. The
forthcode({UPDATE}) command marks this buffer to be
written to disc.},{{(BUFFER)}},
{ { _PREV @ _FIRST _LIMIT WITHIN .},{_T_} },
enddoc)
_HEADER({_PREV},{_PREV},{DOVAR}, )
        DC      BUF1
_C
worddoc( {BLOCKS},{#BUFF},{hash_buf},{--- n},{},
{A constant that leaves the number of block buffers.
Because a buffer that is being interpreted is locked in memory,
this is also a limit to the nesting depth of blocks loading other
blocks. },
{{BLOCK},{THRU},{LOAD},{LOCK}},
{{#BUFF 100 U< .},{_T_} },
enddoc)
_HEADER({#BUFF},{NOBUF},{DOCON}, NBUF)
_C
worddoc( {BLOCKS~},{+BUF},{plus_buf},{addr1 --- addr2 ff},{FIG},
{Advance the disc buffer address forthvar({addr1}) to the address of
the next buffer forthvar({addr2}) . Boolean forthvar({ff}) is false
when forthvar({addr2}) is the buffer presently pointed to by variable
forthcode({_PREV}).
},{{BLOCK}},
{
{ _PREV @ DUP +BUF DROP DUP _PREV ! _FIRST _LIMIT WITHIN .},{_T_},
{ +BUF . DUP _FIRST _LIMIT WITHIN .},{0 _T_},
{ +BUF 0= . _FIRST _LIMIT WITHIN .},{0 _T_},
}, enddoc)
_HEADER({+BUF},{PBUF},{DOCOL})
        DC      BBUF, CELLP, CELLP
        DC      PLUS,LDUP
        DC      _LIMIT,EQUAL
        _0BRANCH(PBUF1)
        DC      DROP,_FIRST
PBUF1:  DC      LDUP, _PREV, FETCH, LSUB
        DC      SEMIS
_C
worddoc( {BLOCKS},{UPDATE},{update},{},{ISO,FIG},
{Marks the most recently referenced block (pointed to by
forthcode({_PREV}) ) as altered. The block will subsequently be
transferred automatically to disc should its buffer be required for
storage of a different block. In fact the block is transferred
to disk immediately.},{{BLOCK},{EMPTY-BUFFERS}},
{{BLOCK-EXIT 2 BLOCK-INIT 1 BLOCK DROP UPDATE},{},
{ 1 BLOCK PAD B/BUF MOVE EMPTY-BUFFERS 1 BLOCK PAD B/BUF CORA .},{0}
},
enddoc)
_HEADER({UPDATE},{UPDAT},{DOCOL})
        DC      _PREV, FETCH
        DC      LDUP, CELLP,CELLP
        DC      SWAP, FETCH
        DC      LOFFSET,  FETCH, PLUS
        DC      BLWRITE
        DC      SEMIS
_C
worddoc( {BLOCKS},{EMPTY-BUFFERS},{empty_buffers},{},{ISO,FIG},
{Mark all block-buffers as empty. Updated blocks are not
written to the disc. This is an initialization proceedure
before first use of the disc. _VERBOSE_({{The usage as an
``undo'' is infeasible in ciforth.}}) },
{{FLUSH},{BLOCK},{SCREEN},{UPDATE}},
{{!CSP EMPTY-BUFFERS ?CSP},{}},
enddoc)
_HEADER({EMPTY-BUFFERS},{MTBUF},{DOCOL})
        DC      _FIRST
        DC      _LIMIT,OVER
        DC      LSUB,LERASE
        DC      _FIRST, _PREV, STOR
        DC      SEMIS
        PAGE
_C
worddocsafe({BLOCKS~},{(BUFFER)},{paren_buffer},{n --- addr},{},
{Return the addres forthvar({addr}) of a buffer assigned to
identification forthvar({n}) , probably a block number.
The buffer layout is as follows: a cell
with forthvar({n}), a cell with the status, and the
content of length forthdefi({B/BUF}) .
The status is negative for locked. The l.s.b. gives
zero for free and one for valid data.
The block is not read from the disc. The buffer
is either one that was already assigned, or else a free buffer.
If there is none free, some non-locked buffer is freed. The
contents of that buffer is written to the disc, if it was
marked as updated. In ciforth this is never needed, because
updated blocks are written immediately.
In ciforth blocks can
be locked, and locked buffers are never freed by
forthcode({(BUFFER)}) .
_VERBOSE_({{An update flag would somehow be multiplexed with
the lock count, but it is not needed in this ciforth.}}) If all
buffers were locked, forthcode({(BUFFER)}) throws exception 48.
},
{{BLOCK},{_PREV},{#BUFF},{LOCK},{UNLOCK}},
{{!CSP 1 (BUFFER) _FIRST _LIMIT WITHIN . ?CSP},{_T_}},
enddoc)
_HEADER({(BUFFER)},{BUFFER},{DOCOL})
_C{ Find the buffer, if it is already here.}
    DC      _PREV, FETCH
BUFFER1:
    DC          TOR, RR, FETCH, OVER, EQUAL
    _0BRANCH(BUFFER3)
    DC        DROP, FROMR, EXIT
BUFFER3:
    DC          FROMR
    DC      PBUF, ZEQU
    _0BRANCH(BUFFER1)
_C{ We are left with the previous buffer.}
BUFFER2:
    DC       PBUF, ZEQU, LIT, 48, QERR  _C{ No free buffers available.}
    DC       LDUP, CELLP, FETCH
    DC       LIT, -1, GREAT        _C{ Unlocked buffer?}
    _0BRANCH(BUFFER2)
    DC       TOR
_C{ Fill in the house keeping.}
    DC       RR, STOR
    DC       ZERO, RR, CELLP, STOR

    DC       RR, _PREV, STOR
    DC       FROMR
    DC  SEMIS
_C

worddoc( {BLOCKS},{BLOCK},{block},{n --- addr},{ISO,FIG},
{Leave forthvar({addr}), the disc buffer containing block
forthvar({n}), which is the physical disk block
forthsamp({OFFSET+n}). The address left is the field within the
buffer to be used for data storage. If the block is not already
in memory, it is transferred from disc to a new buffer allocated
by forthcode({(BUFFER)}) .
_VERBOSE_({{Blocks are generally
used to contain source code to be interpreted
by }forthcode({LOAD}){. They can be equally useful to contain
other data, e.g. for implementing a database. }})
_FEWBLOCKS_({In this experimental version forthsamp({PMASK})
restricts the number of blocks to 0x0FF.})},
{{(BUFFER)},{BLOCK-READ},{BLOCK-WRITE},{OFFSET},{UPDATE},{FLUSH},{LOAD}},
{{!CSP 1 BLOCK _FIRST _LIMIT WITHIN . ?CSP},{_T_} },
enddoc)
_HEADER({BLOCK},{BLOCK},{DOCOL})
_FEWBLOCKS_({        DC      LIT, PMASK, LAND})
        DC      BUFFER
        DC      LDUP, CELLP, FETCH, ONE, LAND, ZEQU
        _0BRANCH(BLOCK1)
        DC      LDUP, CELLP, CELLP
        DC      OVER, FETCH
        DC      LOFFSET,  FETCH, PLUS
        DC      BLREAD
        DC      LDUP, CELLP , ONE, TOGGL
BLOCK1:
        DC      LDUP, _PREV, STOR
        DC      CELLP, CELLP
        DC      SEMIS
_C
worddoc( {BLOCKS~},{FLUSH},{flush},{},{ISO,FIG},
{Make sure that the content of all forthcode({UPDATE}) d block buffers
has been transferred to disk.
The buffers are no longer associated with a block and their content is
no longer available.
In ciforth no transfer takes place,
because mass storage is updated automatically in the background.
},{{EMPTY-BUFFERS},{BLOCK}},
{{1 BLOCK DROP _PREV @ @ 0= . FLUSH _PREV @ @ 0= .},{0 _T_} },
enddoc)
_HEADER({FLUSH},{FLUSH}, {DOCOL}, _VAR_FIELD({MTBUF}))

_C{ Unlock all buffers}
        DC      _LIMIT
        DC      _FIRST, CELLP
        _DO(FLUS2)
FLUS1:  DC      ZERO, IDO, STOR
        DC      LIT,(KBBUF+2*CW)
        DC      PLOOP
        DC      (FLUS1-_AP_)
FLUS2:
        DC      SEMIS
_C
worddoc( {PARSING},{SAVE},{save},{ ---},{},
{Save the content of forthcode({SRC}) on the return stack
to prepare for changing the forthdefi({current input source}).
This must be balanced by a forthcode({RESTORE}) in the same
definition.
forthcode({CO}) can be used between the two.
dnl What do I mean here?
dnl ??? Not true if this is a code definition like in yourforth.
},
{{SET-SRC},{SAVE-INPUT}},
{{!CSP : GS1 SAVE 0 PP ! RESTORE ; GS1 34 . ?CSP},{34} },
enddoc)
_HEADER({SAVE},{SAVE},{DOCOL})
        DC      FROMR
        DC      SRC, TFET
        DC      PP, FETCH
        DC      TOR, TOR, TOR
        DC      TOR
        DC SEMIS
_C
worddoc( {PARSING},{RESTORE},{restore},{ ---},{},
{This must follow a forthcode({SAVE}) in the same definition.
Restore the content of forthcode({SRC}) from the return stack
thus restoring the forthdefi({current input source}) to what
it was when the forthcode({SAVE}) was executed.
},
{{SET-SRC},{RESTORE-INPUT}},
{{( Via SAVE-INPUT)},{}},
enddoc)
_HEADER({RESTORE},{RESTO},{DOCOL})
        DC      FROMR
        DC      FROMR, FROMR, FROMR
        DC      PP, STOR
        DC      SRC, TSTOR
        DC      TOR
        DC SEMIS
_C
_LOAD_({
worddoc( {PARSING},{SAVE-INPUT},{save_input},{ --- n1 n2 n3 3},{ISO,WANT},
{Get a complete specification of the input source stream. For
ciforth this is the content of forthcode({SRC}). ciforth needs
3 cells, and is always able to forthcode({RESTORE}) an input
saved like this. _VERBOSE_({{In practice the use of
}forthcode({SAVE-INPUT}){ should be restricted to restoring input
of the same stream.
}}) },
{{SAVE},{RESTORE-INPUT}},
{{1 LOAD  "SAVE-INPUT" WANTED !CSP : GS1 SAVE-INPUT 0 PP ! RESTORE-INPUT ; dnl
    34 GS1 . . ?CSP},{-1 34} },
enddoc)
_SUPPRESSED({{
_HEADER({SAVE-INPUT},{SAVEI},{DOCOL})
        DC      SRC, TFET
        DC      PP, FETCH
        DC      LIT, 3
        DC SEMIS
}})_C{}_END_({ _SUPPRESSED})
_C
worddoc( {PARSING},{RESTORE-INPUT},{restore_input},{ n1 n2 n3 3---f},{ISO,WANT},
{Restore the input source stream from what was saved by
SAVE-INPUT .
ciforth is always able to restore the input across
different input sources, as long as the input to be restored was
not exhausted. This has the effect of chaining, and doesn't
affect the return from nested calls be it interpreting, loading
or evaluating. ciforth always returns a true into forthvar({f}).
_VERBOSE_({{The input source abandoned will
never be closed properly, so use should be restricted to the same
input source. }}) },
{{SAVE},{SAVE-INPUT}},
{{( Via SAVE-INPUT)},{}},
enddoc)
_SUPPRESSED({{
_HEADER({RESTORE-INPUT},{RESTOI},{DOCOL})
        DC      DROP
        DC      PP, STOR
        DC      SRC, TSTOR
        DC      LIT, -1
        DC SEMIS
}})_C{}_END_({ _SUPPRESSED})
_C
})_C{}_END_({_LOAD_})
worddoc( {SCREEN},{LOCK},{lock},{ n ---},{CI},
{Lock the buffer with identification forthvar({n}),
mostly a block number.
Multiple locks are possible, and require multiple unlocks.
_VERBOSE_({{Probably, it
is to become the }forthdefi({current input source}){.}})
The result is that its buffer will not be reclaimed
until an forthcode({UNLOCK}) occurs.},
{{BLOCK},{(BUFFER}),{UNLOCK},{#BUFF}},
{ {EMPTY-BUFFERS 1 BLOCK DROP 1 LOCK dnl
    _PREV @ CELL+ @ . FLUSH _PREV @ CELL+ @ 0= .},{-1 _T_},
{ : test #BUFF 1+ 0 DO I LOCK LOOP ; test },
{ I LOCK LOOP ; test ? ciforth ERROR # 48 },
{ EMPTY-BUFFERS}, {},
},
enddoc)
_HEADER({LOCK},{LLOCK},{DOCOL})
        DC      BUFFER
        DC      CELLP
        DC      LIT, -2, SWAP, PSTOR
        DC      SEMIS
_C
worddoc( {SCREEN},{UNLOCK},{unlock},{ n ---},{CI},
{Unlock the buffer with identification forthvar({n}),
mostly a block number.
_VERBOSE_({{Probably, because it
is no longer the }forthdefi({current input source}){.}})
The result is that its buffer can again be reclaimed.
Unlocking without a previous lock may lead to a crash.
},
{{LOCK},{(BUFFER)},{#BUFF}},
{
{EMPTY-BUFFERS 1 BLOCK DROP 1 LOCK dnl
 _PREV @ CELL+ @ . 1 UNLOCK _PREV @ CELL+ @ .},{-1 1} },
enddoc)
_HEADER({UNLOCK},{LUNLOCK},{DOCOL})
        DC      BUFFER
        DC      CELLP
        DC      TWO, SWAP, PSTOR
        DC      SEMIS
_C
worddoc( {SCREEN},{LOAD},,{n --- ??},{ISO,FIG},
{Interrupt the forthdefi({current input source}) in order to
interpret screen forthvar({n}) .
_VERBOSE_({{The stack changes in according with the words executed.}})
At the end of the screen, barring errors or forced changes,
it continues with the interrupted input source.},
{{BLOCK},{LOCK},{#BUFF},{THRU},{QUIT},{EXIT},{-->},{LIST}},
{{." interactive"},{interactive}},
enddoc)
_HEADER({LOAD},{LLOAD},{DOCOL})
        DC      SAVE
        DC      TOR
        DC      RR, LIT, LLOCK, CATCH  _C{ Be careful about always unlocking.}
        DC      LDUP, ZEQU
        _0BRANCH(LOAD5)
        DC      DROP
        DC      RR, BLOCK     _C{ Can't fail anymore. }
        DC      BBUF
        DC      SETSRC
        DC      LIT, INTER, CATCH
        DC      RR, LUNLOCK
LOAD5:
        DC      RDROP
        DC      RESTO
        DC      THROW
        DC      SEMIS
_C
worddoc( {SCREEN},{THRU},,{n1 n2 --- ??},{ISO,FIG},
{Interrupt the forthdefi({current input source}) in order to
interpret screen forthvar({n1}) through forthvar({n2})
(inclusive).
_VERBOSE_({{The stack changes in according with the words executed.}})
At the end of the screens, barring errors or forced changes,
it continues with the interrupted input source.},
{{#BUFF},{BLOCK},{LOAD},{QUIT},{EXIT},{-->}},
{{." interactive"},{interactive}},
enddoc)
_HEADER({THRU},{THRU},{DOCOL})
        DC      ONEP, SWAP
        _DO(THRU2)
THRU1:
        DC      IDO, LLOAD
        _LOOP({THRU1})
THRU2:
        DC      SEMIS
_C
_LOAD_({
_C
worddoc( {SCREEN~},{BLK},{blk},{--- addr},{ISO},
{When the standard word forthsamp({BLK}) is used, the content
of the user variable forthsamp({(BLK)}) is refreshed to reflect
the state of the current input source and its address is returned
in forthvar({addr}) .
It indicates the block
number being interpreted, or zero, if input is being taken from
the terminal input buffer. In ciforth
changing the content at
forthvar({addr}) has no effect, which may not be ISO compliant.
Its content must be
fetched before the forthdefi({current input source}) has
changed.},
{{BLOCK},{TIB}},
{{BLK @ .},{0}},
enddoc)
_HEADER({BLK},{BLK},{DOCOL})
        DC      PP, FETCH
        DC      _FIRST, _LIMIT, WITHIN
        DC      SRC, TFET, LSUB
        DC      LIT, 1024, EQUAL, LAND
        _0BRANCH(BLK1)
        DC      SRC, FETCH, TWO, LCELLS, LSUB, FETCH
        _BRANCH(BLK2)
BLK1:
        DC      ZERO
BLK2:
        DC      PBLK, STOR
        DC      PBLK
        DC      SEMIS
_C
worddocsafe( {BLOCKS},{-->},{next_screen},{},{I,WANT},
{Continue interpretation with the next disc screen. If the
current input source is not from a block, a crash will ensue.
If this new screen is left by throw of an exception, the
screen may remain locked until a forthcode({QUIT}), or any
uncaught exception. },
{{LOCK},{CATCH},{LOAD}},
{{." interactive"},{interactive}},
enddoc)
_C
})_C{}_END_({_LOAD_})
_PC_({
_C{ Generic call on BIOS. A boon for experimenters.}
worddoc( {OPERATINGSYSTEM},{BIOSO},{bios},{a b c d i---ar br cr dr fl},{},
{Do a call of ``BIOS'' interrupt forthvar({i}) with forthvar({a b c d})
in registers forthemph({AX BX CX DX}). Upon return those registers contain
forthvar({ar br cr dr}) and forthvar({fl}) is the content of the processors flag
register._HOSTED_DPMI_({This word performs calls only as related to a real mode interface.
Under DPMI we have to do this via a special call to the
unadorned interrupt, which is in this case protected mode,
interrupt 0x31 function 0x0300. In behalf of this registers are
saved and restored in forthcode({REG-SET}) . Unadorned calls to
real interrupts are only available as forthcode({BIOS31}) .})
_VERBOSE_({{ }forthsamp({1 AND}){ leaves a zero if the call was successful.}})
},{{BDOSO}}, {}, enddoc)
_NORMAL_BIOS_({
_C{ Because there is no such thing as a variable interrupt:}
_C{ THIS IS SELF MODIFYING CODE! NOT REENTRANT! DO NOT PUT IN ROM!}
_C{ BEWARE OF THE SOFTWARE POLICE!}
CODE_HEADER({BIOSO},{BIOSO})
        POP     AX      _C{ Function code}
        _C{ Once we are more acknowledgeable, put segment overwrite here.}
        MOV     _BYTE_PTR([RQBIOS+1]),AL _C{ Patch the code.}
        POP     DX
        POP     CX
        POP     BX
        POP     AX
        PUSH     HIP      _C{ Save Forth registers. NEEDED? }
        PUSH     RPO
        XCHG    SI,AX   _C{ Save AX in (already free) SI}
        _SWITCH_({JMPHERE_FROM_FORTH})
        XCHG    {SI},{AX}
RQBIOS:  INT(0)          _C{ Request number to be overwritten.}
        PUSHF      _C{ Save status into DI }
        POP     {DI}
        XCHG    {SI},{AX} _C{ Save AX in (still free) SI     }
        _SWITCH_({JMPHERE_FROM_OS})
        XCHG    SI,AX
        POP     RPO      _C{ Restore Forth registers. NEEDED? }
        POP     HIP
        PUSH     AX
        PUSH     BX
        PUSH     CX
        PUSH     DX
        PUSH     DI     _C{ i.e. flags }
        _NEXT
_SWITCH_({SPSAVE: DC       0x0})
_C{ SELF MODIFYING CODE ENDS HERE! YOU HAVE BEEN WARNED!}
})_C{}_END_({_NORMAL_BIOS_})
_SIMULATE_BIOS_({
CODE_HEADER({BIOSO},{BIOSO})
_C{ Adapted from Allen Wyatt, Advanced Assembly language, QUE}
_C{ from pmtest.asm.}

        POP     BX      _C{ Function code}
        POP     AX
        MOV     _CELL_PTR[SaveDX],AX _C{Parameters specified from stack.}
        POP     AX
        MOV     _CELL_PTR[SaveCX],AX
        POP     AX
        MOV     _CELL_PTR[SaveBX],AX
        POP     AX
        MOV     _CELL_PTR[SaveAX],AX
        PUSHF
        POP     AX
        MOV     _CELL_PTR[SaveFlags],AX


       MOV     _CELL_PTR[SaveSI],SI _C{Save some registers.}
       MOV     _CELL_PTR[SaveDI],DI
       MOV     _CELL_PTR[SaveBP],BP

       MOV     AX,0x0300            _C{Simulate real-mode interrupt}
       _C{  Function number was popped into BX register.}
       MOV     CX,0                _C{Copy nothing from stack}
       LEA     DI, [REGSET+HEADSIZE]
       INT     31h

       MOV     SI,_CELL_PTR[SaveSI] _C{Restore some registers.}
       MOV     DI,_CELL_PTR[SaveDI]
       MOV     BP,_CELL_PTR[SaveBP]

       MOV     AX,_CELL_PTR[SaveAX] _C{Make others available.}
       PUSH     AX
       MOV     AX,_CELL_PTR[SaveBX]
       PUSH     AX
       MOV     AX,_CELL_PTR[SaveCX]
       PUSH     AX
       MOV     AX,_CELL_PTR[SaveDX]
       PUSH     AX
       MOV     AX,_CELL_PTR[SaveFlags]
       PUSH    AX
       JMP     NEXT
_C
})_C{}_END_({_SIMULATE_BIOS_})
_C{ Generic call on BIOS. A boon for experimenters.}
worddoc( {OPERATINGSYSTEM},{BIOSN},{biosn},{d c b a i---ar fl},{},
{Do a call of ``BIOS'' interrupt forthvar({i}) with
forthvar({a b c d}) in registers forthemph({AX BX CX DX}).
Return as a result the content of register forthemph({AX}) into forthvar({ar}).
forthvar({fl}) contains the flag register.
If the carry flag is set, it is presumably a
failed operation. _VERBOSE_({{For other conventions you have to resort to }forthcode({BIOSO}){ .}})
In general forthvar({ar}) then contains some error
code. _HOSTED_DPMI_({{
This word performs calls only
as related to a real mode interface. Under DPMI we have to do
this via a special call to the unadorned interrupt, which is in
this case protected mode, interrupt 0x31 function 0x0300. In
behalf of this registers are saved and restored in
}forthcode({REG-SET}){ . forthcode({BIOS31}) is the only direct interrupt
call available.
If you want selectors forthvar({DS}) or
forthvar({ES}) different from the Forth segment, or any
register different from the default, you must fill that in in
the forthcode({REG-SET}) structure. If your BIOS call destroys
registers, in particular forthvar({DS}) or forthvar({ES}) you
must take care to restore them to }forthcode({REG-SET}){ .
}})
},{{BDOSN}},
{{23 &A _ _ 200 21 BIOSN 1 AND . DROP .},{A0 23}},
enddoc)

_NORMAL_BIOS_({
_C{ Because there is no such thing as a variable interrupt:}
_C{ THIS IS SELF MODIFYING CODE! NOT REENTRANT! DO NOT PUT IN ROM!}
_C{ BEWARE OF THE SOFTWARE POLICE!}
CODE_HEADER({BIOSN},{BIOSN})
        POP     AX      _C{ Function code}
        _C{ Once we are more acknowledgeable, put segment overwrite here.}
        MOV     _BYTE_PTR([RQBIOSN+1]),AL _C{ Patch the code.}
        POP     AX
        POP     BX
        POP     CX
        POP     DX
        PUSH     HIP      _C{ Save Forth registers. NEEDED? }
        PUSH     RPO
        XCHG    SI,AX   _C{ Save AX in (already free) SI}
        _SWITCH_({JMPHERE_FROM_FORTH})
        XCHG    {SI},{AX}
RQBIOSN:  INT(0)          _C{ Request number to be overwritten.}
        PUSHF      _C{ Save status into DI }
        POP     {DI}
        XCHG    {SI},{AX} _C{ Save AX in (still free) SI     }
        _SWITCH_({JMPHERE_FROM_OS})
        XCHG    SI,AX
        POP     RPO      _C{ Restore Forth registers. NEEDED? }
        POP     HIP
        PUSH     AX
        PUSH     DI     _C{ i.e. flags }
        _NEXT
_C{ SELF MODIFYING CODE ENDS HERE! YOU HAVE BEEN WARNED!}
})_C{}_END_({_NORMAL_BIOS_})
_SIMULATE_BIOS_({
CODE_HEADER({BIOSN},{BIOSN})
_C{ Adapted from Allen Wyatt, Advanced Assembly language, QUE}
_C{ from pmtest.asm.}

        POP     BX      _C{ Put function code on return stack.}
        LEA     RPO,[RPO - _CELLS(1)]
        MOV     [RPO],BX

        POP     AX
        POP     BX
        POP     CX
        POP     DX
        PUSHAD            _C{Save also Forth registers.}

        MOV     CX, 8
        MOV     SI, SP
        LEA     DI, [REGSET+HEADSIZE]
        REP     MOVSD

        MOV     AX,0x0300            _C{Simulate real-mode interrupt.}
        MOV     BX,[RPO] _C{ Get function code from return stack.}
        MOV     CX,0                _C{Copy nothing from stack}
        LEA     DI, [REGSET+HEADSIZE]
        INT     31h

        POPAD   _C{Get it all back.}
        LEA     RPO,[RPO + _CELLS(1)] _C{Bump return stack. After the pop!}.
        MOV     AX,_CELL_PTR[SaveAX]
        PUSH    AX
        MOV     AX,_CELL_PTR[SaveFlags]
        PUSH    AX
        _NEXT
_C
_SWITCH_({SPSAVE: DC       0x0})
_C
worddoc( {BLOCKS},{REG-SET},{register_set},{--- addr},{},
{Leaves the start forthvar({addr}) of the register storage area for
cross-mode interrupt handling. _VERBOSE_({{ This structure is
defined by the DPMI specifications for use with interrupt 0x31
function 0x0300.}}) The layout is as forthvar({DI SI BP BX DX CX
AX Flags ES DS FS GS IP CS SP SS
_HOSTED_DPMI_({and startup selectors : CS ES SS}).
}) _VERBOSE_( {For the general
registers this agrees with the forthemph({PUSH_ALL}) instruction.})
},
{{BIOSO}},
dnl Expect a reasonable value for the data segment.
dnl Commented out, for XP it is 0x0DXX . So?
dnl {{REG-SET 24 + @ 0FFFF AND 1000 3000 WITHIN .},{_T_} },
,
enddoc)
_HEADER({REG-SET},{REGSET},{DOVAR},)
SaveDI:     DD      00000000
SaveSI:     DD      00000000
SaveBP:     DD      00000000
            DD      00000000            _C{Reserved area--set to 0}
SaveBX:     DD      00000000
SaveDX:     DD      00000000
SaveCX:     DD      00000000
SaveAX:     DD      00000000
SaveFlags:  DW      0000
SaveES:     DW      0000
SaveDS:     DW      0000
SaveFS:     DW      0000
SaveGS:     DW      0000
SaveIP:     DW      0000
SaveCS:     DW      0000
SaveSP:     DW      0000
SaveSS:     DW      0000
_HOSTED_DPMI_({
_C
Save_CS_PR: DW    0000
Save_DS_PR: DW    0000
Save_ES_PR: DW    0000
})_C{}_END_({ _HOSTED_DPMI_})
_C
worddoc( {OPERATINGSYSTEM},{BIOS31},{bios31},{a b c d di---ar br cr dr fl},{},
{Do a call of ``BIOS'' interrupt 0x31, directly from
protected mode
with forthvar({a b c d di}) in registers
forthemph({AX BX CX DX DI}). Upon return those registers
contains forthvar({ar br cr dr}) and forthvar({fl}) is the
content of the processors flag register. _VERBOSE_({{
}forthsamp({1 AND}){ leaves a zero if the call was successful.}})
 _VERBOSE_({{The word }forthcode({BIOS}){ simulates
a real mode interrupt; that is what you usually want.}})
},{{BIOS},{BDOS}}, {}, enddoc)
_C{ Wanted here is a generic call on BIOS. A boon for experimenters.}
_C{ Because there is no such thing as a variable interrupt:}
_C{ I tried to use self modifying code , filling in the interrupt}
_C{ number. Like in the BIOS for the real case.}
_C{ In protected mode with different selectors for code}
_C{ and data this is dubious. If it turns out to work, this could}
_C{ be made in a general trap generator.}
CODE_HEADER({BIOS31},{BIOS31})
        POP     DI
        POP     DX
        POP     CX
        POP     BX
        POP     AX
RQBIOS: INT(0x31)          _C{ Request number to be overwritten.}
        PUSH     AX
        PUSH     BX
        PUSH     CX
        PUSH     DX
        PUSHF
        _NEXT
})_C{}_END_({_SIMULATE_BIOS_})
worddoc( {OPERATINGSYSTEM},{BDOSO},{bdos},{a b c d---ar br cr dr fl},{},
{Do a call of ``BDOS'' interrupt (0x21) with forthvar({a b c d}) in
registers forthemph({AX BX CX DX}). Upon return those registers
contains forthvar({ar br cr dr}) and forthvar({fl}) is the content
of the processors flag register. This draws upon all facilities made
available by MSDOS. _BOOTSECTRK_({{This works in this standalone Forth, but
only if it is started from MSDOS.}}) This is obsolescent, use forthcode({BDOSN}) .
},{{BIOSO},{BDOSN}}, {}, enddoc)
_NORMAL_BIOS_({
CODE_HEADER({BDOSO},{BDOSO})
        POP     DX
        POP     CX
        POP     BX
        POP     AX
        PUSH     HIP      _C{ Save Forth registers. NEEDED? }
        PUSH     RPO
        XCHG    SI,AX   _C{ Save AX in (already free) SI}
        _SWITCH_({JMPHERE_FROM_FORTH})
        XCHG    {SI},{AX}
        INT     0x21
        PUSHF      _C{ Save status into DI }
        POP     {DI}_C{ Not EDI! }
        XCHG    {SI},{AX}  _C{ Save AX in (still free) SI     }
        _SWITCH_({JMPHERE_FROM_OS})
        XCHG    SI,AX
        POP     RPO      _C{ Restore Forth registers. NEEDED? }
        POP     HIP
        PUSH     AX
        PUSH     BX
        PUSH     CX
        PUSH     DX
        PUSH     DI     _C{ i.e. flags }
        _NEXT
})_C{}_END_({_NORMAL_BIOS_})
_SIMULATE_BIOS_({
_HEADER({BDOSO},{BDOSO},{DOCOL})
        DC      LIT,  0x21
        DC      BIOSO
        DC      SEMIS
})_C{}_END_({_SIMULATE_BIOS_})
})_C{}_END_({ _PC_})
_HOSTED_X_({
worddoc( {OPERATINGSYSTEM},{XOS},{xos},{n1 n2 n3 n---ret},{},
{ Do a traditional Unix type
system call forthvar({n})
(man 2) with parameters forthvar({n1 n2 n3}).
forthvar({ret}) is the return value of the call. If it is negative, it
is mostly an error, such as known by forthemph({errno}) . This makes
available all facilities present in _OS_, except those with 4 or 5 parameters
that are handled by forthcode({XOS5}) .
},{{?ERRUR}},
_BITS32_({ {{1 "CHIMP" 4 XOS .},{CHIMP5}}, })
_BITS64_({ {{1 "CHIMP" 1 XOS .},{CHIMP5}}, })
enddoc)
_LINUX_N_({
CODE_HEADER({XOS},{XOS})
_BITS32_({
        POP     AX        _C{ Function number}
        POP     DX        _C{ Third parameter, or dummy}
        POP     CX        _C{ Second parameter, or dummy}
        POP     BX        _C{ First parameter.}
        INT     0x80        _C{ Generic call on LINUX }
})_C{}_END_({_BITS32_})
_BITS64_({
_C({    Saving HIP on the return stack, with RPO saved in memory or })
_C({    R15 fails with the __NR_clone syscall (and only then) })
        MOV     R15,HIP   _C{ HIP is SI }
        POP     AX       _C{ Function number              }
        POP     DX       _C{ Third parameter, or dummy    }
        POP     SI       _C{ Second parameter, or dummy   }
        POP     DI       _C{ First parameter.             }
        SYSCALL          _C{  Generic call on LINUX       }
        MOV     HIP,R15
})_C{}_END_({_BITS64_})
        _PUSH     _C{ Positive means okay. Negative means -errno.}
_C
})_C{}_END_({_LINUX_N_})
_HOSTED_OSX_({
CODE_HEADER({XOS},{XOS})
; OS X expects parameters on the stack, parm 1 in the most accessible place,
; so swap first and third parameter
        MOV     BX, [SP+_CELLS(1)]
        MOV     CX, [SP+_CELLS(3)]
        MOV     [SP+_CELLS(1)], CX
        MOV     [SP+_CELLS(3)], BX

        MOV     AX, [SP]    _C{ Get call number, leave dummy.}
        INT     0x80        _C{ Generic call on OSX }
        LEA     SP, [SP+_CELLS(4)] _C{ 3 parameters plus call number.}

        _PUSH     _C{ Positive means okay. Negative means -errno.}
_C
})_C{}_END_({_HOSTED_OSX_})
worddoc( {OPERATINGSYSTEM},{XOS5},{xos5},{n1 n2 n3 n4 n5 n---ret},{},
{ Do a traditional Unix type system call forthvar({n}) (man 2) with parameters
forthvar({n1 n2 n3 n4 n5}). forthvar({ret}) is the return
value of the call. If it is negative, it is mostly an error,
such as known by forthemph({errno}) . This makes available
forthemph({all}) facilities present in _OS_.
},{{?ERRUR}},
dnl the syscall number for write has changed since 64 bits.
_BITS32_({ {{1 "CHIMP" 0 0 4 XOS5 .},{CHIMP5}}, })
_BITS64_({ {{1 "CHIMP" 0 0 1 XOS5 .},{CHIMP5}}, })
enddoc)
_LINUX_N_({
CODE_HEADER({XOS5},{XOS5})
_BITS32_({
        LEA     RPO,[RPO - _CELLS(1)] _C{Save HIP on return stack.}
        MOV     [RPO],HIP

        POP     AX        _C{ Function number}
        POP     DI        _C{ 5th parameter, or dummy}
        POP     SI        _C{ 4th parameter, or dummy}
        POP     DX        _C{ Third parameter, or dummy}
        POP     CX        _C{ Second parameter, or dummy}
        POP     BX        _C{ First parameter.}
        INT     0x80        _C{ Generic call on LINUX }
        MOV     HIP,[RPO]    _C{ Restore}
        LEA     RPO,[RPO+_CELLS(1)]
})_C{}_END_({_BITS32_})
_BITS64_({
        MOV     R15,HIP   _C{ HIP is SI }
        POP     AX        _C{ Function number            }
        POP     R8       _C{ 5th parameter, or dummy    }
        POP     R10      _C{ 4th parameter, or dummy    }
        POP     DX        _C{ Third parameter, or dummy  }
        POP     SI        _C{ Second parameter, or dummy }
        POP     DI        _C{ First parameter.           }
        SYSCALL           _C{ Generic call on LINUX      }
        MOV     HIP,R15
})_C{}_END_({_BITS64_})

        _PUSH     _C{ Positive means okay. Negative means -errno.}
_C
})_C{}_END_({_LINUX_N_})
_HOSTED_OSX_({
CODE_HEADER({XOS5},{XOS5})
; OS X expects parameters on the stack, parm 1 in the most accessible place,
; so swap first and fifth parameter, second and fourth too.
        MOV     BX, [SP+_CELLS(1)]
        MOV     CX, [SP+_CELLS(5)]
        MOV     [SP+_CELLS(1)], CX
        MOV     [SP+_CELLS(5)], BX
        MOV     BX, [SP+_CELLS(2)]
        MOV     CX, [SP+_CELLS(4)]
        MOV     [SP+_CELLS(2)], CX
        MOV     [SP+_CELLS(4)], BX

        MOV     AX, [SP]    _C{ Get call number, leave dummy.}
        INT     0x80        _C{ Generic call on OSX }
        LEA     SP, [SP+_CELLS(6)] _C{ 5 parameters plus call number.}

        _PUSH     _C{ Positive means okay. Negative means -errno.}
_C
worddoc( {OPERATINGSYSTEM},{XOSV},{xos_variable},{ ni ...n3 n2 n1 i nc ---ret},{},
{ Do a traditional Unix type system call forthvar({nc}) (man 2) with
forthvar({i}) parameters forthvar({n1 n2 n3 .. ni}). forthvar({ret}) is the return
value of the call. If it is negative, it is mostly an error,
such as known by forthemph({errno}) . This makes available
forthemph({all}) facilities present in _OS_.
_VERBOSE_({Please note that the parameters appear in reverse order compared to
normal documentation.})
},{{?ERRUR}},
{{0 0 "CHIMP" SWAP 1 5 4 XOSV .},{CHIMP5}},
enddoc)
CODE_HEADER({XOSV},{XOSV})
        POP     AX      _C{ system call no. }
        INT     0x80    _C{ Generic call on OSX }
        POP     BX      _C{ Number of parameters }
        LEA     SP, [SP + 4*BX]
        _PUSH     _C{ Positive means okay. Negative means -errno.}
_C
})_C{}_END_({_HOSTED_OSX_})
worddoc( {OPERATINGSYSTEM},{MS},{millisecond},{n ---},{ISO},
{ Wait for forthvar({n}) milliseconds. },
{{KEY?}},
{{ 123 10 MS . },{123}},
enddoc)
_HEADER({MS},{MS},{DOCOL})
dnl _BITS32_({  Maybe change because 64 bits has better nanosleep
_C{ Use select because nanosleep has a 20 MS resolution. }
        DC      LIT, 1000, LIT, 1000000, SSMOD _C{ (ms -- us s) }
        DC      LIT, TV, TSTOR
        DC      ZERO, ZERO
        DC      ZERO, ZERO
        DC      LIT, TV
       DC      LIT, _newselect, XOS5
dnl })_C{}_END_({ _BITS32_})
dnl _BITS64_({
dnl })_C{}_END_({ _BITS64_})

        DC      QERRUR
        DC      SEMIS
TV:     _RESB( _CELLS(2) )   _C{ A time_t and a long, both cells.}
_C
})_C{}_END_({ _HOSTED_X_})
_PC_({
worddoc( {OPERATINGSYSTEM},{m_s_fetch},{millisecond_fetch},{ --- n},{},
{ Return a counter that is increase by 1 for each millisecond.
On this ciforth
it wraps after 100 seconds, and has a resolution on 10 mS.
},
{{MS}},
{{ DECIMAL MS@ 100 MS MS@ SWAP - 10 / 8 12  WITHIN . },{-1}},
enddoc)
_HEADER({MS@},{MSFET},{DOCOL})
        DC      LIT,   0x2C00, X, X, X
        DC      LIT,    0x21,  BIOSO, DROP
        DC      TOR, TDROP, DROP, FROMR
        DC      LIT, 0x100, SLMOD, LIT, 100, STAR, PLUS
        DC      LIT, 10, STAR
        DC      SEMIS
_C
worddoc( {OPERATINGSYSTEM},{MS},{millisecond},{n ---},{ISO},
{ Wait for forthvar({n}) milliseconds. },
{{KEY?},{MS@@}},
{{ 123 10 MS . },{123}},
enddoc)
_HEADER({MS},{MS},{DOCOL})
        DC      MSFET, PLUS, LIT, 100000, TOR
LMS0:   DC      LDUP,  MSFET
        DC      LSUB, RR, PLUS
        DC      RR, LMOD, RR, LIT, 2, SLASH
        DC      GREAT
        _0BRANCH(LMS0)
        DC      RDROP, DROP
        DC      SEMIS
})_C{}_END_({ _PC_})
        PAGE
_C{------------------------------------}
_C{       CONSOLE RELEATED I/O         }
_C{------------------------------------}
_MODERN_({
worddoc( {OUTPUT},{EMIT},{emit},{c ---},{ISO,FIG},
{Transmit ASCII character forthvar({c}) to the output device.
forthcode({OUT}) is incremented for each character output
and reset by a LF.
.},{{OUT}}, {}, enddoc)
_HEADER({EMIT},{EMIT},{DOCOL})
        DC      LDUP,LIT,ALF,EQUAL
        _0BRANCH(EMIT1)
        DC      LIT,ACR,EMIT
        DC      ZERO,LOUT,STOR
EMIT1:
        DC      SPFET, ONE, LTYPE
        DC      DROP
        DC      SEMIS
_C
worddoc( {INPUT},{KEY},{key},{--- c},{ISO,FIG},
{Leave the ASCII value of the next terminal key struck.},
{{ACCEPT},{KEY?}}, {}, enddoc)
_HEADER({KEY},{KEY},{DOCOL})
        DC      LIT, 0x1000, X, X, X
        DC      LIT, 0x0016, BIOSO
        DC      TDROP, TDROP
        DC      LIT, 0x00FF, LAND, SEMIS
_C
worddoc( {INPUT},{KEY?},{key_question},{--- f},{ISO},
{Perform a test of the terminal keyboard for a break request.
Any key pressed is interpreted as such and the key is not consumed.
A non-zero flag indicates actuation. },{{KEY},{ACCEPT}}, {}, enddoc)
_HEADER({KEY?},{KEYQ},DOCOL)
        DC      X, X, X, LIT, 0x0B00
        DC      BDOSN, DROP _C{ ignore error }
        DC      LIT, 0x01, LAND  _C{Dubious!! FIXME!!}
        DC      SEMIS
_C
worddoc( {OUTPUT},{TYPE},{type},{addr count ---},{ISO,FIG},
{Transmit count characters from forthvar({addr}) to the output device.
All terminal I/O goes through this word, so terminal
I/O can be redirected, by forthdefi({revectoring}) it.
In this ciforth the string must not contain embedded LF's.
forthcode({OUT}) is incremented for each character output.},
{{EMIT},{OUT}}, {}, enddoc)
_HEADER({TYPE},{LTYPE},{DOCOL})
        DC      LDUP, LOUT, PSTOR
        DC      _DLL_({STDOUT},{ONE}), WFILE, DROP
        DC      SEMIS
_C
worddocsafe( {INPUT},{(ACCEPT)},{paren_accept},{ --- sc } ,{},
{Accept characters from the terminal, until a forthkey({RET})
is received and return the result as a constant string
forthvar({sc}).
It doesn't contain a trailing forthkey({LF}).
But possibly a trailing forthkey({RET}) (0x0D).
The
editing functions are the same as with forthcode({ACCEPT}) .
_VERBOSE_({{This is lighter on the system and sometimes easier
to use than }forthcode({ACCEPT}){.
Text is probably present in the buffer address contained in
}forthcode({TIB @@}){, but not necessarily at the beginning. }})
},
{{KEY},{KEY?},{ACCEPT}},
{
{(ACCEPT) DUP . PAD SWAP CMOVE },{6},
 {GIBBON
PAD 6 TYPE },{GIBBON},
dnl { ." Type an 'A'" (ACCEPT) DUP . TYPE},{1 A)},
dnl {." Type an 'ABCDEF'" DUP . },{6},
},
enddoc)
_HEADER({(ACCEPT)},{PACCEP},{DOCOL})
PACCEP2:
        DC      REMAIND
        DC      TFET
        DC      LIT, ALF, SINDEX
        DC      ZEQU
        _0BRANCH(PACCEP1)
        DC      REMAIND, TFET
        DC      TIB, FETCH
        DC      SWAP, LMOVE
        DC      TIB, FETCH
        DC      REMAIND, CELLP, STOR
        DC      REFTIB
        _BRANCH(PACCEP2)
PACCEP1:
        DC      REMAIND, TFET
        DC      LIT, ALF, SSLAS
        DC      TSWAP, REMAIND, TSTOR
        DC      SEMIS
_C
worddoc( {OPERATINGSYSTEM},{BDOSN},{bdosn},{d c b a ---ar fl},{},
{Do a call of ``BDOS'' interrupt (0x21) with forthvar({d c b a }) in
registers forthvar({ DX CX BX AX }).
Return as a result the content of register forthemph({AX}) into forthvar({ar}).
forthvar({fl}) contains the flag register.
If the carry flag is set, it is presumably a
failed operation.
_VERBOSE_({{For other conventions you have to resort to }forthcode({BIOSO}){ .}})
So 0 indicates no error, 1 indicates an error, probably
with more information present in forthvar({ar }).
This draws upon all facilities made
available by MSDOS. _BOOTSECTRK_({{This works in this standalone Forth, but
only if it is started from MSDOS.}})
_VERBOSE_({{This is intended to replace the obsolescent BDOSO , that has the
parameters backwards, and returns too many useless parameters. }})
},
{{BIOSN},{BDOSO}},
{},
enddoc)
_HEADER({BDOSN},{BDOSN},{DOCOL})
        DC      LIT, 0x21, BIOSN
        DC      ONE, LAND
        DC      LDUP
        _0BRANCH(BDOSN1)
        DC      SWAP
        DC      NEGATE
        DC      SWAP
BDOSN1:
        DC      SEMIS
_C
})_C{}_END_({_MODERN_})
_FILES_({
worddoc( {FILES~},{RW-BUFFER},{read_write_buffer},{--- addr},{},
{A constant that leaves the address of a disk buffer used by
file i/o words._HOSTED_MSDOS_({{It is primarily used for building up
a zero ended string, such as not to burden pad.}})
_HOSTED_DPMI_({{It is aliased with a "real" segment, to pass data
from protected mode to the the DPMI-interface. Therefore it must be 16-bits
addressable. It occupies 32K from 0x8000 onwards. }})
},
{{READ-FILE}, {OPEN-FILE},{ZEN}},
{{( not yet)},{}},
enddoc)
_HOSTED_DPMI_({
define({SIZE_RWBUF}, {0x8000})
_HEADER({RW-BUFFER},{RWBUF},{DOCON}, 0x8000)
})_C{}_END_({ _HOSTED_DPMI_})
_HOSTED_MSDOS_({
define({SIZE_RWBUF}, {0x200})
_HEADER({RW-BUFFER},{RWBUF},{DOVAR},)
        _RESB(SIZE_RWBUF)
})_C{}_END_({ _HOSTED_MSDOS_})
_HOSTED_X_({
define({SIZE_RWBUF}, {0x1000})
_HEADER({RW-BUFFER},{RWBUF},{DOVAR},)
        _RESB(SIZE_RWBUF)
})_C{}_END_({ _HOSTED_X_})
_DLL_({
define({SIZE_RWBUF}, {0x1000})
_HEADER({RW-BUFFER},{RWBUF},{DOVAR},)
        _RESB(SIZE_RWBUF)
})_C{}_END_({ _DLL_})
_C
worddoc( {OPERATINGSYSTEM},{ZEN},{zren},{sc --- addr},{},
{Leaves an address that contains a zero-ended (c-type) equivalent of
forthvar({sc}).
The same buffer (in fact forthcode({RW-BUFFER})) is reused,
such that this word is not reentrant.
The size available is SIZE_RWBUF minus one for the zero character.
_VERBOSE_({{Use the word immediately, its intended used is
passing parameters to the operating system. }})
_HOSTED_DPMI_({{The result is present in the "real" segment, such that this address
only is useful to be passed to DPMI. }})
},
_HOSTED_X_({ {{OPEN-FILE},{XOS},{XOS5}}, })
_DLL_({ {{OPEN-FILE},{LOAD-DLL},{DLL-ADDRESS}}, })
_HOSTED_MSDOS_({ {{OPEN-FILE},{BIOSN},{BDOSN}}, })
_HOSTED_DPMI_({  {{OPEN-FILE},{BIOSN},{BDOSN}}, })
_HOSTED_X_({ {{"AAP" ZEN 3 + C@ .},{0}}, })
_DLL_(     { {{"AAP" ZEN 3 + C@ .},{0}}, })
_HOSTED_MSDOS_({ {{"AAP" ZEN 3 + C@ .},{0}}, })
_HOSTED_DPMI_({
{{: G3 "AAP" ZEN REG-SET 34 + @ SWAP 2 + FAR@ FF AND ;},{},
{G3 EMIT },{P}},
})
enddoc)
_HOSTED_X_({
_HEADER({ZEN},{ZEN}, {DOCOL})
        DC      RWBUF, SSTOR
        DC      ZERO, RWBUF, CHAPP
        DC      RWBUF, CELLP
        DC      SEMIS
})_C{}_END_({ _HOSTED_X_})
_DLL_({
_HEADER({ZEN},{ZEN}, {DOCOL})
        DC      RWBUF, SSTOR
        DC      ZERO, RWBUF, CHAPP
        DC      RWBUF, CELLP
        DC      SEMIS
})_C{}_END_({ _DLL_})
_HOSTED_MSDOS_({
_HEADER({ZEN},{ZEN}, {DOCOL})
        DC      RWBUF, SSTOR
        DC      ZERO, RWBUF, CHAPP
        DC      RWBUF, CELLP
         _SWITCH_({DC   LIT, M4_SWITCHOFFSET, PLUS, })
        DC      SEMIS
})_C{}_END_({ _HOSTED_MSDOS_})
_HOSTED_DPMI_({
_HEADER({ZEN},{ZEN}, {DOCOL})
        DC      TOR, ZERO, SWAP
        DC      LIT, Save_DS_PR, FETCH, RWBUF _C{ <FAR> RW-BUFFER}
        DC      RR, FMOVE        _C{  R@ FARMOVE}
        DC      ZERO
        DC      LIT, Save_DS_PR, FETCH, RWBUF _C{ <FAR> RW-BUFFER}
        DC      FROMR, PLUS, LSTOR
        DC      RWBUF
        DC      SEMIS
})_C{}_END_({ _HOSTED_DPMI_})
_C
_C
worddoc( {FILES},{WRITE-FILE}, {write_file},{addr n fd --- u1 }, {ISO},
{Write forthvar({n}) characters from forthvar({addr}) to the file that is
open at forthvar({fd}) , starting at its current position.
forthvar({u1}) is 0 for success,
or otherwise _PC_({the MSDOS}) _HOSTED_X_({ forthvar({errno}) })
error code
negated, usable as a throw code.
dnl FIXME Wanted : positive for a short read of forthvar({u1}) characters,
},
dnl This must be the first of the file test! hello.frt is used.
{{OPEN-FILE},{READ-FILE},{REPOSITION-FILE},{BLOCK-WRITE}},
_PC_({
{ { "hello.frt" 0 CREATE-FILE . CONSTANT FD },{0 },
{"""Hello world!"" TYPE" FD WRITE-FILE .},{0},
{^M PAD C! ^J PAD 1+ C! PAD 2 FD WRITE-FILE .},{0},
{FD CLOSE-FILE .},{0} },
})
_HOSTED_X_({
{ { "hello.frt" 8 BASE ! 644 CREATE-FILE . CONSTANT FD },{0 },
{"""Hello world!"" TYPE" FD WRITE-FILE .},{0},
{^J PAD C! PAD 1 FD WRITE-FILE .},{0},
{FD CLOSE-FILE .},{0} },
})
_DLL_({
{ { "hello.frt" 2 CREATE-FILE . CONSTANT FD },{0 },
{"""Hello world!"" TYPE" FD WRITE-FILE .},{0},
{^M PAD C! ^J PAD 1+ C! PAD 2 FD WRITE-FILE .},{0},
{FD CLOSE-FILE .},{0} },
})
enddoc)
_HOSTED_X_({
_HEADER({WRITE-FILE},{WFILE},{DOCOL})
        DC      ROT, ROT
        DC      LIT, write, XOS
        DC      ZERO, MIN
        DC      SEMIS
})_C{}_END_({ _HOSTED_X_})
_DLL_({
_HEADER({WRITE-FILE},{WFILE},{DOCOL})
        DC      CALLOPEN
        DC      PAR1             ;   hFile: dword;
        DC      PAR3     ; nNumberOfBytesToWrite: dword;
        DC      PAR2       ; var lpBuffer: var;
        ; var lpNumberOfBytesWritten: dword; points to limbo.
        DC      PARS, FETCH, LIT, 10, LCELLS, PLUS, PAR4
        DC      ZERO, PAR5 ; var lpOverlapped: OVERLAPPED
        DC      LIT, _WriteFile@20, ICALLCLOSE
        DC      TOERR
        DC      SEMIS
})_C{}_END_({ _DLL_})
_HOSTED_MSDOS_({
_HEADER({WRITE-FILE},{WFILE},{DOCOL})
        DC      LIT, write, BDOSN
        DC      ZEQU
        _0BRANCH({WFILE1})
        DC      DROP, ZERO
WFILE1:
        DC      SEMIS
})_C{}_END_({ _HOSTED_MSDOS_})
_HOSTED_DPMI_({
_HEADER({WRITE-FILE},{WFILE},{DOCOL})
        DC      TOR             _C{>R}
WFIL1:                          _C{BEGIN}
        DC      TDUP, LIT, 0x8000 _C{   2DUP 8000 MIN R@ ^ WRITE-FILE}
        DC      MIN, RR, LWRITE
        DC      LDUP             _C{   DUP}
        _0BRANCH({WFIL2})        _C{ IF RDROP >R 2DROP R> EXIT}
        DC      RDROP, TOR, TDROP, FROMR, EXIT
WFIL2:                           _C{ THEN DROP}
        DC      DROP, LIT, 0x8000, LSUB      _C{ 8000 -}
        DC      LDUP, ZERO, GREAT      _C{ DUP 0 >}
        _0BRANCH({WFIL3})        _C{ WHILE}
        DC      SWAP, LIT, 0x8000 _C{ SWAP 8000}
        DC      PLUS, SWAP       _C{ + SWAP}
        _BRANCH({WFIL1})         _C{ REPEAT}
WFIL3:
        DC      TDROP, RDROP, ZERO _C{ 2DROP RDROP 0}
        DC      SEMIS
})_C{}_END_({ _HOSTED_DPMI_})
_C
worddoc( {FILES},{OPEN-FILE}, {open_file},{sc fam --- fileid ior }, {ISO},
{Open the file with name forthvar({sc}) and file access method
forthvar({fam}). Return a file handle into forthvar({fileid})
and a result code into forthvar({ior}). The latter is the _PC_({ MSDOS}) _HOSTED_X_({ forthvar({errno}) })
error code negated, usable as a throw code.
 forthvar({fam}) is one of 0=READ_ONLY, 1=WRITE_ONLY, 2=READ_WRITE.
_DLL_({For your convenience, all files are opened in binary mode.})
},
{{READ-FILE},{WRITE-FILE},{CREATE-FILE},{DELETE-FILE},{CLOSE-FILE}},
{
{345 "money" 0 OPEN-FILE 0 < . DROP . },{_T_ 345},
dnl This may fail the first time the test runs
{"hello.frt" 0 OPEN-FILE . DUP 0 > . },{0 _T_},
{CLOSE-FILE .},{0}
},
enddoc)
_HOSTED_X_({
_HEADER({OPEN-FILE},{OFILE},{DOCOL})
        DC      TOR, ZEN, FROMR
_HOSTED_OSX_({
        DC      TDUP, ZERO
        DC      LIT, access, XOS, LDUP
        _0BRANCH({OFIL1})
        DC      NEGATE, NIP, EXIT
OFIL1:
        DC      DROP
})_C{}_END_({_HOSTED_OSX_})
        DC      X
        DC      LIT, open, XOS
        DC      LDUP, ZERO, MIN
        DC      SEMIS
})_C{}_END_({_HOSTED_X_})
_DLL_({
_HEADER({OPEN-FILE},{OFILE},{DOCOL})
        DC      CALLOPEN
        DC      LIT, GENERIC_READ, LOR, PAR2 ; OR 8000H
        DC      ZEN, PAR1
        DC      LIT, FILE_SHARE_READ, PAR3
        DC      ZERO, PAR4
        DC      LIT, OPEN_EXISTING, PAR5
        DC      LIT, FILE_ATTRIBUTE_NORMAL, LIT, 6, PARI
        DC      ZERO, LIT, 7, PARI
        DC      LIT, CreateFile, ICALLCLOSE
        DC      LDUP, TOERR
        DC      SEMIS
})_C{}_END_({_DLL_})
_MODERN_({
_HEADER({OPEN-FILE},{OFILE},{DOCOL})
        DC      TOR, ZEN, X, X
        DC      LIT, open, FROMR, PLUS, BDOSN
        _0BRANCH({OFILE1})
        DC      LDUP
        _BRANCH({OFILE2})
OFILE1:
        DC      ZERO
OFILE2:
        DC      SEMIS
})_C{}_END_({_MODERN_})
_C
worddoc( {FILES},{CLOSE-FILE}, {close_file},{fileid --- ior }, {ISO},
{Close the file with file handle in forthvar({fileid}). Return
a result code into forthvar({ior}). The latter is the _HOSTED_({_OS_})
error code negated, usable as a throw code.},
{{OPEN-FILE},{READ-FILE},{WRITE-FILE},{CREATE-FILE},{DELETE-FILE}},
{{." See OPEN-FILE"},{See OPEN-FILE}},
enddoc)
_HOSTED_X_({
_HEADER({CLOSE-FILE},{CFILE},{DOCOL})
        DC      X, X
        DC      LIT, close, XOS
        DC      SEMIS
})_C{}_END_({_HOSTED_X_})
_DLL_({
_HEADER({CLOSE-FILE},{CFILE},{DOCOL})
        DC      CALLOPEN, PAR1, LIT, CloseHandle, ICALLCLOSE
        DC      ZEQU, TOERR
        DC      SEMIS
})_C{}_END_({_DLL_})
_MODERN_({
_HEADER({CLOSE-FILE},{CFILE},{DOCOL})
        DC      TOR, X, X, FROMR
        DC      LIT, close, BDOSN
        _0BRANCH({CFILE1})
        _BRANCH({CFILE2})
CFILE1:
        DC      DROP, ZERO
CFILE2:
        DC      SEMIS
})_C{}_END_({_MODERN_})
_C
_HOSTED_OSX_({
worddoc( {FILES},{CREATE-FILE}, {create_file},{sc fam --- fileid ior }, {ISO},
{_MODERN_({ Create a file with name forthvar({sc}) and
access method forthvar({fam}), for normal files this is just 0.})
_PC_({The meaning is to be found in the MSDOS programmers
manual at INT 21h function 3Ch "Create file with handle"}).
_HOSTED_({ Create a file with name forthvar({sc}) and file
access method forthvar({fam}) })
If the file already exists,
it is truncated to zero length. Return a file handle into
forthvar({fileid}) and a result code into forthvar({ior}).
The latter is the _PC_({ MSDOS}) _HOSTED_X_({
forthvar({errno}) }) negated, to be inspected using
forthcode({MESSAGE}) .
_HOSTED_LINUX_({ The handle is open for READ_WRITE, so forthvar({fam}) is
in fact ignored. The access privileges default to octal 755. })
},
{{OPEN-FILE},{READ-FILE},{WRITE-FILE},{DELETE-FILE}},
{{"AAP" 0 CREATE-FILE . DUP 0 > . },{0 _T_},
{CLOSE-FILE .},{0}},
enddoc)
_HEADER({CREATE-FILE},{CREATEF},{DOCOL})
        DC      TOR, TDUP, DFILE, DROP
        DD      ZEN, LIT, O_CREAT|O_WRONLY|O_TRUNC, FROMR
        DD      LIT, open, XOS
        DC      LDUP, ZERO, MAX, SWAP, ZERO, MIN
        DC      SEMIS
})_C{}_END_({_HOSTED_OSX_})
_HOSTED_LINUX_({
worddoc( {FILES},{CREATE-FILE}, {create_file},{sc fam --- fileid ior }, {ISO},
{ Create a file with name forthvar({sc}) and file
access method forthvar({fam}) .
If the file already exists,
it is truncated to zero length. Return a file handle into
forthvar({fileid}) and a result code into forthvar({ior}).
The latter is the forthvar({errno})  negated, to be inspected using
forthcode({MESSAGE}) .
 The handle is open for READ_WRITE, so forthvar({fam}) is
in fact ignored.
The access privileges default to octal 755.
This can be changed by applying forthcode({mask 8 LSHIFT OR}) where
 forthcode({mask}) contains the privilege bits one wants to change.
},
{{OPEN-FILE},{READ-FILE},{WRITE-FILE},{DELETE-FILE}},
{{"AAP" 0 CREATE-FILE . DUP 0 > . },{0 _T_},
{CLOSE-FILE .},{0}},
enddoc)
_HEADER({CREATE-FILE},{CREATEF},{DOCOL})
        DC      TOR, TDUP, DFILE, DROP, ZEN
        DC      LIT, _O(755), FROMR, LIT, 8, RSHIFT, LXOR
        DC      X
        DC      LIT, creat, XOS
        DC      LDUP, ZERO, MAX, SWAP, ZERO, MIN
        DC      SEMIS
})_C{}_END_({_HOSTED_LINUX_})
_DLL_({
worddoc( {FILES},{CREATE-FILE}, {create_file},{sc fam --- fileid ior }, {ISO},
{_MODERN_({ Create a file with name forthvar({sc}) and
access method forthvar({fam}), for normal files this is just 0.})
_PC_({The meaning is to be found in the MSDOS programmers
manual at INT 21h function 3Ch "Create file with handle"}).
_HOSTED_({ Create a file with name forthvar({sc}) and file
access method forthvar({fam}) })
If the file already exists,
it is truncated to zero length. Return a file handle into
forthvar({fileid}) and a result code into forthvar({ior}).
The latter is the _PC_({ MSDOS}) _HOSTED_X_({
forthvar({errno}) }) negated, to be inspected using
forthcode({MESSAGE}) .
_HOSTED_LINUX_({ The handle is open for READ_WRITE, so forthvar({fam}) is
in fact ignored. The access privileges default to octal 755. })
},
{{OPEN-FILE},{READ-FILE},{WRITE-FILE},{DELETE-FILE}},
{{"AAP" 0 CREATE-FILE . DUP 0 > . },{0 _T_},
{CLOSE-FILE .},{0}},
enddoc)
_HEADER({CREATE-FILE},{CREATEF},{DOCOL})
        DC      CALLOPEN, DROP
        DC      ZEN, PAR1
        DC      LIT, GENERIC_WRITE, PAR2
        DC      LIT, FILE_SHARE_READ, PAR3
        DC      ZERO, PAR4
        DC      LIT, CREATE_ALWAYS, PAR5
        DC      ZERO, LIT, 6, PARI
        DC      ZERO, LIT, 7, PARI
        DC      LIT, CreateFile, ICALLCLOSE
        DC      LDUP, TOERR
        DC      SEMIS
})_C{}_END_({_DLL_})
_MODERN_({
worddoc( {FILES},{CREATE-FILE}, {create_file},{sc fam --- fileid ior }, {ISO},
{_MODERN_({ Create a file with name forthvar({sc}) and
access method forthvar({fam}), for normal files this is just 0.})
_PC_({The meaning is to be found in the MSDOS programmers
manual at INT 21h function 3Ch "Create file with handle"}).
_HOSTED_({ Create a file with name forthvar({sc}) and file
access method forthvar({fam}) })
If the file already exists,
it is truncated to zero length. Return a file handle into
forthvar({fileid}) and a result code into forthvar({ior}).
The latter is the _PC_({ MSDOS}) _HOSTED_X_({
forthvar({errno}) }) negated, to be inspected using
forthcode({MESSAGE}) .
_HOSTED_LINUX_({ The handle is open for READ_WRITE, so forthvar({fam}) is
in fact ignored. The access privileges default to octal 755. })
},
{{OPEN-FILE},{READ-FILE},{WRITE-FILE},{DELETE-FILE}},
{{"AAP" 0 CREATE-FILE . DUP 0 > . },{0 _T_},
{CLOSE-FILE .},{0}},
enddoc)
_HEADER({CREATE-FILE},{CREATEF},{DOCOL})
        DC      TOR, ZEN, FROMR, X
        DC      LIT, create, BDOSN
        _0BRANCH({CRFILE1})
        DC      LDUP
        _BRANCH({CRFILE2})
CRFILE1:
        DC      ZERO
CRFILE2:
        DC      SEMIS
})_C{}_END_({_MODERN_})
_C
worddoc( {FILES},{DELETE-FILE}, {delete_file},{sc --- ior }, {ISO},
{Delete the file with name forthvar({sc}). Return
a result code into forthvar({ior}).
The latter is the _PC_({ MSDOS}) _HOSTED_X_({
forthvar({errno}) }) negated, to be inspected using
forthcode({MESSAGE}) .
},
{{OPEN-FILE},{READ-FILE},{WRITE-FILE},{CREATE-FILE}},
{{"AAP" 0 CREATE-FILE . CLOSE-FILE .},{0 0},
{"AAP" DELETE-FILE . },{0 },
{345 "AAP" 0 OPEN-FILE 0 < . DROP . },{_T_ 345}},
enddoc)
_HOSTED_X_({
_HEADER({DELETE-FILE},{DFILE},{DOCOL})
        DC      ZEN, X, X
        DC      LIT, unlink, XOS
        DC      SEMIS
})_C{}_END_({_HOSTED_X_})
_DLL_({
_HEADER({DELETE-FILE},{DFILE},{DOCOL})
        DC      CALLOPEN
        DC      ZEN, PAR1
        DC      LIT, _DeleteFileA@4, ICALLCLOSE
        DC      ZEQU, TOERR
        DC      SEMIS
})_C{}_END_({_DLL_})
_MODERN_({
_HEADER({DELETE-FILE},{DFILE},{DOCOL})
        DC      ZEN, X, X
        DC      LIT, delete, BDOSN
        DC      ZEQU
        _0BRANCH({DFILE1})
        DC      DROP, ZERO
DFILE1:
        DC      SEMIS
})_C{}_END_({_MODERN_})
_C
worddoc( {FILES},{READ-FILE}, {read_file}, {addr n1 fd --- n2 ior }, {ISO},
{Read forthvar({n}) characters to forthvar({addr}) from current
position of the file that is open at forthvar({fd}) .
forthvar({n2}) is the number of characters successfully read,
this may be zero. forthvar({ior}) is 0 for success, or
otherwise _PC_({the MSDOS}) _HOSTED_X_({ forthvar({errno}) })
error code negated, usable as a throw code. },
{{OPEN-FILE},{WRITE-FILE},{REPOSITION-FILE},{BLOCK-READ}},
{
{ "hello.frt" 0 OPEN-FILE . CONSTANT FD FD 0 > . },{0 _T_},
{PAD 1024 FD READ-FILE . PAD SWAP TYPE },{0 "Hello world!" TYPE},
{FD CLOSE-FILE .},{0}
},
enddoc)
_HOSTED_X_({
_HEADER({READ-FILE},{RFILE},{DOCOL})
        DC      ROT, ROT
        DC      LIT, read, XOS
        DC      LDUP, ZERO, MAX, SWAP, ZERO, MIN
        DC      SEMIS
})_C{}_END_({ _HOSTED_X_})
_DLL_({
_HEADER({READ-FILE},{RFILE},{DOCOL})
        DC      CALLOPEN
        DC      PAR1            ; hFile: dword;
        DC      PAR3            ; nNumberOfBytesToRead: dword;
        DC      PAR2            ; lpBuffer: var;
        DC      X, SPFET, PAR4  ; lpNumberOfBytesRead: var;
        DC      ZERO, PAR5      ; lpOverlapped: var;
        DC      LIT, _ReadFile@20, ICALLCLOSE
        DC      ZEQU, TOERR
        DC      SEMIS
})_C{}_END_({ _DLL_})
_HOSTED_MSDOS_({
_HEADER({READ-FILE},{RFILE},{DOCOL})
        DC      LIT, read, BDOSN
        _0BRANCH({RFILE1})
        DC      ZERO, SWAP
        _BRANCH({RFILE2})
RFILE1:
        DC      ZERO
RFILE2:
        DC      SEMIS
})_C{}_END_({ _HOSTED_MSDOS_})
_HOSTED_DPMI_({
_HEADER({READ-FILE},{RFILE},{DOCOL})
        DC      ZERO, LIT, RC, STOR, TOR
RFIL1:
        DC      TDUP, LIT, 0x8000, MIN
        DC      RR, LREAD
        DC      LDUP
        _0BRANCH({RFIL2})
        DC      RDROP, TOR, TDROP, FROMR, EXIT
RFIL2:
        DC      DROP
        DC      LIT, RC, PSTOR
        DC      LIT, 0x8000, LSUB, LDUP
        DC      ZERO, GREAT
        _0BRANCH({RFIL3})
        DC      SWAP, LIT, 0x8000, PLUS, SWAP
        _BRANCH({RFIL1})
RFIL3:
        DC      TDROP, RDROP
        DC      LIT, RC, FETCH, ZERO
        DC      SEMIS
RC:     DC      0
})_C{}_END_({ _HOSTED_DPMI_})
_C
worddoc( {FILES}, {REPOSITION-FILE}, {reposition_file}, {ud fd --- ior }, {ISO},
{Position the file that is open at forthvar({fd}) at position
forthvar({ud}). forthvar({ior}) is 0 for success, or otherwise
_PC_({the MSDOS error code}) _HOSTED_X_({forthvar({errno})})
negated . Information about
error codes can be found by forthcode({MESSAGE}). },
{{OPEN-FILE},{READ-FILE},{WRITE-FILE}},
{
{ "hello.frt" 0 OPEN-FILE . CONSTANT FD },{0 },
{5. FD REPOSITION-FILE .},{0},
{PAD 1024 FD READ-FILE . PAD SWAP TYPE },{0 o world!" TYPE},
{FD CLOSE-FILE .},{0}
},
enddoc)
_LINUX_N_({
_HEADER({REPOSITION-FILE},{PFILE},{DOCOL})
        DC      TOR, DROP, FROMR   _C{Convert to single precision.}
        DC      SWAP
        DC      LIT, SEEK_SET
        DC      LIT, lseek, XOS
        DC      ZERO, MIN
        DC      SEMIS
})_C{}_END_({_LINUX_N_})
_HOSTED_OSX_({
_HEADER({REPOSITION-FILE},{PFILE},{DOCOL})
        DC      ROT, ROT
        DC      LIT, SEEK_SET, X
        DC      LIT, lseek, XOS5
        DC      ZERO, MIN
        DC      SEMIS
})_C{}_END_({_HOSTED_OSX_})
_DLL_({
_HEADER({REPOSITION-FILE},{PFILE},{DOCOL})
        DC      CALLOPEN
        DC      PAR1
        DC      DROP, PAR2       _C{Convert to single precision.}
        DC      ZERO, PAR3
        DC      LIT, FILE_BEGIN, PAR4
        DC      LIT, SetFilePointer, ICALLCLOSE
        DC      TOERR
        DC      SEMIS
})_C{}_END_({_DLL_})
_MODERN_({
_HEADER({REPOSITION-FILE},{PFILE},{DOCOL})
        _BITS32_({DC     TOR, DROP, LIT, 0x10000, SLMOD, FROMR})
        _BITS64_({DC     ERROR, LOOK GOOD INTO THIS})
        DC      LIT, lseek, BDOSN
        DC      ZEQU
        _0BRANCH({PFILE1})
        DC      DROP, ZERO
PFILE1:
        DC      SEMIS
})_C{}_END_({_MODERN_})
_C
_HOSTED_DPMI_({
worddoc( {FILES},{READ}, {read}, {addr n1 fd --- n2 ior }, {ISO},
{As forthcode({READ-FILE}) , but can handle only 32K.
},
{{READ-FILE}},
{
{ "hello.frt" 0 OPEN-FILE . CONSTANT FD FD 0 > . },{0 _T_},
{PAD 1024 FD READ . PAD SWAP TYPE },{0 "Hello world!" TYPE},
{FD CLOSE-FILE .},{0}
},
enddoc)
_HEADER({READ},{LREAD},{DOCOL})
        DC      RWBUF, ROT, ROT         _C{ RW-BUFFER ROT ROT}
        DC      LIT, read, BDOSN        _C{ 3F00 BDOSN IF}
        _0BRANCH({READ1})
        DC      TOR, DROP               _C{ >R DROP}
        DC      ZERO, FROMR             _C{ 0 R> NEGATE ELSE}
        _BRANCH({READ2})
READ1:
        DC      TOR, TOR         _C{ >R >R}
        DC      LIT, Save_DS_PR, FETCH, RWBUF _C{ <FAR> RW-BUFFER}
        DC      ZERO, FROMR                   _C{ 0 R>}
        DC      RR, FMOVE, FROMR, ZERO        _C{ R@ FARMOVE   R> 0}
READ2:
        DC      SEMIS
_C
worddoc( {FILES},{WRITE}, {write},{addr n fd --- u1 }, {ISO},
{As forthcode({WRITE-FILE}) , but can handle only 32K.
},
{{RW-BUFFER}},
{ { "hello.frt" 0 CREATE-FILE . CONSTANT FD },{0 },
{"""Hello world!"" TYPE" FD WRITE .},{0},
{^M PAD C! ^J PAD 1+ C! PAD 2 FD WRITE .},{0},
{FD CLOSE-FILE .},{0} },
enddoc)
_HEADER({WRITE},{LWRITE},{DOCOL})
        DC      TOR, TOR, ZERO, SWAP    _C{   >R >R  0 SWAP}
        DC      LIT, Save_DS_PR, FETCH, RWBUF  _C{ PD RW-BUFFER}
        DC      RR, FMOVE               _C{ R@ FARMOVE}
        DC      RWBUF, FROMR, FROMR     _C{ RW-BUFFER R> R>}
        DC      LIT, write, BDOSN       _C{  4000 BDOSN}
        DC      ZEQU
        _0BRANCH({WRITE1})              _C{ IF NEGATE ELSE DROP 0 THEN ;}
        DC      DROP
        DC      ZERO
WRITE1:
        DC      SEMIS
_C
})_C{}_END_({ _HOSTED_DPMI_})
worddoc( {FILES},{GET-FILE},{get_file},{sc1 --- sc2},{},
{Get the content of the file with name forthvar({sc1});
leave it as a string forthvar({sc2}). Any errors are thrown.
The file is permanently stored at forthcode({HERE}) .
},
{{PUT-FILE},{OPEN-FILE},{THROW}},
{{"hello.frt" GET-FILE TYPE },{"Hello world!" TYPE}},
enddoc)
_HEADER({GET-FILE},{GETFILE},DOCOL)
        DC      TDUP, SCOMMA, DROP
        DC      LIT, 'F'+(0x100*('i'+0x100*('L'+0x100*'e'))), COMMA _C{Magic number.}
        DC      ZERO, OFILE, THROW, TOR
        DC      HERE, LDUP
        DC      SPFET, HERE, LSUB
        DC      LIT, 6, SLASH, LDUP, ALLOT
        DC      LIT, 1000, LSUB
        DC      RR, RFILE, THROW
        DC      FROMR, CFILE, THROW
        DC      TDUP, PLUS, LDP, STOR        _C{ No allocation if it fails.}
        DC      SEMIS
_C
worddoc( {FILES},{PUT-FILE},{put_file},{sc1 sc2 ---},{},
{Save the forthdefin({string constant}) forthvar({sc1}) to a file with
the name forthvar({sc2}). Any errors are thrown. },
{{GET-FILE},{OPEN-FILE},{THROW}},
{{"CONTENT" "orang" PUT-FILE "orang" GET-FILE TYPE },{CONTENT}},
enddoc)
_HEADER({PUT-FILE},{PUTFILE},DOCOL)
        DC      ZERO
        DC      CREATEF, THROW
        DC      LDUP, TOR
        DC      WFILE, THROW
        DC      FROMR, CFILE, THROW
        DC      SEMIS
_C
worddoc( {FILES},{INCLUDED},{INCLUDED},{sc1 --- i*x},{ISO},
{Interpret the content of the file with name forthvar({sc1})
as if it was typed from the console, leaving result
forthvar({i*x}).
The file is permanently stored in the dictionary.
},
{{LOAD},{}},
{{"hello.frt" INCLUDED},{Hello world!}},
enddoc)
_HEADER({INCLUDED},{INCLUD},DOCOL)
        DC      HERE, TOR
        DC      LIT, GETFILE, CATCH
        DC      LDUP
        _0BRANCH(INCLUD1)
        DC      FROMR, LDP, STOR
        DC      THROW
        _BRANCH(INCLUD2)
INCLUD1:
        DC      RDROP, DROP
INCLUD2:
        DC      EVALUATE
        DC      SEMIS
_C
worddoc( {INPUT~},{REFILL-TIB},{refill_tib},{ ---} ,{},
{Accept characters from the terminal input stream such as to
fill up forthcode({TIB}) . Normally this means until a
forthkey({RET}).
It is now consumable
by forthcode({ACCEPT}) or after forthcode({SET-SRC}) by
Forth parsing words like forthcode({NAME}) .
The editing functions
are those described by forthcode({ACCEPT}).
Immediately, after forthcode({REFILL-TIB}) forthsamp({REMAINDER 2@@}) defines
the characters ready in the input buffer. All characters are
retained including the forthkey({RET}).

If the input is redirected (such that
after a forthkey({RET}) more characters are available)
forthsamp({REMAINDER 2@@}) contains the part of
forthcode({TIB}) that is not yet consumed by forthcode({(ACCEPT)}) ,
and outside the reach of forthcode({SRC}) .

_HOSTED_({ All errors from _OS_ result in an exception.})
The end of normal or redirected I/O results in an an end-of-pipe exception
in this word, which terminates thisforth and is not considered an error condition.
},
{{ACCEPT},{(ACCEPT)}},
{
{"see (ACCEPT)" TYPE},{see (ACCEPT)}
},
enddoc)
_HEADER({REFILL-TIB},{REFTIB},{DOCOL})
        DC      REMAIND, FETCH, TOR
        DC      TIB, FETCH, RR, PLUS
        DC      LIT, TIBSIZE, RR, LSUB
        DC      _DLL_({STDIN},{ZERO})
        DC      RFILE
        DC      QERRUR
        DC      LDUP, ZEQU, LIT, -EPIPE, LAND _C{ Presumably end of pipe.}
        DC      QERRUR
        DC      TIB, FETCH, SWAP, FROMR, PLUS
        DC      REMAIND, TSTOR
        DC      SEMIS
_C
})_C{}_END_({_FILES_})
_MODERN_({
_SUPPRESSED({{ Leave this in for reference.
worddoc( {INPUT~},{REFILL-TIB},{refill_tib},{ ---} ,{},
{Accept characters from the terminal input stream such as to
fill up forthcode({TIB}) . Normally this means until a
forthkey({RET}). If the input is redirected (such that reading
after forthkey({RET}) cannot be prevented)
forthsamp({REMAINDER 2@@}) contains the first part of
forthcode({TIB}) that has a left over from the previous read.
After forthcode({REFILL-TIB}) forthsamp({REMAINDER 2@@}) defines
the characters ready in the input buffer. All characters are
retained including the forthkey({RET}). The editing functions
are the same as with forthcode({ACCEPT}).
},
{{ACCEPT},{(ACCEPT)}},
{
{ "see (ACCEPT)" TYPE},{see (ACCEPT)}
},
enddoc)
_NO_DPMI_({
_HEADER({REFILL-TIB},{REFTIB},{DOCOL})
_BITS16_({      DC      TIB, FETCH, REMAIND, FETCH, PLUS},{dnl})
_BITS64_( {_ERROR Look good into this, 64 bit.})
_BITS32_( {_C{ MSDOS cannot handle a 32 bits address: use the buffer.}})
_BITS32_( {     DC   LIT, EXPECTBUF },{dnl})
_SWITCH_({        DC   LIT, M4_SWITCHOFFSET, PLUS, },{dnl})
_BITS16_({        DC      LIT, TIBSIZE, REMAIND, FETCH, LSUB},{dnl})
_BITS32_( {     DC   LIT, 0x0200},{dnl})
        DC      ZERO     _C{ Handle}
        DC      RFILE, LIT, 6, QERR
_BITS32_(
{_C{ Copy the buffer.}
        DC      LIT, EXPECTBUF, OVER
        DC      TIB, FETCH, RR, PLUS
        DC      SWAP, LCMOVE},
{dnl})
        DC      LDUP, ZEQU
        _0BRANCH(PACCEP3)
        DC      ZERO, REMAIND, STOR
        DC      LIT, -32, LAND, THROW _C{ Presumably end of pipe.}
PACCEP3:
        DC      TIB, FETCH, SWAP, REMAIND, FETCH, PLUS
        DC      REMAIND, TSTOR
        DC      SEMIS
_BITS32_({EXPECTBUF:  _RESB( 0x0200 ) },{dnl})
_C
})_C{}_END_({ _NO_DPMI_})
}})_C{}_END_({ _SUPPRESSED}) dnl with this this whole MODERN section has been burned down!
})_C{}_END_({_MODERN_})
_LINUX_C_({
_C{ Code fields are filled in during bootup. }
_C{ Lower case labels starting with "c_.." are c-supplied facilities.}
worddocsafe( {INPUT},{(ACCEPT)},{paren_accept},{ --- sc } ,{},
{Input a line
until a "return") from the operators terminal, and leave it as
a forthdefin({string constant}).
It doesn't contain the forthkey({LF}),
but the buffer still does and after forthcode({1+}) the string
contains forthkey({LF}).
_VERBOSE_({{This is lighter on the system and sometimes easier
to use than }forthcode({ACCEPT}){
Text is probably present in the buffer address contained in
}forthcode({TIB @@}){, but not necessarily at the beginning. }})
},
{{ACCEPT},{EVALUATE}},
{{." interactive"},{interactive}},
enddoc)
_HEADER({(ACCEPT)},{PACCEP},{DOCOL})
        DC      TIB
        DC      FETCH
        DC      LDUP
        DC      LIT,TIBSIZE
        DC      ACCEP
_C{ Keep the next line in for debugging ACCEPT for MSDOS.}
_C{        DC      LIT, 0x41, EMIT, TDUP, LTYPE, LIT, 0x41, EMIT}
_C{        DC      DOTS}
        DC      SEMIS
_C
worddoc( {INPUT},{ACCEPT},{accept},{addr count --- n},{ISO,FIG},
{Transfer at most forthvar({count}) characters from the
terminal to forthvar({addr}) .
The transfer takes place when a forthkey({RET}) is received,
and excess characters after forthvar({count}) are ignored.
Rely on the operating system for input editing. One or more
nulls are added at the end of the text.
},{{KEY},{KEY?}}, {}, enddoc)
CODE_HEADER({ACCEPT},{ACCEP})
        CALL    c_expec
        LEA     ESP,[ESP+_CELLS(2)]    _C{ remove input}
        PUSH    EAX
        _NEXT
_C
worddoc( {INPUT},{KEY},{key},{--- c},{ISO,FIG},
{Leave the ASCII value of the next terminal key struck.},{}, {}, enddoc)
CODE_HEADER({KEY},{KEY})
        CALL    c_key
        PUSH    EAX
        _NEXT
_C
worddoc( {INPUT},{KEY?},{key_question},{--- f},{ISO},
{Perform a test of the terminal keyboard for a break request.
Any key pressed is interpreted as such and the key is not consumed.
A non-zero flag indicates actuation. },{}, {}, enddoc)
CODE_HEADER({KEY?},{KEYQ})
        CALL    c_qterm
        PUSH    EAX
        _NEXT
_C
worddoc( {OUTPUT},{TYPE},{type},{addr count ---},{ISO,FIG},
{Transmit count characters from forthvar({addr}) to the output device.
All terminal I/O goes through this word.
forthcode({OUT}) is not observed.},{{EMIT},{OUT}}, {}, enddoc)
CODE_HEADER({TYPE},{LTYPE},DOCOL)
        CALL    c_type
        LEA     ESP,[ESP+_CELLS(2)]    _C{ remove input}
        _NEXT
_C
worddoc( {OUTPUT},{ETYPE},{etype},{addr count ---},{},
{This behaves identical to forthcode({TYPE}) .
However it is used for all error message, so via this word
error output can be redirected, by
forthdefi({revectoring}) it.
},
,
dnl This test assumes a redirection of error out to standard out.
{{HERE 41 C, 42 C, 2 ETYPE},{AB}},
enddoc)
_HEADER({ETYPE},{ETYPE},{DOCOL})
        DC      LTYPE
        DC      SEMIS
_C
})_C{}_END_({_LINUX_C_})
_HOSTED_X_({
_C{ All I/O goes through the modern device (Unix-standard)}
_C{ device I/O. Code fields are filled in during bootup. }
_C{ Lower case labels starting with "c_.." are c-supplied facilities.}
worddoc( {INPUT},{ACCEPT},{accept},{addr count --- n},{ISO},
{Transfer at most forthvar({count}) characters from the
terminal to forthvar({addr}) .
The transfer takes place when a forthkey({RET}) is received,
and excess characters after forthvar({count}) are ignored.
The
simple tty editing functions of _OS_ are observed, i.e. the
``erase'' (delete a character) and ``kill'' (delete a line)
characters. Typically these are the backspace key and ^U.
The number of characters not
including the forthkey({RET}) is returned into forthvar({n}).
},
{{(ACCEPT)},{KEY},{KEY?}},
{
{PAD 10 ACCEPT},{},
 {GIBBON
  . PAD 6 TYPE},{6 GIBBON},
 {( ." Type an 'A'" PAD 2 ACCEPT . PAD C@ EMIT)( 1 A)},{},
 {( ." Type an 'ABCDEF'" PAD 80 ACCEPT . )( 6)},{},
 {( ." Type an 'ZX'" PAD 1 ACCEPT . PAD C@ EMIT)( 1 Z)},{}
},
enddoc)
_HEADER({ACCEPT},{ACCEP},{DOCOL})
        DC      PACCEP
        DC      TSWAP, ROT, MIN
        DC      LDUP, TOR, LMOVE, FROMR
        DC      SEMIS
_C
worddocsafe( {INPUT},{(ACCEPT)},{paren_accept},{ --- sc } ,{},
{Accept characters from the terminal, until a forthkey({RET})
is received and return the result as a constant string
forthvar({sc}).
It doesn't contain any line ending, but the buffer still does
and after forthcode({1+}) the string ends in a forthkey({LF}).
The editing functions are the same as with forthcode({ACCEPT}) .
_VERBOSE_({{This is lighter on the system and sometimes easier
to use than }forthcode({ACCEPT}){ }})
This input remains valid until the next time that the console
buffer is refilled.
With TIBSIZE characters the terminal input buffer overflows,
with unpredictable results.
},
{{KEY},{KEY?},{ACCEPT},{PP@@@@},{REFILL-TIB}},
{
{(ACCEPT)},{},
 {GIBBON
  DUP . TYPE},{6 GIBBON},
dnl { ." Type an 'A'" (ACCEPT) DUP . TYPE},{1 A)},
dnl {." Type an 'ABCDEF'" DUP . },{6},
},
enddoc)
_HEADER({(ACCEPT)},{PACCEP},{DOCOL})
PACCEP2:
_C{        DC      NOLF}
_C{        DC       LIT, 'a', EMIT}
        DC      REMAIND
        DC      TFET
        DC      LIT, ALF, SINDEX
        DC      ZEQU
        _0BRANCH(PACCEP1)
_C{        DC      RETOBO}
        DC      REMAIND, TFET
        DC      TIB, FETCH
        DC      SWAP, LMOVE
        DC      TIB, FETCH
        DC      REMAIND, CELLP, STOR
        DC      REFTIB
        _BRANCH(PACCEP2)
PACCEP1:
_C{        DC      SPLOFF}
        DC      REMAIND, TFET
        DC      LIT, ALF, SSLAS
        DC      TSWAP, REMAIND, TSTOR
        DC      SEMIS

worddoc( {INPUT},{KEY},{key},{--- c},{ISO,FIG},
{Leave the ASCII value of the next terminal key struck.},
{{ACCEPT},{KEY?}},
dnl THE TEST CODE HERE IS PARTLY INPUT FOR KEY
dnl HENCE THE CRITICAL LAYOUT WITH RESPECT TO CR'S
dnl KEY has to be patched with the code `` DSP@ 1 ACCEPT DROP ''
dnl because while redirected the input is buffered in ACCEPT.
dnl {
dnl {CR KEY},{},
dnl  {G
dnl   EMIT CR},{
dnl G},
dnl {CR KEY},{},
dnl  {G EMIT CR},{G}
dnl }
,
enddoc)
_HEADER({KEY},{KEY},{DOCOL})
        DC      ONE, LIT, RAWIO, STTERM _C{ Do not wait for CR}
        DC      ZERO, SPFET     _C{ Expect single key on stack}
        DC      ZERO            _C{ Standard input}
        DC      SWAP, ONE       _C{ Buffer and length}
        DC      LIT, read, XOS
        DC      LDUP, QERRUR
        DC      ZEQU, LIT, -EPIPE, LAND, QERRUR _C{ Presumably end of pipe.}
        DC      ONE, LIT, RAWIO, STTERM       _C{ Toggle back}
        DC      SEMIS
_C
worddoc( {INPUT},{KEY?},{key_question},{--- ff},{ISO},
{Return into forthvar({ff}) whether a character is available.
The next execution of forthcode({KEY}) will return the character immediately.
},
{{KEY},{ACCEPT},{KEY?}},
{{." interactive"},{interactive}},
enddoc)
_HEADER({KEY?},{KEYQ},{DOCOL})
        DC      ZERO, LIT, RAWIO, STTERM
        DC      ZERO, ZERO     _C{ Time out of zero. See MS.}
        _BITS64_({DC    LIT, TV, LSTOR, LIT, TV+4, LSTOR}
        ,{ DC      LIT, TV, TSTOR})
        DC      ONE _C{ Waiting for standard in.}
        DC      LIT, RFDS, _BITS64_({LSTOR},{STOR})
        DC      ONE     _C{ # of highest channel to watch.}
        DC      LIT, RFDS
        DC      ZERO, ZERO  _C{ Not output, not events.}
        DC      LIT, TV
        DC      LIT, _newselect, XOS5
        DC      LDUP,  QERRUR
        DC      NEGATE        _C{ 1 -> flag.}
        DC      ZERO, LIT, RAWIO, STTERM
        DC      SEMIS
        _ALIGN(_CELLS(1))
RFDS:   _RESB( _CELLS(32))     _C{32 channels maximum.}
_C
worddoc( {OUTPUT},{TYPE},{type},{addr count ---},{ISO,FIG},
{Transmit forthvar({count}) characters from forthvar({addr}) to
the output device. All terminal I/O goes through this word. It
is high level so terminal I/O can be redirected, by
forthdefi({revectoring}) it _VERBOSE_({{and the usual
redirection or }forthsamp({tee}){-ing by _OS_}}). In this
ciforth strings may contain embedded forthkey({LF}) 's with the
effect of a new line at that point in the output, however in
that case forthcode({OUT}) is not observed. },
{{EMIT},{OUT},{ETYPE}},
{{HERE 41 C, 42 C, 2 TYPE},{AB}},
enddoc)
_HEADER({TYPE},{LTYPE},{DOCOL})
        DC      LDUP, LOUT, PSTOR
        DC      _DLL_({STDOUT},{ONE}), WFILE, THROW
        DC      SEMIS
_C
worddoc( {OUTPUT},{ETYPE},{etype},{addr count ---},{},
{Transmit forthvar({count}) characters from forthvar({addr}) to
the standard error device.
It is high level so error output can be redirected, by
forthdefi({revectoring}) it. _VERBOSE_({Or you may use
redirection by _OS_}). In this
ciforth strings may contain embedded forthkey({LF}) 's with the
effect of a new line at that point in the output. },
{{EMIT},{TYPE}},
dnl This test assumes a redirection of error out to standard out.
{{HERE 41 C, 42 C, 2 ETYPE},{AB}},
enddoc)
_HEADER({ETYPE},{ETYPE},{DOCOL})
        DC      _DLL_({STDERR},{TWO}), WFILE, THROW
        DC      SEMIS
_C
worddoc( {OUTPUT},{EMIT},{emit},{c ---},{ISO,FIG},
{Transmit ASCII character forthvar({c}) to the output device.
For this ciforth all terminal I/O goes through forthcode({TYPE}).
In this ciforth forthcode({EMIT}) maintains forthcode({OUT}).},
{{TYPE},{OUT}},
{ {&z EMIT},{z} },
enddoc)
_HEADER({EMIT},{EMIT},{DOCOL})
        DC      SPFET, ONE, LTYPE
        DC      DROP
        DC      SEMIS
_C
worddoc( {INPUT~},{TERMIO},{termio},{--- addr},{},
{Leave the address of the terminal description, this has the layout of
a c-structure forthsamp({termios}) .
},{{SET-TERM}},
{{." interactive"},{interactive}},
enddoc)
_HEADER({TERMIO},{TERMIO},{DOVAR}, )
        _RESB(SIZE_TERMIO)     _C{ Filled in during cold boot.}
_C
worddoc( {INPUT~},{SET-TERM},{set_term},{len b ---},{},
{Set the terminal length to forthvar({len}) and toggle the c_lflag field
with forthvar({b}) in the termios structure forthcode({TERMIO}) .
In particular toggling with 0x0A makes that
the terminal doesn't wait for a forthkey({RET}).
This word is invalid for pipes, and is replaced by
a forthcode({2DROP}) in that case.
},{{TERMIO},{KEY}},
{{." interactive"},{interactive}},
enddoc)
_HEADER({SET-TERM},{STTERM},{DOCOL})
SIZEL   EQU 4     _C{ Also for 64 bits. }
        DC      LIT, _VAR_FIELD(TERMIO)+SIZEL*3
        DC      SWAP, TOGGL
        DC      LIT, _VAR_FIELD(TERMIO)+SIZEL*4+7
        DC      CSTOR
        DC      ZERO, LIT, TCSETS, TERMIO
        DC      LIT, ioctl, XOS, QERRUR
        DC      SEMIS
_C
})_C{}_END_({ _HOSTED_X_})
_DLL_({
worddoc( {OUTPUT},{TYPE},{type},{addr count ---},{ISO,FIG},
{Transmit forthvar({count}) characters from forthvar({addr}) to
the output device. All terminal I/O goes through this word. It
is high level so terminal I/O can be redirected, by
forthdefi({revectoring}) it _VERBOSE_({{and the usual
redirection or }forthsamp({tee}){-ing by _OS_}}). In this
ciforth strings may contain embedded forthkey({LF}) 's with the
effect of a new line at that point in the output, however in
that case forthcode({OUT}) is not observed. },
{{EMIT},{OUT},{ETYPE}},
{{HERE 41 C, 42 C, 2 TYPE},{AB}},
enddoc)
_HEADER({TYPE},{LTYPE},{DOCOL})
        DC      LDUP, LOUT, PSTOR
        DC      STDOUT, WFILE, THROW
        DC      SEMIS
_C
worddoc( {OUTPUT},{ETYPE},{etype},{addr count ---},{},
{Transmit forthvar({count}) characters from forthvar({addr}) to
the standard error device.
It is high level so error output can be redirected, by
forthdefi({revectoring}) it. _VERBOSE_({Or you may use
redirection by _OS_}). In this
ciforth strings may contain embedded forthkey({LF}) 's with the
effect of a new line at that point in the output. },
{{EMIT},{TYPE}},
dnl This test assumes a redirection of error out to standard out.
{{HERE 41 C, 42 C, 2 ETYPE},{AB}},
enddoc)
_HEADER({ETYPE},{ETYPE},{DOCOL})
        DC      STDERR, WFILE, THROW
        DC      SEMIS
_C
dnl same as in HOSTED_X
worddoc( {OUTPUT},{EMIT},{emit},{c ---},{ISO,FIG},
{Transmit ASCII character forthvar({c}) to the output device.
For this ciforth all terminal I/O goes through forthcode({TYPE}).
In this ciforth forthcode({EMIT}) maintains forthcode({OUT}).},
{{TYPE},{OUT}},
{ {&z EMIT},{z} },
enddoc)
_HEADER({EMIT},{EMIT},{DOCOL})
        DC      SPFET, ONE, LTYPE
        DC      DROP
        DC      SEMIS
_C
worddoc( {INPUT},{SET-MODE},{set_mode},{u --- },{},
{Set the mode of standard input to forthvar({u}), as defined
in MS-WINDOWS forthemph({GetConsoleMode}) function from
forthemph({_BITS64_({KERNEL32.DLL})_BITS32_({KERNEL32.DLL})})
},
{{GET-MODE},{KEY?}}, {}, enddoc)
_HEADER({SET-MODE},{SETMODE},{DOCOL})
        DC      CALLOPEN
        DC      STDIN, PAR1
        DC      PAR2
        DC      LIT, _SetConsoleMode@8, ICALLCLOSE
        DC      ZEQU, TOERR, THROW
        DC      SEMIS
_C
worddoc( {INPUT},{GET-MODE},{get_mode},{ --- u },{},
{Get the mode of standard input to forthvar({u}), as defined
in MS-WINDOWS forthemph({GetConsoleMode}) function from
forthemph({_BITS64_({KERNEL32.DLL})_BITS32_({KERNEL32.DLL})}).
},
{{SET-MODE},{KEY?}}, {}, enddoc)
_C
_HEADER({GET-MODE},{GETMODE},{DOCOL})
        DC      CALLOPEN
        DC      STDIN, PAR1
        DC      X, SPFET,  PAR2
        DC      LIT, _GetConsoleMode@8, ICALLCLOSE
        DC      ZEQU, TOERR, THROW
        DC      SEMIS
; EXTRN     _GetConsoleMode@8    : NEAR
; : GET-MODE _ DSP@ STD-IN 0 GCM CALL-C ;
_C
worddoc( {INPUT},{KEY},{key},{--- c},{ISO,FIG},
{Leave the ASCII value of the next terminal key struck.},
{{ACCEPT},{KEY?}}, {}, enddoc)
_HEADER({KEY},{KEY},{DOCOL})
        DC      GETMODE, TOR, ZERO, SETMODE  _C{ Raw mode.}

        DC      CALLOPEN
        DC      STDIN, PAR1
        DC      ZERO, SPFET, PAR2
        DC      ONE, PAR3
        DC      PARS, FETCH, LIT, _CELLS(5), PLUS, PAR4  _C{ Limbo.}
        DC      ZERO,  PAR5
        DC      LIT, _ReadConsoleA@20, ICALLCLOSE
        DC      ZEQU, TOERR, THROW

        DC      FROMR, SETMODE          _C{ Restore mode.}
        DC      SEMIS
_C
worddoc( {INPUT},{KEY?},{key_question},{--- f},{ISO},
{Perform a test of the terminal keyboard for a break request.
Any key pressed is interpreted as such and the key is not consumed.
A non-zero flag indicates actuation. },{{KEY},{ACCEPT}}, {}, enddoc)
_HEADER({KEY?},{KEYQ},DOCOL)
        DC      CALLOPEN
        DC      X, SPFET, PAR4       _C{ 4: Result buffer of length.}
        DC      ONE, PAR3, RWBUF, PAR2, STDIN, PAR1   _C{ 3..1 }
        DC      LIT, _PeekConsoleInputA@16, ICALLCLOSE
        DC      ZEQU, TOERR, THROW
        DC      ZEQU, ZEQU      _C{ Well formed flag.}
        DC      SEMIS
_C
worddoc( {INPUT},{ACCEPT},{accept},{addr count --- n},{ISO},
{Transfer at most forthvar({count}) characters from the
terminal to forthvar({addr}) .
The transfer takes place when a forthkey({RET}) is received,
and excess characters after forthvar({count}) are ignored.
The simple tty editing functions of _OS_ are observed, like the
backspace key, and probably also the cursors keys, maybe more.
The number of characters not
including the forthkey({RET}) is returned into forthvar({n}).
The data at adr remains valid indefinitely.
},
{{(ACCEPT)},{KEY},{KEY?}},
{
{PAD 10 ACCEPT},{},
 {GIBBON
  . PAD 5 TYPE},{6 GIBBO},
 {( ." Type an 'A'" PAD 2 ACCEPT . PAD C@ EMIT)( 1 A)},{},
 {( ." Type an 'ABCDEF'" PAD 80 ACCEPT . )( 6)},{},
 {( ." Type an 'ZX'" PAD 1 ACCEPT . PAD C@ EMIT)( 1 Z)},{}
},
enddoc)
_HEADER({ACCEPT},{ACCEP},{DOCOL})
        DC      PACCEP
        DC      TSWAP, ROT, MIN
        DC      LDUP, TOR, LMOVE, FROMR
        DC      SEMIS
_C
worddocsafe( {INPUT},{(ACCEPT)},{paren_accept},{ --- sc } ,{},
{Accept characters from the terminal, until a forthkey({ENTER})
is pressed and return the result as a constant string
forthvar({sc}).
The forthkey({ENTER}) is not part of forthvar({sc}).
It is possible that it contains other line endings such as a trailing (0x0D),
which can be disposed off by forthcode({-TRAILING}).
The editing functions are the same as with forthcode({ACCEPT}) .
_VERBOSE_({{This is lighter on the system and sometimes easier
to use than }forthcode({ACCEPT}){.
Text is probably present in the buffer address contained in
}forthcode({TIB @@}){, but not necessarily at the beginning. }})
},
{{KEY},{KEY?},{ACCEPT}},
{
{(ACCEPT) DUP . PAD SWAP CMOVE },{6},
 {GIBBON
PAD 6 TYPE },{GIBBON},
dnl { ." Type an 'A'" (ACCEPT) DUP . TYPE},{1 A)},
dnl {." Type an 'ABCDEF'" DUP . },{6},
},
enddoc)
_HEADER({(ACCEPT)},{PACCEP},{DOCOL})
PACCEP2:
        DC      REMAIND
        DC      TFET
        DC      LIT, ALF, SINDEX
        DC      ZEQU
        _0BRANCH(PACCEP1)
        DC      REMAIND, TFET
        DC      TIB, FETCH
        DC      SWAP, LMOVE
        DC      TIB, FETCH
        DC      REMAIND, CELLP, STOR
        DC      REFTIB
        _BRANCH(PACCEP2)
PACCEP1:
        DC      REMAIND, TFET
        DC      LIT, ALF, SSLAS
        DC      TSWAP, REMAIND, TSTOR
        DC      SEMIS
_C
worddoc( {OPERATINGSYSTEM},{MS},{millisecond},{n ---},{ISO},
{ Wait for forthvar({n}) milliseconds. },
{{KEY?},{MS@@}},
{{ 123 10 MS . },{123}},
enddoc)
_HEADER({MS},{MS},{DOCOL})
        DC      CALLOPEN
        DC      PAR1
        DC      LIT, _Sleep@4, ICALLCLOSE
        DC      DROP
        DC      SEMIS
})_C{}_END_({_DLL_})
_DLL_({
worddoc( {OPERATINGSYSTEM},{CALL[}, {icallopen}, { --- }, {},
{ Reserve 256 bytes to serve as an MS-Windows stack frame
in behalf of calling an externally supplied subroutine.
A pointer to there is stored in forthdefi({PARS}).
The parameters are fille with forthcode({PAR1}) etc. and then a
direct or indirect call is executed
_BITS64_({It takes care that it is aligned at a 16-byte boundary,
which is required for 64-bits.})
It may be closed by either forthcode({ICALL]}) or forthcode({CALL]})
},
{{PAR1},{PAR2},{PAR4},{PARI},{ICALL]},{CALL]} },
{
{ CALL[ DSP@ PARS @ - 0FE 102 WITHIN .}, {_T_}
},
enddoc)

_HEADER({CALL[},{CALLOPEN},{DOCOL})
         DC      SPFET,  LIT, 256, LSUB
_BITS64_({         DC      LIT, -16, LAND},{dnl})
         DC      PARS, STOR
         DC      SEMIS

worddoc( {OPERATINGSYSTEM},{PARS}, {parameters}, { --- }, {},
{ forthdefi({PARS}) is a variable that contains MS-Windows stackpointer
during a system call. },
{{ICALL[},{ICALL]}},
{
dnl { DSP@ ICALL[ DUP DSP@ - 254 258 WITHIN DSP! }, { T }
},
enddoc)

dnl This one is only used in MS-Windows, otherwise it is a wasted cell.
dnl _HEADER({PARS},{PARS},{DOUSE}, _CELLS(38))
_HEADER({PARS},{PARS},{DOVAR}, )
        DC      0

_HEADER({PAR1},{PAR1},{DOCOL})
        DC      PARS, FETCH, STOR
        DC      SEMIS

_HEADER({PAR2},{PAR2},{DOCOL})
        DC      PARS, FETCH, CELLP, STOR
        DC      SEMIS

_HEADER({PAR3},{PAR3},{DOCOL})
        DC      PARS, FETCH, CELLP, CELLP, STOR
        DC      SEMIS

_HEADER({PAR4},{PAR4},{DOCOL})
        DC      PARS, FETCH, CELLP, CELLP, CELLP, STOR
        DC      SEMIS

_HEADER({PAR5},{PAR5},{DOCOL})
        DC      PARS, FETCH, CELLP, CELLP, CELLP, CELLP, STOR
        DC      SEMIS

_HEADER({PARI},{PARI},{DOCOL})
        DC      ONEM, LCELLS, PARS, FETCH, PLUS, STOR
        DC      SEMIS

worddoc( {OPERATINGSYSTEM},{ICALL]}, {indirect_call_close}, { addr --- u }, {},
{ Execute an indirect call to forthvar({addr}).
This is probably an external subroutine, whose addres is filled in
in the header of the executable during start up,
not fetched via forthcode({DLL-ADDRESS}).
It is an indirect call because the external subroutines address is
filled in into the header at startup.
The stack frame at forthdefi({PARS}) must be filled with its parameters.
The call is given PARS as its stack pointer, and immediately there
after the original stack is restored.
The forthvar({u}) is subroutine dependent, to be found in the documentation
of whoever wrote the DLL.
It may be a result or an error condition or an indication that there is
an error to be fetched by forthcode({LAST-ERROR}) .
It was returned into AX.
},
{{OPEN-FILE},{DLL-ADDRESS},{LOAD-DLL},{CALL[},{LAST-ERROR} },
{
{ dnl most OS calls testin fact this interface
}
},
enddoc)
CODE_HEADER({ICALL]},{ICALLCLOSE})

        POP    AX

dnl to become : XCHG SP,   [BP] ; Nieuwe stack.
        XCHG SP,   [PARS+ (CW*(PH_OFFSET)) ] ; Nieuwe stack.

_BITS64_({
        MOV    CX,   [SP+(CW*(0))]
        MOV    DX,   [SP+(CW*(1))]
        MOV    R8,   [SP+(CW*(2))]
        MOV    R9,   [SP+(CW*(3))]
})
        CALL   _CELL_PTR[AX]
        XCHG    SP,   [PARS+ (CW*(PH_OFFSET)) ] ; Nieuwe stack.
        _PUSH

worddoc( {OPERATINGSYSTEM},{CALL]}, {direct_call_close}, { addr --- u }, {},
{ Execute a direct call to forthvar({addr}).
This is probably an external subroutine, supplied via a DLL that is
directly called with an address fetched via forthcode({DLL-ADDRESS}).
The stack frame at forthdefi({PARS}) must be filled with its parameters.
The call is given PARS as its stack pointer, and immediately there
after the original stack is restored.
The forthvar({u}) is subroutine dependent, to be found in the documentation
of whoever wrote the DLL.
It may be a result or an error condition or an indication that there is
an error to be fetched by forthcode({LAST-ERROR}) .
It was returned into AX.
_VERBOSE_({ If the c-convention is used, the caller must nip
results that are under forthvar({status}). })
},
{{OPEN-FILE},{DLL-ADDRESS},{LOAD-DLL},{CALL[},{LAST-ERROR}},
{
{ dnl e.g. GET-EVENT in forth.lab
}
},
enddoc)
CODE_HEADER({CALL]},{CALLCLOSE})

        POP    AX
        XCHG SP,   [PARS+ (CW*(PH_OFFSET)) ] ; Nieuwe stack.

_BITS64_({
        MOV    CX,   [SP+(CW*(0))]
        MOV    DX,   [SP+(CW*(1))]
        MOV    R8,   [SP+(CW*(2))]
        MOV    R9,   [SP+(CW*(3))]
})
        CALL   AX
        XCHG    SP,   [PARS+ (CW*(PH_OFFSET)) ] ; Nieuwe stack.
        _PUSH

_BITS32_({
worddoc( {OPERATINGSYSTEM},{ICALL}, {indirect_call}, { n1*x addr --- ior }, {},
{ Execute an indirect call to forthvar({addr}).
This is probably an external subroutine, supplied via a DLL that is
indirectly linked, not fetched via forthcode({DLL-ADDRESS}) and positioned
in the table at the head of the forthfile({.exe}) file.
This is slightly faster than a forthcode({ICALL[}) forthcode({ICALL]})
that uses a stackframe.
The stack must be filled with its parameters,
those are popped by the external subroutien.
The forthvar({ior}) is a subroutine dependent indication whether
the operation has succeeded.
It is assumed that it was returned into AX.
},
{{OPEN-FILE},{DLL-ADDRESS},{LOAD-DLL},{ICALL]}},
{
{ dnl all OS calls testin fact this interface
}
},
enddoc)
CODE_HEADER({ICALL},{ICALL})
        POP    AX
        CALL   _CELL_PTR[AX]
       _PUSH
_C{}
worddoc( {OPERATINGSYSTEM},{CALL}, {call}, { n1*x addr --- ior }, {},
{ Execute a call to forthvar({addr}).
This is probably an external subroutine, supplied via a DLL-library.
The stack must be filled with its parameters,
This is slightly faster than a forthcode({ICALL[}) forthcode({CALL]})
that uses a stackframe.
the forthvar({ior}) is a subroutine dependent indication whether
the operation has succeeded.
It is assumed that it was returned into AX.
_VERBOSE_({ If the c-convention is used, the caller must nip
results that are under forthvar({ior}). })     },
{{DLL-ADDRESS}},
{
{ ( all OS calls test in fact this interface) },{}
},
enddoc)
CODE_HEADER({CALL},{LCALL})
        POP    AX
        CALL   AX
       _PUSH
_C
})_C{}_END_({ _BITS32_})
})_C{}_END_({_DLL_})
_PC_({
worddoc( {OUTPUT},{ETYPE},{etype},{addr count ---},{},
{This behaves identical to forthcode({TYPE}) .
However it is used for all error message, so via this word
error output can be redirected, by
forthdefi({revectoring}) it.
},
,
dnl This test assumes a redirection of error out to standard out.
{{HERE 41 C, 42 C, 2 ETYPE},{AB}},
enddoc)
_HEADER({ETYPE},{ETYPE},{DOCOL})
        DC      LTYPE
        DC      SEMIS
_C
worddoc( {INPUT},{ACCEPT},{accept},{addr count --- n},{ISO},
{Transfer at most forthvar({count}) characters from the
terminal to address. The transfer takes place when a forthkey({RET}) is received,
and excess characters after forthvar({count}) are ignored.
The backspace key on the standard PC keyboard layout
is used to delete characters, without involvement of Forth, so
changing forthcode({RUBOUT}) has no effect. Other editing keys such as
forthkey({F3}) and cursor keys probably work as usual with a console application.
The number of
characters not including the forthkey({RET}) is returned into
forthvar({n}). },
{{(ACCEPT)},{KEY},{KEY?}},
{
{PAD 10 ACCEPT},{},
 {GIBBON
  . PAD 5 TYPE},{6 GIBBO},
 {( ." Type an 'A'" PAD 2 ACCEPT . PAD C@ EMIT)( 1 A)},{},
 {( ." Type an 'ABCDEF'" PAD 80 ACCEPT . )( 6)},{},
 {( ." Type an 'ZX'" PAD 1 ACCEPT . PAD C@ EMIT)( 1 Z)},{}
},
enddoc)
_HEADER({ACCEPT},{ACCEP},{DOCOL})
        DC      PACCEP
        DC      TSWAP, ROT, MIN
        DC      LDUP, TOR, LMOVE, FROMR
        DC      SEMIS
_C
})_C{}_END_({_PC_})
_CLASSIC_({
_C{ All I/O goes through the 3 assembler functions}
_C{ CI CHO CSTAT. They could be collapsed into the }
_C{ code definitions, but this way they are available}
_C{ to be called from code. And the high level words can be revectored }
worddoc( {OUTPUT},{EMIT},{emit},{c ---},{ISO,FIG},
{Transmit ASCII character forthvar({c}) to the terminal.
All terminal I/O goes through this word. It is high level so terminal
I/O can be redirected, by forthdefi({revectoring}) it.
forthcode({OUT}) is incremented for each character output and reset for
a carriage return.
Note that in this ciforth (``classical FIG'') terminal I/O mainly
uses BDOS, where disk I/O uses the BIOS.
},{{TYPE},{OUT}}, {}, enddoc)
_HEADER({EMIT},{EMIT},{DOCOL})
        DC      PEMIT
        DC      ONE,LOUT
        DC      PSTOR,SEMIS
PEMIT   DC      _AP_ +_CELLS(1)     _C{ Mini header, pointer to code.}
        POP     AX      _C{GET CHAR}
        CMP     AL,ALF   _C{ Precede ^J with ^M}
        JNE     PEMIT1
        MOV     _CELL_PTR[_VAR_FIELD(LOUT)],0x0
        MOV     AL,ACR
        CALL    CHO
        MOV     AL,ALF
        _C{ Bizarre, without the colon MASM reports error.}
PEMIT1: CALL    CHO    _C{CHAR OUTPUT}
        _NEXT
CHO     PROC    NEAR
        PUSH    DX
        PUSH    AX      _C{SAVE CHAR}
        MOV     DL,AL   _C{CHAR TO WRITE}
        MOV     AH,2    _C{CHAR OUT FUNCTION}
        INT     0x21     _C{DOS}
        POP     AX
        POP     DX
        RET
_ENDP CHO     ENDP
_C
worddoc( {INPUT},{KEY},{key},{--- c},{ISO,FIG},
{Leave the ASCII value of the next terminal key struck.},{}, {}, enddoc)
CODE_HEADER({KEY},{KEY})
        CALL    CI      _C{CONSOLE INPUT}
        MOV     AH,0    _C{MAKE 16 BITS}
        _PUSH   _C{SAVE KEY VALUE}
CI      PROC    NEAR
        MOV     AH,0    _C{ READ CHAR FUNCTION}
        INT     0x16
        RET
_ENDP CI      ENDP
_C
worddoc( {INPUT},{KEY?},{key_question},{--- ff},{ISO},
{Perform a test of the terminal keyboard for a break request.
Any key pressed is interpreted as such and the key is not consumed.
A true flag indicates actuation. },
{{KEY},{ACCEPT}}, {}, enddoc)
CODE_HEADER({KEY?},{KEYQ})
        JMP     PQTER
PQTER:  CALL    CSTAT   _C{TEST FOR KEY}
        OR      AL,AL   _C{ANY KEY?}
        JZ      PQTER1  _C{NO}
        MOV     AL,-1    _C{TRUE = CHAR FOUND}
PQTER1: MOV     AH,0    _C{MAKE 16 BITS}
        _PUSH   _C{SAVE STATUS}
_C
CSTAT   PROC    NEAR
        PUSH    DX
        MOV     DX,0x0FF
        MOV     AX,0x0600
        INT     0x21
        POP     DX
STATRT: RET
_ENDP CSTAT   ENDP
_C
worddoc( {OUTPUT},{TYPE},{type},{addr count ---},{ISO,FIG},
{Transmit forthvar({count}) characters from forthvar({addr}) to the
terminal.
In this ciforth all terminal I/O goes through forthcode({EMIT}), so
forthcode({OUT}) is observed.},{{EMIT},{OUT}}, {}, enddoc)
_HEADER({TYPE},{LTYPE},{DOCOL})
        DC      OVER
        DC      PLUS
        DC      SWAP
        _QDO(TYPE4)
TYPE2:  DC      IDO
        DC      CFET
        DC      EMIT
        _LOOP(TYPE2)    _C{ LOOP}
TYPE4:
        DC      SEMIS
_C
})_C{}_END_({_CLASSIC_})
_USEBIOS_({
worddocsafe( {OUTPUT},{(EMIT)},{paren_emit},{c ---},{},
{Just transmit ASCII character forthvar({c}) to the terminal
by a BIOS call.
},{{EMIT}}, {}, enddoc)
_HEADER({(EMIT)},{PEMIT},{DOCOL})
        DC      LIT, 0x0E00, PLUS, X, X, X
        DC      LIT, 0x0010, BIOSO
        DC      TDROP, TDROP, DROP    _C{Ignore errors.}
        DC      SEMIS
_C
worddoc( {OUTPUT},{EMIT},{emit},{c ---},{ISO,FIG},
{Transmit ASCII character forthvar({c}) to the terminal.
All terminal I/O goes through this word. It is high level so terminal
I/O can be redirected, by forthdefi({revectoring}) it.
forthcode({OUT}) is incremented for each character output and reset for
a carriage return.
},{{TYPE},{OUT}}, {}, enddoc)
_HEADER({EMIT},{EMIT},{DOCOL})
             DC      ONE,LOUT,PSTOR
             DC      LIT, 0x07F, LAND
             DC      LDUP,LIT,ALF,EQUAL
             _0BRANCH(EMIT1)
             DC      LIT,ACR,PEMIT
             DC      ZERO,LOUT,STOR
EMIT1:       DC      PEMIT
             DC      SEMIS
_C
worddoc( {INPUT},{KEY},{key},{--- c},{ISO,FIG},
{Leave the ASCII value of the next terminal key struck.},{}, {}, enddoc)
_HEADER({KEY},{KEY},{DOCOL})
        DC      LIT, 0x1000, X, X, X
        DC      LIT, 0x0016, BIOSO
        DC      TDROP, TDROP
        DC      LIT, 0x00FF, LAND
        DC      SEMIS
_C
worddoc( {INPUT},{KEY?},{key_question},{--- ff},{ISO},
{Perform a test of the terminal keyboard for a break request.
Any key pressed is interpreted as such and the key is not consumed.
A true flag indicates actuation. },
{{KEY},{ACCEPT}}, {}, enddoc)
_HEADER({KEY?},{KEYQ},{DOCOL})
             DC      LIT, 0x01100, ZERO, ZERO, ZERO
             DC      LIT, 0x016, BIOSO
             DC      LIT, 0x040, LAND, ZEQU, TOR
             DC      DROP, DROP, DROP, DROP
             DC      FROMR, SEMIS
_C
worddoc( {OUTPUT},{POUT)},{p_out},{c ---},{},
{Just transmit ASCII character forthvar({c}) to the printer
by a BIOS call. forthcode({OUT}) is not observed.
},{{EMIT}}, {}, enddoc)
_HEADER({POUT},{POUT},{DOCOL})
        DC      X, X, X
        DC      LIT, 0x0017, BIOSO
        DC      DROP, TDROP, TDROP           _C{Ignore errors.}
        DC      SEMIS
_C
worddoc( {OUTPUT},{TYPE},{type},{addr count ---},{ISO,FIG},
{Transmit count characters from forthvar({addr}) to the output device.
forthcode({OUT}) is incremented for each character output.
In this ciforth all terminal I/O goes through forthcode({EMIT}), so
forthcode({OUT}) is observed.
},{{EMIT},{OUT}}, {}, enddoc)
_HEADER({TYPE},{LTYPE},{DOCOL})
        DC      OVER
        DC      PLUS
        DC      SWAP
        _QDO(TYPE4)
TYPE2:  DC      IDO
        DC      CFET
        DC      EMIT
        _LOOP(TYPE2)    _C{ LOOP}
TYPE4:
        DC      SEMIS
_C
})_C{}_END_({_USEBIOS_})
_KEY_BY_KEY_({
worddocsafe( {INPUT},{(ACCEPT)},{paren_accept},{ --- sc } ,{},
{Input a line
until a forthkey({RET)}) from the input terminal, and leave it as
a forthdefin({string constant}). It doesn't contain a trailing forthkey({LF}).
But possibly a trailing forthkey({RET}) (0x0D).
_VERBOSE_({{This is lighter on the system and sometimes easier
to use than }forthcode({ACCEPT}){
Text is probably present in the buffer address contained in
}forthcode({TIB @@}){, but not necessarily at the beginning. }})
Editing is done locally observing forthcode({RUBOUT}) .
},
{{ACCEPT},{EVALUATE}},
{{." interactive"},{interactive}},
enddoc)
_HEADER({(ACCEPT)},{PACCEP},{DOCOL})
        DC      TIB
        DC      FETCH
        DC      LIT,TIBSIZE
        DC      TDUP
_C{  Old fig code of EXPECT :}
             DC      OVER
             DC      PLUS
             DC      OVER
             _DO(EXPE8)
EXPE1:       DC      KEY
             DC      LDUP
             DC      RUBOUT
             DC      FETCH
             DC      EQUAL
             _0BRANCH(EXPE2) _C{ IF                    }
             DC      DROP
             DC      LDUP
             DC      IDO
             DC      EQUAL
             DC      LDUP
             DC      FROMR
             DC      TWO     _C{ Remove last 2 chars }
             DC      LSUB
             DC      PLUS
             DC      TOR
             _0BRANCH(EXPE6) _C{ IF                    }
             DC      LIT
             DC      BELL
             _BRANCH(EXPE7)  _C{ ELSE                  }
EXPE6:       DC      LIT
             DC      BSOUT   _C{ THEN                 }
EXPE7:       _BRANCH(EXPE3)  _C{ ELSE                  }
EXPE2:       DC      LDUP
             DC      LIT,0x0D
             DC      EQUAL
             _0BRANCH(EXPE4) _C{ IF}
             _C{ Emulate old fashioned LEAVE.}
             DC      FROMR, RDROP, LDUP, TOR, TOR
             DC      DROP
             DC      LBL
             DC      ZERO
             _BRANCH(EXPE5)  _C{ ELSE}
EXPE4:       DC      LDUP    _C{ THEN}
EXPE5:       DC      IDO
             DC      CSTOR
             DC      ZERO
             DC      IDO
             DC      ONEP
             DC      STOR   _C{ THEN}
EXPE3:       DC      EMIT
             _LOOP(EXPE1)    _C{ LOOP}
EXPE8:
             DC      DROP
_C{        END      EXPEC}
        DC      ZERO, SINDEX
        DC      TIB, FETCH, SWAP, OVER, LSUB
        DC      SEMIS
_C
})_C{}_END_({_KEY_BY_KEY_})

        PAGE
_C{------------------------------------}
_C{       SYSTEM DEPENDANT DISK I/O}
_C{------------------------------------}
worddoc( {BLOCKS},{DISK-ERROR},{disk_error},{--- addr},{},
{_PC_({
{Leave the address} forthvar({addr}) {of a variable containing
information about the latest disk error in opening, using or
closing the block file.
One means an
error and and zero means okay.}
_VERBOSE_({{Beware that if error messages are loaded from disk,
this may clear }forthcode({DISK-ERROR}){.}})})
dnl _HOSTED_X_({ This is just a flag, indicating there was an error. })
_HOSTED_X_({{This variable is not used in thisforth, errors are thrown.}})
},
{{BLOCK}},
{{." See BLOCK-EXIT"},{See BLOCK-EXIT}},
enddoc)
_HEADER({DISK-ERROR},{DERR},{DOVAR}, )
        DC      -1
_C
_BLOCKSINFILE_({
worddoc( {BLOCKS},{BLOCK-FILE},{block_file},{---addr},{},
{Leave the address forthvar({addr}) of a counted string,
the name of a forthdefi({library file}) in
which forthdefi({blocks}) are (to be) allocated.
The name may contain a path and be at most}
M4_FILENAMELENGTH {characters long.
The default name is forthemph({forth.lab}) .
This name is typically changed during installation and is used by the
 forthcode({BLOCK-INIT}) command.
},{{BLOCK-HANDLE},{BLOCK-INIT},{LIST},{LOAD},{$@@}},
{{BLOCK-FILE $@ TYPE},{forth.lab}},
enddoc)
_HEADER({BLOCK-FILE},{BLFL},{DOVAR}, )
        _STRING({forth.lab})
        _RESB(M4_FILENAMELENGTH-9)               _C{ Allow for some path}
worddoc( {BLOCKS},{BLOCK-HANDLE},{block_handle},{---n},{},
{Leave a file handle in forthvar({n}) .
If it is negative there is no block file open,
otherwise the handle is used by the system to access blocks.
_LINUX_C_({In this ciforth forthcode({BLOCK-HANDLE}) is not used.})
},{{BLOCK-FILE},{BLOCK-INIT},{BLOCK-EXIT}},
_DLL_({
{{BLOCK-HANDLE @ DUP 0 > . 1000 < .},{_T_ _T_}},
},{
{{BLOCK-HANDLE @ 10 U< .},{_T_}},
})
enddoc)
_HEADER({BLOCK-HANDLE},{BHAN},{DOVAR}, )
        DC      -1
_C
worddoc( {BLOCKS},{?DISK-ERROR},{disk_error_},{n---},{},
{Interpret forthvar({n}) as the status of a disk i/o call and
forthdefi({signal an error}) if it contains an error condition.
It is only used to signal errors related to accessing the
forthcode({BLOCK-FILE}).
},{{BLOCK-FILE},{BLOCK-HANDLE},{BLOCK-INIT},{BLOCK-EXIT}}, {}, enddoc)
_HEADER({?DISK-ERROR},{QDSKER},{DOCOL})
        DC      LIT, 8, QERR
        DC      SEMIS
_C
})_C{}_END_({_BLOCKSINFILE_})
_BLOCKSBYFILEWS_({
worddoc( {BLOCKS},{BLOCK-INIT},{block_init},{n ---},{},
{Map the blocks on the block file forthcode({BLOCK-FILE}),
i.e. the mass storage words refer
to the blocks in this file. The handle
forthsamp({BLOCK-HANDLE}) can be used
to access it, with access code forthvar({n})
_VERBOSE_({{(2 for read and write)}}).
This command signals failure by a negative handle in forthcode({BLOCK-HANDLE}).
You must activate mnemonic error messages explicitly
by setting forthcode({WARNING}).
},
{{BLOCK},{LIST},{LOAD},{BLOCK-EXIT},{OPEN-FILE}},
{{." Via MESSAGE"},{Via MESSAGE}},
enddoc)
_HEADER({BLOCK-INIT},{BLINI},{DOCOL})
        DC      BLFL, SFET
        DC      ROT
        DC      OFILE
        DC      ZEQU, NEGATE  _C{ 0 if disk problems, 1 if not.}
        DC      LWARN, FETCH, MIN _C{ AND but WARNING is 0/1.}
        DC      LWARN, STOR
        DC      BHAN, STOR
        DC      MTBUF
        DC      SEMIS
_C
worddoc( {BLOCKS},{BLOCK-EXIT},{block_exit},{---},{},
{A block file must have been opened by forthcode({BLOCK-INIT}) .
All blocks are unlocked.
Any changed blocks are written back to mass storage.
Close the currently open block file forthcode({BLOCK-HANDLE}),
such that the mass storage words no longer work, and will result in
error messages.
If error messages were fetched from disk, they
no longer are.},
{{BLOCK},{LIST},{LOAD},{DISK-ERROR},{WARNING}},
{
{EMPTY-BUFFERS BLOCK-EXIT},{},
{0 WARNING ! EMPTY-BUFFERS 1 BLOCK},
 {PTY-BUFFERS 1 BLOCK ? ciforth ERROR # 8},
{ CR DISK-ERROR @ 0 < . 1 WARNING ! 2 BLOCK-INIT},{_T_},
{1 0 (LINE) TYPE}, { LICENSE }
},
enddoc)
_HEADER({BLOCK-EXIT},{BLEXI},{DOCOL})
        DC      FLUSH
        DC      BHAN, FETCH
        DC      CFILE
        DC      ZERO, LWARN, STOR
        DC      LIT, -1, BHAN, STOR    _C{Regardless of close errors.}
        DC      QDSKER
        DC      SEMIS
_C
worddoc( {BLOCKS~},{BLOCK-SEEK},{block_seek},{n---},{},
{A block file must have been opened by forthcode({BLOCK-INIT}) .
Position the file pointer at block forthvar({n})
in behalf of subsequent reads and writes.
},{{BLOCK},{LIST},{LOAD},{BLOCK-READ},{BLOCK-WRITE}}, {}, enddoc)
_HEADER({BLSEEK},{BLSEEK},{DOCOL})
        DC      BBUF
        DC      USTAR
        DC      BHAN, FETCH
        DC      PFILE           _C{ Disk position.}
        DC      QDSKER
        DC      SEMIS
_C
worddoc( {BLOCKS},{BLOCK-READ},{block_read},{addr blk ---},{},
{The ciforth primitive for reading of blocks. forthvar({addr})
specifies the destination block buffer, forthvar({blk}) is
the sequential number of the referenced physical block
forthcode({BLOCK-READ}) determines the location on mass storage,
performs the read and throws an exception on errors.},
{{BLOCK},{DISK-ERROR},{BLOCK-WRITE},{BLOCK-INIT}},
dnl we can use block 2 for scratch, -b is not an option in use.
{
{PAD B/BUF 41 FILL PAD 2 BLOCK-WRITE},{},
{PAD B/BUF 45 FILL PAD 2 BLOCK-READ},{},
{PAD 23 + 5 TYPE},{AAAAA},
},
enddoc)
_HEADER({BLOCK-READ},{BLREAD},{DOCOL})
        DC      BLSEEK _C{ That's done}
        DC      BBUF
        DC      BHAN, FETCH
        DC      RFILE           _C{ Disk read }
        DC      SWAP, BBUF, UNEQ
        DC      LOR, QDSKER
        DC      SEMIS
_C
worddoc( {BLOCKS},{BLOCK-WRITE},{block_write},{addr blk ---},{},
{The ciforth primitive for writing of blocks. forthvar({addr})
specifies the source or destination block buffer, forthvar({blk}) is
the sequential number of the referenced physical block.
forthcode({BLOCK-WRITE}) determines the location on mass storage,
performs the write and throws an exception on errors.},
{{BLOCK},{DISK-ERROR},{BLOCK-READ},{BLOCK-INIT}},
{
dnl see BLOCK-READ
},
enddoc)
_HEADER({BLOCK-WRITE},{BLWRITE},{DOCOL})
        DC      BLSEEK _C{ That's done}
        DC      BBUF
        DC      BHAN, FETCH
        DC      WFILE           _C{ Disk write}
        DC      QDSKER
        DC      SEMIS
_C
})_C{}_END_({_BLOCKSBYFILEWS_})
worddoc( {OPERATINGSYSTEM},{SHELL},{shell},{---addr},{},
{Leave the address forthvar({addr}) of a string variable,
the name of a file that contains the command interpreter,
or shell.
This name may be changed and is used by the
 forthcode({SYSTEM}) command.
The name may contain a path and be at most}
M4_FILENAMELENGTH {characters long.
_HOSTED_LINUX_({ The default name is forthemph({/bin/sh}) .})
_PC_({ The default name is forthemph({C:\COMMAND.COM}) .
256 bytes after forthcode({SHELL}) are reserved for
a start up stack.})
},{{SYSTEM},{$@@}},
,
enddoc)
_HEADER({SHELL},{SHELL},{DOVAR}, )
         _HOSTED_X_( {_STRING({/bin/sh})})
        _DLL_( {_STRING({C:\windows\system32\cmd.exe})})
        _PC_( {_STRING({C:\COMMAND.COM})})
        _ALIGN(_CELLS(1))
        _RESB(M4_FILENAMELENGTH)_C{ Allow for some path}  
_PC_({  _RESB(0x100)     _C{ Double serve as stack at start up. }})
_C
_HOSTED_OSX_({
worddoc( {OPERATINGSYSTEM},{XOSFORK},{xosfork},{ --- flag},{},
{Fork the process. If it is negative, it is an error.
Otherwise, if forthvar({flag}) is clear, we are the child else the
mother.}, {{SYSTEM}}, {}, enddoc )
CODE_HEADER({XOSFORK},{XOSFORK})
_C{ This is coded in assembler because there is a return value in DX :}
_C{ 0 = parent 1 = child }
        MOV     EAX, fork  _C{ Syscall with no parameters}
        PUSH EAX
        INT     0x80
        ADD     ESP, 4

        NEG EDX
        NOT     EDX     _C{ TRUE: parent  FALSE: child }
        AND EAX, EDX    _C{ parent: like classic fork }
                        _C{ child: always zero }
        _PUSH
})_C{}_END_({_HOSTED_OSX_})
worddoc( {OPERATINGSYSTEM},{SYSTEM},{system},{sc ---},{ISO},
{Have the operating system execute the command contained
in the string forthvar({sc}).
_MODERN_({{The environment is passed to the
command, but not the changes made after ciforth started.}})
},{{?ERRUR},{SHELL}},
_LINUX_N_({ {{"cat hello.frt" SYSTEM 2000 MS},{"Hello world!" TYPE}} })
dnl Redirection can not be reliably tested on Windows XP
dnl _MODERN_({ {{"TYPE hello.frt" SYSTEM },{"Hello world!" TYPE}} })
_DLL_({
{ dnl these test must be unconditional, in separate worddoc headers
{ 1 LOAD  "GET-ENV" WANTED },{},
{ "COMSPEC" GET-ENV SHELL $!},{},
dnl Output would come at the end of file, fails under wine.
dnl{"wina.exe -f 23 EXIT-CODE ! BYE >null:" SYSTEM ( No error!)}, { }
{"REM NO OUTPUT" SYSTEM },{}
dnl{"" SYSTEM },{}
} dnl these test must be unconditional, in separate worddoc headers
})
,enddoc)
_LINUX_N_({
_HEADER({SYSTEM},{SYSTEM},{DOCOL})
        DC      LIT, COMBUF, SSTOR, ZERO, LIT, COMBUF, CHAPP
        DC      ZERO, SHELL, CHAPP, LIT, -1, SHELL, PSTOR
        DC      X, X, X, LIT, fork, XOS
        DC      LDUP, QERRUR
        DC      LDUP, ZEQU
        _0BRANCH(SYSTEM1)
        DC      SHELL, CELLP, LIT, SYSARGS
_C{  Get environment vector}
_BITS32_({      DC      ARGS, FETCH, SFET, ONEP, LCELLS, PLUS},{dnl})
_BITS64_({      DC      ARGS, FETCH, SFET, ONEP, LCELLS, PLUS},{dnl})
        DC      LIT, execve, XOS
        DC      LIT, 49, LERROR, BYE   _C{ Returned, this is always wrong.}
SYSTEM1:
        DC      LDUP
        DC      LIT, STATUS, ZERO, LIT, waitpid, XOS
        DC      LDUP
        DC      LIT, EINTR, EQUAL
        _BRANCH(SYSTEM2)
        DC      DROP
        _0BRANCH(SYSTEM1)
SYSTEM2:
        DC      QERRUR
        DC      TDROP
        DC      SEMIS
_C
        _ALIGN(_CELLS(1))
STATUS:  DC     0
SYSARG2: DSS     "-c"
         DB      0
        _ALIGN(_CELLS(1))
COMBUF:  _RESB(CW+256)  _C{One cell for high level string manipulation.}
        _ALIGN(_CELLS(1))
SYSARGS:DC   _VAR_FIELD(SHELL)+CW, SYSARG2, COMBUF + CW, 0
_C
})_C{}_END_({_LINUX_N_})
_HOSTED_OSX_({
_HEADER({SYSTEM},{SYSTEM},{DOCOL})
        DC      LIT, COMBUF, SSTOR, ZERO, LIT, COMBUF, CHAPP
        DC      ZERO, SHELL, CHAPP, LIT, -1, SHELL, PSTOR
        DD      XOSFORK
        DC      LDUP, QERRUR
        DC      LDUP, ZEQU
        _0BRANCH(SYSTEM1)
_C{  Get environment vector}
        DD      ARGS, FETCH, SFET, ONEP, LCELLS, PLUS
                DD      LIT, SYSARGS
                DD      SHELL, CELLP
                DD      LIT, 3
        DD      LIT, execve, XOSV
        DC      LIT, 49, LERROR, BYE   _C{ Returned, this is always wrong.}
SYSTEM1:
        DC      LDUP

        DD      ZERO ; struct rusage *rusage
        DD      ZERO, ; options
        DD      ROT
        DD      LIT, STATUS ; status
        DD      SWAP  ; pid on top
        DD      LIT, 4
        DD      LIT, waitpid  ; wait4 (OSX)
        DD      XOSV

        DC      LDUP
        DC      LIT, EINTR, EQUAL
        _BRANCH(SYSTEM2)
        DC      DROP
        _0BRANCH(SYSTEM1)
SYSTEM2:
        DC      QERRUR
        DC      TDROP
        DC      SEMIS
_C
        _ALIGN(_CELLS(1))
STATUS:  DC     0
SYSARG2: DSS     "-c"
         DB      0
        _ALIGN(_CELLS(1))
COMBUF:  _RESB(CW+256)  _C{One cell for high level string manipulation.}
        _ALIGN(_CELLS(1))
        _C{ These are longs, not cells! }
SYSARGS: DD   _VAR_FIELD(SHELL)+CW, SYSARG2, COMBUF + CW, 0
_C
})_C{}_END_({_HOSTED_OSX_})
_MODERN_({
_HEADER({SYSTEM},{SYSTEM},{DOCOL})
        DC      LIT, COMBUF, TOR
        DC      ZERO, SHELL, CHAPP, LIT, -1, SHELL, PSTOR
        _STRINGINLINE({X /c })  _C{byte X contains string count.}
        DC      RR, SSTOR
        DC      RR, SADD, LIT, ACR, RR, CHAPP
        DC      RR, FETCH, LIT, 2, LSUB _C{Count, minus X minus CR}
        DC      FROMR, CELLP, CSTOR _C{Fill in (BD) count at X.}
_HOSTED_DPMI_(
{       DC      ZERO, LIT, COMBUF + CW
        DC      LIT, Save_DS_PR, FETCH, OVER
        DC      LIT, 256
        DC      FMOVE
        DC      ZERO, LIT, SHELL + CW
        DC      LIT, Save_DS_PR, FETCH, OVER
        DC      LIT, M4_FILENAMELENGTH
        DC      FMOVE                         }) _END_({_HOSTED_DPMI_})
        DC      SHELL, CELLP, X, LIT, LOADEXEC
        DC      LIT, 0x4B00, BDOSN
        DC      SWAP, QERR
        DC      SEMIS
LOADEXEC:   DW  0       _C{ The 0 are filled in at boot with DS.}
        DW      COMBUF + CW  _C{Allow it to be a counted string.}
        DW      0
        DW      0x6C
        DW      0
        DW      0x7C
        DW      0
COMBUF:  _RESB(CW+256)  _C{One cell for high level string manipulation.}
})_C{}_END_({_MODERN_})
_DLL_({
_HEADER({SYSTEM},{SYSTEM},{DOCOL})
        DC      LIT, COMBUF, TOR
        DC      SHELL, SFET, RR, SSTOR
        _STRINGINLINE({ /c })  _C{byte X contains string count.}
        DC      RR, SADD, RR, SADD
        DC      ZERO, RR, CHAPP

        DC      CALLOPEN
        DC      LIT, -2000H, PARS, PSTOR
        DC      PARS, FETCH
        DC      LDUP, LIT, 02000H+_CELLS(10), LERASE
        DC      LDUP, LIT, 01000H, PLUS, LIT, 10, PARI _C{ Limbo, 1}
        DC      LIT, _CELLS(10), PLUS, LIT, 9, PARI _C{ Limbo, 2}
        DC      FROMR, CELLP, PAR2    _C{ Zero ended command.}
        DC      LIT, _CreateProcessA@40, ICALLCLOSE
        DC      ZEQU, TOERR, THROW
        DC      SEMIS
COMBUF:  _RESB(CW+0x1000)  _C{One cell for high level string manipulation.}
})_C{}_END_({_DLL_})
_LINUX_C_({
worddoc( {BLOCKS},{BLOCK-INIT},{block_init},{n ---},{},
{Map the blocks on the block file forthcode({BLOCK-FILE}),
i.e. the mass storage words refer
to the blocks in this file, with access code forthvar({n}) .
The handle to use it is
hidden in the c-code. forthcode({DISK-ERROR}) reflects whether the mapping was
successful. Reinstall forthcode({WARNING}) as appropriate!
_VERBOSE_({{
This word is executed by c-code outside of Forth.
This handling from c is problematic,
because }forthcode({WARNING}){ no longer is maintained properly.
We could import it to C , but there is no end to that.}})
},{{BLOCK},{LIST},{LOAD},{BLOCK-EXIT},{DISK-ERROR}}, {}, enddoc)
CODE_HEADER({BLOCK-INIT},{BLINI})
        POP     CX
        MOV     AX,[_VAR_FIELD(BLFL)]
        MOV     BX,_VAR_FIELD(BLFL)+CW
        PUSH    BX
        PUSH    AX
        PUSH    CX
        CALL    c_block_init
        MOV     [_VAR_FIELD(DERR)],AX
        LEA     ESP,[ESP+_CELLS(3)]    _C{ remove input}
        _NEXT
_C
worddoc( {BLOCKS},{BLOCK-EXIT},{block_exit},{---},{},
{A block file must have been opened by forthcode({BLOCK-INIT}) .
Close the currently open block file,
i.e. the mass storage words no longer work, and will result in
errors. Reinstall forthcode({WARNING}) as appropriate!
_VERBOSE_({{
This word is executed by c-code outside of Forth.
This handling from c is problematic,
because }forthcode({WARNING}){ no longer is maintained properly.
We could import it to C , but there is no end to that.}})
},{{BLOCK},{LIST},{LOAD},{DISK-ERROR}}, {}, enddoc)
CODE_HEADER({BLOCK-EXIT},{BLEXI})
        CALL    c_block_exit
        _NEXT
_C
worddoc( {BLOCKS},{R|W},{read_slash_write},{addr blk n ---},{FIG},
{The ciforth primitive for read-write of blocks. forthvar({addr})
specifies the source or destination block buffer, forthvar({blk}) is
the sequential number of the referenced physical block; and
forthvar({n}) is a control variable
for forthvar({n})=0 write and forthvar({n})=l
read. forthcode({R|W}) determines the location on mass storage,
performs the read or write and shows errors via forthcode({DISK-ERROR}).},
{{BLOCK}}, {}, enddoc)
_C{      ( ADDR  BLK#  FLAG (0=W, 1=R)}
CODE_HEADER({R|W},{RSLW})
        CALL c_rslw
        MOV     [_VAR_FIELD(DERR)],AX
        LEA     ESP,[ESP+_CELLS(3)]    _C{ remove input}
        _NEXT


})_C{}_END_({_LINUX_C_})
_RWSECTRK_({
worddoc( {BLOCKS},{DRIVE},{drive},{--- addr},{},
{Leave the address forthvar({addr}) of a character buffer,
containing the
drive used for mass storage, the number of sectors in a
track, and the number of heads.
The drive
 is in MSDOS coding,
0 is floppy A: , 1 is floppy B:, 0x80 is drive C:,
0x81 is drive D: and so forth.
These parameters
may be switched but this should only be
attempted after forthcode({EMPTY-BUFFERS}) .
_VERBOSE_({{These are manipulated in rare cases where an
other disk is to be accessed, such as installing a bootable
system on hard disk from floppy.}})},
{{BLOCK},{FLUSH}}, {}, enddoc)
_HEADER({DRIVE},{LDRIVE},{DOVAR}, )
_BOOTSECTRK_({_C{During booting replaced by copy from boot sector.}})
LFDRIVE DB      DRIVE                   _C{ To be used by Forth.}
LFSPT   DB      SPT
LFHEADS DB      HEADS
        _ALIGNED_({_ALIGN(4)})
_C
})_C{}_END_({ _RWSECTRK_})
_CLASSIC_({
_C{ This the mass storage I/O that looks most like FIG.}
_C{ It may not be pretty but it surely is the smallest.}
_C
_C
worddoc( {BLOCKS},{DRIVE},{drive},{--- addr},{},
{Leave the address forthvar({addr}) of a variable containing the
drive used for mass storage. This is in MSDOS coding,
0 is floppy A: , 1 is floppy B:, 0x80 is drive C:,
0x81 is drive D: and so forth.
The drive may be switched but this should only be
attempted after forthcode({EMPTY-BUFFERS}) .},
{{BLOCK},{FLUSH}}, {}, enddoc)
_HEADER({DRIVE},{LDRIVE},{DOVAR}, )
      DC  DRIVE
_C
WERR    DB      'DISK WRITE ERROR  $'
RERR    DB      'DISK READ ERROR   $'
_C
SBLK    PROC    NEAR
_C{      ( ADDR  BLK# -- )}
_C{      THIS ROUTINE WILL PREPARE PARAMETERS FOR DISK I/O}
_C{       DRIVE, ADDRESS, LENGTH, SEC#}
        POP     DI      _C{SAVE RETURN}
        POP     AX      _C{BLK #}
        MOV     CX,SPB
        MUL     CX   _C{SEC #}
        MOV     DX,AX
        MOV     AL,[_VAR_FIELD(LDRIVE)]    _C{SELECT DR A}
        POP     BX      _C{TRANSFER ADDR}
        PUSH    DI      _C{GET THAT RETURN BACK}
        RET
_ENDP SBLK    ENDP
_C
worddoc( {BLOCKS},{BLOCK-READ},{block_read},{addr blk ---},{},
{forthsamp({1 R|W}) is an abbreviation for forthsamp({BLOCK-READ}).
},{{R|W}}, {}, enddoc)
CODE_HEADER({BLOCK-READ},{BLREAD})
        CALL    SBLK
        PUSH    HIP      _C{PRESERVE INTERPRETER POINTER}
        PUSH    RPO      _C{RETURN POINTER}
        INT     0x25
        JNC     DOK     _C{NO ERRORS}
        LEA     DX,[RERR]
        JMP     RWERR
_C
worddoc( {BLOCKS},{BLOCK-WRITE},{block_write},{addr blk ---},{},
{forthsamp({0 R|W}) is an abbreviation for forthsamp({BLOCK-WRITE}).
},{{R|W}}, {}, enddoc)
CODE_HEADER({BLOCK-WRITE},{BLWRITE})
        CALL    SBLK
        PUSH    HIP
        PUSH    RPO
        INT     0x26
        JNC     DOK
        LEA     DX,[WERR]
_C
_C{ Error exit for both BLOCK-READ and BLOCK-WRITE }
RWERR:   PUSH    AX      _C{ DX contains message.}
        MOV     AH,9    _C{String write function, obsolete for ages}
        INT     0x21
        POP     AX      _C{ERROR CODE IN AX}
_C
_C{ Okay exit for both BLOCK-READ and BLOCK-WRITE }
DOK:    POPF            _C{POP FLAGS}
        POP     RPO      _C{RETURN STACK}
        POP     HIP      _C{INTERPRETER PNTR}
        _NEXT
_C
worddoc( {BLOCKS},{R|W},{read_slash_write},{addr blk n ---},{},
{The basic mass storage read-write linkage. (Already present in
figforth.) forthvar({addr}) specifies the source or destination
block buffer, forthvar({blk}) is the sequential number of the
referenced physical block; and forthvar({n}) is a control variable
for
forthvar({n})=0 write and forthvar({n})=l read.
forthcode({R|W}) determines the location on mass storage,
performs the read-write. This version of ciforth features the
most classic mass storage. Blocks are counted sequentially from
0 on the drive with MSDOS code in forthcode({DRIVE}), so
forthcode({R|W}) can be used to write boot code. Errors are
handled by writing directly to the console after they are
detected. },
{{BLOCK},{DRIVE}}, {}, enddoc)
_C{      ( ADDR  OFFSET+BLK#  FLAG (0=W, 1=R) --- )}
_HEADER({R|W},{RSLW},{DOCOL})
         _SWITCH_({DC   ROT, LIT, M4_SWITCHOFFSET, PLUS, ROT, ROT})
        _0BRANCH(RSLW1)
        DC      BLREAD
        _BRANCH(RSLW2)
RSLW1:  DC      BLWRITE
RSLW2:  DC      SEMIS
})_C{}_END_({_CLASSIC_})
_USEBIOS_({
_C
worddoc( {BLOCKS},{SEC/BLK},{sectors_per_block},{--- c},{},
{This constant leaves the number of sectors per block. _VERBOSE_(
The original idea was that a sector forthemph({is}) a block. In
fact SEC/BLK is set such that B/SRC is one, as is required for ISO.)
},{{BLOCK},{B/BUF}}, {}, enddoc)
_HEADER({SEC/BLK},{SPBLK},{DOCON}, SPB)
_C
})_C{}_END_({_USEBIOS_})
_C
_RWSECTRK_({
worddoc( {BLOCKS},{SEC-RW},{sector_read_write},{com addr sec ---},{},
{Performs the BIOS function forthvar({com}) , for
a single sector
forthvar({sec}) either a read to forthvar({addr}) or write from
forthvar({addr}) .
Disk errors are stored in
forthcode({DISK-ERROR}).},
{{BLOCK},{BLOCK-READ},{BLOCK-WRITE}}, {}, enddoc)
_HEADER({SEC-RW},{SECRW},{DOCOL})
        DC      LIT, LFSPT, CFET, SLMOD
        DC      LIT, LFHEADS, CFET, SLMOD   _C{ Now #sec, #head, #cyl}
        DC      TOR
        DC      RR, LIT, 8, RSHIFT, LIT, 6, LSHIFT _C{ Bit 8, 9 of cyl}
        DC      ROT, ONEP, LOR         _C{ Compose and in place.}
        DC      FROMR, LIT, 8, LSHIFT     _C{Bits 0..7 of #cyl.}
        DC      LOR   _C{ High, low -- reg CX. }
        DC      SWAP
        DC      LIT, 8, LSHIFT
        DC      LIT, LFDRIVE, CFET
        DC      LOR   _C{ High, low -- reg DX. }
        DC      LIT, 0x13, BIOSO
        DC      ONE, LAND, DERR, PSTOR
        DC      TDROP, TDROP
        DC      SEMIS
_C
worddoc( {BLOCKS},{BLOCK-READ},{block_read},{addr blk ---},{},
{The ciforth primitive for reading of blocks. forthvar({addr})
specifies the destination block buffer, forthvar({blk}) is
the sequential number of the referenced physical block
forthcode({BLOCK-READ}) determines the location on mass storage,
performs the read and throws an exception on errors.
forthcode({DISK-ERROR}) contains an error count for the latest operation.
},
{{BLOCK},{DISK-ERROR},{SEC-RW}}, {}, enddoc)
_C{      ( ADDR  OFFSET+BLK#  FLAG (0=W, 1=R) --- )}
_HEADER({BLOCK-READ},{BLREAD},{DOCOL})
         _SWITCH_({DC   SWAP, LIT, M4_SWITCHOFFSET, PLUS, SWAP})
        DC      ZERO, DERR, STOR
        DC      LIT, 0x0201      _C{ Read (AH) one (AL) sector }
        DC      SWAP
        DC      SPBLK,  STAR
        DC      SPBLK,  OVER, PLUS
        _DO(BLREAD9)
BLREAD0:
        DC      TDUP
        DC      IDO
        DC      SECRW
        DC      LIT, BPS, PLUS
        _LOOP(BLREAD0)
BLREAD9:
        DC      TDROP
        DC      DERR, FETCH
        _0BRANCH(BLREAD5)              _C{OK}
        DC      ZERO,   _PREV,   FETCH,     STOR   _C{This buffer is no good!}
        DC      LIT,    8, LERROR _C{Read error}
BLREAD5:  DC      SEMIS
_C
worddoc( {BLOCKS},{BLOCK-WRITE},{block_write},{addr blk ---},{},
{The ciforth primitive for writing of blocks. forthvar({addr})
specifies the source or destination block buffer, forthvar({blk}) is
the sequential number of the referenced physical block.
forthcode({BLOCK-WRITE}) determines the location on mass storage,
performs the write and throws an exception on errors.
forthcode({DISK-ERROR}) contains an error for the latest operation.
},
{{BLOCK},{DISK-ERROR},{SEC-RW}}, {}, enddoc)
_C{      ( ADDR  OFFSET+BLK#  FLAG (0=W, 1=R) --- )}
_HEADER({BLOCK-WRITE},{BLWRITE},{DOCOL})
        DC      ZERO, DERR, STOR
         _SWITCH_({DC   SWAP, LIT, M4_SWITCHOFFSET, PLUS, SWAP})
        DC      LIT, 0x0301      _C{ Write (AH) one (AL) sector }
        DC      SWAP
        DC      SPBLK,  STAR
        DC      SPBLK,  OVER, PLUS
        _DO(BLWRIT9)
BLWRIT0:
        DC      TDUP
        DC      IDO
        DC      SECRW
        DC      LIT, BPS, PLUS
        _LOOP(BLWRIT0)
BLWRIT9:
        DC      TDROP
        DC      DERR, FETCH
        _0BRANCH(BLWRIT5)              _C{OK}
        DC      ZERO,   _PREV,   FETCH,     STOR   _C{This  buffer}
        DC      LIT, 9, LERROR
BLWRIT5:  DC      SEMIS
_C
})_C{}_END_({ _RWSECTRK_})
_RWLBA_({

_C{ Warning : if this LBA is used apart from by R|W}
_C{ the fields marked default must be restored.}
worddoc( {BLOCKS},{LBAPAR},{l_b_a_params},{ --- addr},{},
{ A data structure used by R|W , that also must be filled in for disk
operations forthcode({BLOCK-READ}) and forthcode({BLOCK-WRITE}) .
Do not touch the first 16-bits word.
The second word is the number of sectors to be
transferred. The third and fourth word contain a long real mode
pointer where the data comes from or goes to. The fourth word
and fifth word is as 32 bit counter for the sector on the disc.
If a 2 Terabyte disk is not enough this can be extended into
the sixth and seventh word.
Word 1,2,4 6 and 7 must be restored to their previous value after
calling forthcode({BLOCK-READ}) and forthcode({BLOCK-WRITE}) so as not to interfere
with forthcode({R|W}). },
{{R|W},{BLOCK},{OFFSET}}, {}, enddoc)
_HEADER({LBAPAR},{LBA},{DOVAR}, )
        DB      0x10, 0      _C{ default    }
        DW      SPB         _C{ default    }
        DW      0           _C{ to be filled with offset}
        DW      _SWITCH_({SWITCHSEGMENT}) _C{ default segment}
        _C{ At a hard disk we just read sector from sector 1        }
        DD      0       _C{ sector number}
        DD      0       _C{ M.S. 32 BITS default}

worddoc( {BLOCKS},{BLOCK-READ},{block_read},{},{},
{Perform a disk read operation using a properly filled in LBA structure
in forthcode({LBAPAR}). },
{{R|W},{BLOCK-WRITE}}, {}, enddoc)
CODE_HEADER({BLOCK-READ},{BLREAD})
        MOV     BX,0x4200
        JMP    RWBLK
_C
worddoc( {BLOCKS},{BLOCK-WRITE},{block_write},{},{},
{Perform a disk write operation using a properly filled in LBA
structure in forthcode({LBAPAR}). },
{{R|W},{BLOCK-READ}}, {}, enddoc)
CODE_HEADER({BLOCK-WRITE},{BLWRITE})
        MOV     BX,0x4300
RWBLK:
        POP     AX
        PUSH    HIP      _C{PRESERVE INTERPRETER POINTER}
        _SWITCH_({ADD     AX, M4_SWITCHOFFSET })
        MOV     SI,AX
        PUSH    RPO      _C{RETURN POINTER}
        MOV     DX,0x0080  _C{   Disk C                                 }
        _SWITCH_({JMPHERE_FROM_FORTH})
        XCHG    BX,AX
        INT     0x13
        PUSHF           _C{ REMEMBER STATUS}
        POP     BX
        _SWITCH_({JMPHERE_FROM_OS})
        POP     RPO      _C{RETURN STACK}
        POP     HIP      _C{INTERPRETER PNTR}
        PUSH    BX
        _NEXT

worddoc( {BLOCKS},{R|W},{read_slash_write},{addr blk n ---},{},
{The ciforth primitive for read-write of blocks. forthvar({addr})
specifies the source or destination block buffer, It must reside
in the lowest 1 Mbyte of physical memory.
forthvar({blk}) is
the sequential number of the referenced physical block; and
forthvar({n}) is a control variable
for forthvar({n})=0 write and forthvar({n})=l
read. forthcode({R|W}) determines the location on mass storage,
performs the read-write and aborts with an error message for failures.
This function uses ``LBA'' : Logical Block Addressing and may
not work on elderly hard disks.
_BITS16_({{Where blk is at most 64K the largest addressable disk is
64M , you can get around this by filling in }forthcode({LBAPAR}){ and then calling
 forthcode({BLOCK-READ}) or }forthcode({BLOCK-WRITE}){ }})
forthcode({DISK-ERROR}) contains the status of the latest operation,
bit 1 (carry flag) indicates an error.
},
{{BLOCK},{DISK-ERROR},{LBAPAR},{BLOCK-READ},{BLOCK-WRITE}}, {}, enddoc)
_C{      ( ADDR  OFFSET+BLK#  FLAG (0=W, 1=R) --- )}
_HEADER({R|W},{RSLW},{DOCOL})
        DC      TOR
        DC      SWAP
_C{       On a big endian machine the following code is 16/32 bit clean.}
_C{       The 2 m.s. bytes are overwritten by the next store.}
         _SWITCH_({DC   LIT, A_FORTH0, PLUS })
        DC      LDUP, LIT, 0x0F, LAND
        DC      LBA, LIT, 4, PLUS, STOR   _C{  Address }
        DC      LIT, 4, RSHIFT
        DC      LBA, LIT, 6, PLUS, STOR
        DC      LIT, SPB, STAR  _C{ Sector number}
        DC      LBA, LIT, 8, PLUS, STOR _C{  Sector number. }
        DC      LBA
        DC      RR
        _0BRANCH(RSLW1)
        DC      BLREAD
        _BRANCH(RSLW2)
RSLW1:  DC      BLWRITE
RSLW2:  DC      LDUP, DERR, STOR

        DC      ONE, LAND, LDUP
        _0BRANCH(RSLW4)
_C{        DC      ZERO,   _PREV,   FETCH,     STOR   }_C{This  buffer}
                                                   _C{ is no good!}
RSLW4:
        _C{ Handle error}
        DC      LIT,    9   _C{Write error}
        DC      FROMR, LSUB _C{ 1 less: read error}
        DC      QERR    _C{8 or 9 }
        DC      SEMIS
_C
})_C{}_END_({ _RWLBA_})
_C
_LOAD_({
worddocsafe( {DICTIONARY},{'},{tick_iso},{--- addr},{ISO,FIG},
{Used in the form: forthexample({' nnnn })
It leaves the forthdefi({execution token}) (equivalent to the
forthdefi({dea}) dictionary entry address)
of dictionary word forthsamp({nnnn}).
If the word is not found after a search of
the search order an appropriate error message is
given.
If compiled the searching is done while
the word being compiled is executed.
Because this is so confusing,
it is recommended that
one never compiles or postpones forthcode({'}).
(Use a
combination of forthcode({NAME}) and forthcode({FOUND}) _VERBOSE_({{or
any form of explicit parsing and searching }})
instead.)
_VERBOSE_({Furthermore it is recommended that
for non-portable code forthcode({'}) is used in its
forthdefi({denotation}) form without the space}).
},
{{[']},{FOUND},{>CFA},{>DFA},{>FFA},{>LFA},{>NFA},{>SFA},{>XFA}
dnl _SOURCEFIELD_({,{>SFA}},dnl)  doesn't work FIXME
dnl _EXTRAFIELD({,{>XFA}},dnl)    doesn't work FIXME
,{EXECUTE}},
{
{ : QPE 1 2 ; ' QPE EXECUTE ' QPE ID. . . },{QPE 2 1 },
{ : QQ  ' EXECUTE ' ID. . . ; QQ  QPE QPE },{QPE 2 1},
{' QPEEE },{' QPEEE ?  ciforth ERROR # 11 : WORD IS NOT FOUND},
},
enddoc)
_HEADER({'},{ITICK},{DOCOL} )
        DC      LNAME, PRESENT
        DC      LDUP, ZEQU
        DC      LIT, 11, QERR
        DC      SEMIS
_C
worddocsafe( {DICTIONARY},{[']},{bracket_tick_bracket},{--- addr},{ISO,I},
{Used in the form:
forthexample({['] nnnn})
In compilation mode it leaves the
forthdefi({execution token}) (equivalent to the dictionary
entry address) of dictionary word forthsamp({nnnn}). So as a
compiler directive it compiles the address as a literal. If the
word is not found after a search of the search order
an appropriate error message is
given.
_VERBOSE_({It is recommended that
where you can't use a forthdefi({denotation}){,} or don't want to{,}
you use a combination of
forthcode({NAME}) and forthcode({FOUND}) (or forthcode({WORD}) and forthcode({FIND})) instead.
})
 },
{{FOUND},{'},{EXECUTE}} ,
{{ : APE 1 2 ; : GS1 ['] APE ; GS1 EXECUTE  GS1 ID. . .},{APE 2 1}},
enddoc)
dnl An alias header. CFA DFA are the same.
_HEADER({[']},{BTICK},{DOCOL}, _VAR_FIELD({TICK}), B_IMMED)
_C
})_C{}_END_({_LOAD_})
worddoc( {DICTIONARY~},{FORGET-VOC},{forget_voc},{addr wid --- addr },{},
{Remove all words whose forthdefi({dea}) is greater (which mostly means later defined) than
forthvar({addr}) from a wordlist given by
forthvar({wid}) .
This works too if links have been redirected, such that some earlier
words point back to later defined words.
Leave forthvar({addr}) (as
forthcode({FORGET-VOC}) is intended to be used with
forthcode({FOR-VOCS})) . If any whole namespace is removed,
the search order is reset to forthsamp({ONLY FORTH}). The space
freed is not recovered.},
{{FORGET}},
{
{!CSP NAMESPACE APE dnl
APE DEFINITIONS : GO ; : CH ; : GI ; dnl
FORTH DEFINITIONS : NEW ; ?CSP},{},
{APE ' CH ' APE FORGET-VOC ID.},{CH},
{APE DEFINITIONS LATEST ID.},{GO},
{FORTH DEFINITIONS LATEST ID.},{NEW},
},
enddoc)
_HEADER({FORGET-VOC},{FORGV},{DOCOL})
        DC      TDUP
        DC      SWAP
        DC      ULESS
        _0BRANCH(FORGV1)
_C{  Forget part of contents.}
        DC      SWAP
        DC      TOR
        DC      TWID
FORGV0:
        DC      LDUP
        DC      LDUP
FORGV3:
        DC      TLFA,FETCH
        DC      LDUP
        DC      RR
        DC      ULESS
        _0BRANCH(FORGV3)
        DC      SWAP            _C{  Not to be forgotten entry found.}
        DC      TLFA
        DC      STOR           _C{  Short other entries out.}
        DC      TLFA,FETCH
        DC      LDUP
        DC      ZEQU
        _0BRANCH(FORGV0)        _C{  Repeat until end of wordlist.}
        DC      DROP
        DC      FROMR
        _BRANCH(FORGV2)
FORGV1:
_C{       { Vocabulary itself is also forgotten.}}
        DC      TVFA
        DC      FETCH     _C{ Unlink by linking next namespace.}
        DC      VOCL
        DC      STOR
        DC      ONLY, FORTH
        DC      DEFIN
FORGV2: DC      SEMIS
_C
worddoc( {DICTIONARY},{FORGET},{forget},{},{ISO,FIG,E},
{Executed in the form:
               forthcode({FORGET}) forthvar({cccc})
Deletes definition named forthvar({cccc}) from the dictionary
with all entries physically following it. Recover the space
that was in use.},
{{FENCE},{FORGET-VOC}},
{
{: GO ; HERE : CH ; : GI ; FORGET CH LATEST ID. },{GO},
{HERE - .},{0},
},
enddoc)
_HEADER({FORGET},{FORG},{DOCOL})
        DC      TICK
        DC      LDUP
        DC      FENCE
        DC      FETCH
        DC      LESS
        DC      LIT, 21, QERR
        DC      LIT,FORGV
        DC      FORV
        DC      TNFA, FETCH, LDP, STOR
        DC      SEMIS
_C
worddocsafe( {CONTROL~},{(BACK},{paren_back},{--- addr},{},
{Start a backward branch by leaving the target address
forthcode({HERE}) into forthvar({addr}). _VERBOSE_({Usage is
forthsamp({ (BACK .. POSTPONE BRANCH BACK) }) })},
{{BACK)},{BEGIN},{DO}},
{
{: GS1 -1 [ (BACK ] 1+ DUP .
DUP 0BRANCH [ BACK) ] ; GS1 .},
{0 1 1}
},
enddoc)
_HEADER({(BACK},{PBACK},{DOCOL})
        DC      HERE
        DC      SEMIS
_C
worddocsafe( {CONTROL~},{BACK)},{back_paren},{addr ---},{},
{Complete a backward branch by compiling an offset from
forthcode({HERE}) to forthvar({addr}), left there by
forthcode({{{{{(BACK}}}}}) . _VERBOSE_({{Usage is
}forthsamp({ (BACK .. POSTPONE BRANCH BACK) }){ }})},
{{LOOP},{UNTIL}},
{{( See (BACK )},{}},
enddoc)
_HEADER({BACK)},{BACKP},{DOCOL})
        DC      HERE
        DC      CELLP
        DC      LSUB
        DC      COMMA
        DC      SEMIS
_C
worddocsafe( {CONTROL~},{(FORWARD},{paren_forward},{--- addr},{},
{Start a forward branch by allocating space for an offset,
that must be backpatched into forthvar({addr}).
_VERBOSE_({{Usage is
}forthsamp({ POSTPONE BRANCH (FORWARD .. FORWARD) }){ }})},
{{IF},{BRANCH},{0BRANCH}},
{
{: GS1 2 BRANCH [ (FORWARD ] 4 [ FORWARD) ] 6 ; GS1 . .},
{6 2}
},
enddoc)
_HEADER({(FORWARD},{PFORWARD},{DOCOL})
        DC      HERE
        DC      X
        DC      COMMA
        DC      SEMIS
_C
worddocsafe( {CONTROL~},{FORWARD)},{forward_paren},{addr ---},{},
{Complete a forward branch by backpatching an offset from
forthcode({HERE}) into forthvar({addr}), left there by forthcode({{{{{(FORWARD}}}}}) .
_VERBOSE_({{Usage is }forthsamp({POSTPONE
BRANCH (FORWARD .. FORWARD) }){ }})
},
{{LOOP},{UNTIL},{REPEAT}},
{{( See (FORWARD)},{}},
enddoc)
_HEADER({FORWARD)},{FORWARDP},{DOCOL})
        DC      HERE
        DC      OVER
        DC      CELLP
        DC      LSUB
        DC      SWAP
        DC      STOR
        DC      SEMIS
_C
worddoc( {CONTROL},{BEGIN},{begin},{--- addr n  (compiling)},{ISO,FIG,I},
{Occurs in a colon-definition in one of the forms:
  forthexample({BEGIN ... UNTIL})
  forthexample({BEGIN ... AGAIN})
  forthexample({BEGIN ... WHILE ... REPEAT})
At run-time, forthcode({BEGIN}) marks the start of a sequence that may be
repetitively executed. It serves as a return point from the
corresponding forthcode({UNTIL}) , forthcode({AGAIN}) or forthcode({REPEAT}) .
When executing forthcode({UNTIL}) a return
to forthcode({BEGIN}) will occur if the top of the stack is false;
for forthcode({AGAIN}) and forthcode({REPEAT}) a return to forthcode({BEGIN}) always occurs.

At compile time forthcode({BEGIN}) leaves its return address and forthvar({n}) for compiler
error checking.},{{(BACK},{DO}},
{
{0 WARNING !   BEGIN},{0 WARNING !   BEGIN ? ciforth ERROR # 17 },
 {CR 1 WARNING !},{}
},
enddoc)
_HEADER({BEGIN},{BEGIN},{DOCOL}, , B_IMMED)
        DC      PBACK
        _SECURITY_({DC      QCOMP, ONE})
        DC      SEMIS
_C
worddoc( {CONTROL},{THEN},{endif},{addr n --- (compile)},{ISO,FIG,I,C},
{Occurs in a colon-definition in form:
 forthexample({IF ... THEN})
 forthexample({IF ... ELSE ... THEN})
At run-time, forthcode({THEN}) serves only as the destination
of a forward branch from forthcode({IF}) or forthcode({ELSE}) .
It marks the conclusion of the conditional structure. At
compile-time, forthcode({THEN}) computes the forward branch
offset from forthvar({addr}) to forthcode({HERE}) and stores it
at forthvar({addr}) . forthvar({n}) is used for error tests.},
{{FORWARD)},{IF},{ELSE}},
{{( See IF ELSE)},{}},
enddoc)
_HEADER({THEN},{THEN},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      QCOMP, TWO, QPAIR})
        DC      FORWARDP
        DC      SEMIS
_C
worddoc( {CONTROL},{DO},{do},
{n1 n2 --- (execute) addr n --- (compile)},{ISO,FIG,I,C},
{Occurs in a colon-definition in form: forthsamp({DO ... LOOP})
At run time, forthcode({DO}) begins a sequence with repetitive
execution controlled by a loop limit forthvar({n1}) and an
index with initial value forthvar({n2}) .
forthcode({DO}) removes
these from the stack. Upon reaching forthcode({LOOP}) the
index is incremented by one. Until the new index equals or
exceeds the limit, execution loops back to just after
forthcode({DO}) ; otherwise the loop parameters are discarded
and execution continues ahead. Both forthvar({n1}) and
forthvar({n2}) are determined at run-time and may be the result
of other operations. Within a loop forthcode({I}) will copy the
current value of the index to the stack.
With forthcode({+LOOP}) it can be used with other increments than one.

It deviates from the ISO standard in that
that if forthvar({n1}) is equal to forthvar({n2}) the loop is never
executed even once.

When compiling within the colon definition, forthcode({DO}) compiles
forthcode({(DO)}) and leaves the following address forthvar({addr}) and
forthvar({n}) for later error checking.},
{{I},{LOOP},{+LOOP},{LEAVE}},
{ { : GS1 DO 41 EMIT LOOP ; 3 0 GS1},{AAA},
dnl ISO VIOLATION:
  {: GS3 0 1 1 DO 1+ I 4 = IF LEAVE THEN LOOP . ; GS3 },{1},
dnl {: GS3 0 1 1 DO 1+ I 4 = IF LEAVE THEN LOOP . ; GS3 },{4}, dnl ISO
  {0 WARNING !   DO},{  0 WARNING !   DO ? ciforth ERROR # 17 },
  {1 WARNING !},{},
  },
enddoc)
_HEADER({DO},{DO},{DOCOL}, , B_IMMED)
         DC      LIT, XDO, COMMA, PFORWARD, PBACK
        _SECURITY_({DC      QCOMP, LIT,3    _C{ Magic number}})
        DC      SEMIS
_C
worddoc( {CONTROL},{?DO},{question_do},{n1 n2 --- (execute)
addr n --- (compile)},{NISO,I,C},
{Occurs in a colon-definition in form:
    forthexample({?DO ... LOOP})
It behaves like forthcode({DO}),
with the exception that if forthvar({n1}) is less than forthvar({n2})
the loop body is not executed.
This is intended to suppress the unwanted behaviour of looping
through the whole number range,
ciforth deviates from ISO in that it also suppresses the unwanted
behaviour of looping through almost the whole number range for
an input of e.g. forthexample({1 2})
However, negative increments are made impossible for forthword({?DO}) this way.
},
{{DO},{I},{LOOP},{+LOOP},{LEAVE}},
{
  { : GS1 ?DO 41 EMIT LOOP 0 . ; 3 0 GS1},{AAA0 },
  {: GS3 0 1 1 ?DO I . LOOP . ; GS3 },{0} ,
dnl ISO VIOLATION:
  {: GS4 0 -1 1 ?DO I . LOOP . ; GS4 },{0} ,
dnl {: GS4 0 -1 1 ?DO 1- I DUP 4 = IF LEAVE THEN LOOP . ; GS4 },{4}, dnl ISO
  {0 WARNING !   ?DO},{  0 WARNING !   ?DO ? ciforth ERROR # 17 },
  {CR 1 WARNING !},{}
},
enddoc)
_HEADER({?DO},{QDO},{DOCOL}, , B_IMMED)
         DC      LIT, XQDO, COMMA, PFORWARD, PBACK
        _SECURITY_({DC      QCOMP, LIT,3    _C{ Magic number}})
        DC      SEMIS
_C
worddoc( {CONTROL},{LOOP},{loop},
{ --- (run) addr n --- (compiling)},{ISO,I,C},
{Occurs in a colon-definition in form:
    forthexample({DO ... LOOP})
At run-time, forthcode({LOOP}) selectively controls branching
back to the corresponding forthcode({DO}) based on the loop
index and limit. The loop index is incremented by one and
compared to the limit. The branch back to
forthcode({DO}) occurs until the index equals or exceeds the
limit; at that time, the parameters are discarded and execution
continues ahead.

At compile-time, forthcode({LOOP}) compiles
forthcode({(LOOP)}) and uses forthvar({addr}) to calculate an
offset to forthsamp({DO}) . forthvar({n2}) is used for compile
time error checking.},
{{+LOOP}},
{ { : GS1 DO I . LOOP ; 2 -2 GS1},{-2 -1 0 1},
  { : GS2 DO I . LOOP ; 4 0 GS2},{0 1 2 3} },
enddoc)
_HEADER({LOOP},{LLOOP},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      QCOMP, LIT, 3, QPAIR})
        DC      LIT, XLOOP, COMMA, BACKP
        DC      FORWARDP _C{ For DO to push the leave address.}
        DC      SEMIS
_C
worddoc( {CONTROL},{+LOOP},{plus_loop},
{n1 --- (run) / addr n2 --- (compile)},{ISO,I,C},
{Used in a colon-definition in the form:
    forthexample({DO ... n1 +LOOP})
At run-time, forthcode({+LOOP}) selectively controls branching
back to the corresponding forthcode({DO}) based on
forthvar({n1}) , the loop index and the loop limit. The signed
increment forthvar({n1}) is added to the index and the total
compared to the limit.
The branch back to forthcode({DO}) occurs until the new index
is equal to or greater than the limit (forthsamp({n1>0})), or
until the new index is equal to or less than the limit
(forthsamp({n1<0})). Negative increments cannot be combined with
 forthcode({?DO}) , this deviates from the ISO standard.
Upon exiting the loop, the parameters are
discarded and execution continues ahead.

At compile time, forthcode({+LOOP}) compiles the run-time word
forthcode({(+LOOP)}) and the branch offset computed from
forthcode({HERE}) to the address left on the stack by
forthcode({DO}) .
 forthvar({n2}) is used for compile time error
checking.},{},
{ { : GS1 DO I . -1 +LOOP ; -1 2 GS1},{2 1 0 -1},
  { : GS2 DO I . 2 +LOOP ; 4 0 GS2},{0 2 } },
enddoc)
_HEADER({+LOOP},{PLOOP},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      QCOMP, LIT, 3, QPAIR})
        DC      LIT, XPLOO, COMMA, BACKP
        DC      FORWARDP _C{ For DO to push the leave address.}
        DC      SEMIS
_C
worddoc( {CONTROL},{UNTIL},{until},
{f --- (run-time) / addr n --- (compile)},{ISO,FIG,I,C},
{Occurs within a colon-definition in the form:
              forthexample({BEGIN ... UNTIL})
At run-time, forthcode({UNTIL}) controls the conditional branch
back to the corresponding forthcode({BEGIN}). If f is false,
execution returns to just after forthcode({BEGIN}) , otherwise
execution continues ahead.

At compile-time, forthcode({UNTIL}) compiles
forthcode({0BRANCH}) and an offset from forthcode({HERE}) to
addr. forthvar({n}) is used for error tests.},
{{BEGIN}},
{
{: GI4 BEGIN DUP . 1+ DUP 5 > UNTIL ; 3 GI4 .},{3 4 5 6},
{8 GI4 .},{8 9}
},
enddoc)
_HEADER({UNTIL},{UNTIL},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      QCOMP, ONE, QPAIR})
        DC      LIT, ZBRAN, COMMA, BACKP
        DC      SEMIS
_C
worddoc( {CONTROL},{AGAIN},{again},{addr n --- (compiling)},{ISO,FIG,I,C},
{Used in a colon-definition in the form:
    forthexample({BEGIN ... AGAIN})
At run-time,
forthcode({AGAIN}) forces execution to return to the corresponding
forthcode({BEGIN}) . There is no effect on the stack. Execution
cannot leave this loop except for forthcode({EXIT}). At compile
time, forthcode({AGAIN}) compiles forthcode({BRANCH}) with an
offset from forthcode({HERE}) to addr. forthvar({n}) is used
for compile-time error checking.},
{{BEGIN}},
{
{ : GCE2 BEGIN DUP . 1 - DUP 0= IF EXIT THEN AGAIN ; 3 GCE2 DROP},
{3 2 1}
},
enddoc)
_HEADER({AGAIN},{AGAIN},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      QCOMP, ONE, QPAIR})
        DC      LIT, BRAN, COMMA, BACKP
        DC      SEMIS
_C
worddoc( {CONTROL},{REPEAT},{repeat},{addr1 n1 addr2 n2--- (compiling)},{ISO,FIG,I,C},
{Used within a colon-definition in the form:
    forthexample({BEGIN ... WHILE ... REPEAT})
At run-time, forthcode({REPEAT}) forces an unconditional branch
back to just after the corresponding forthcode({BEGIN}) .

At compile-time, forthcode({REPEAT}) compiles
forthcode({BRANCH}) and the offset from forthcode({HERE}) to
forthvar({addr2}) . Then it fills in another branch offset at
forthvar({addr1}) left there by forthcode({WHILE}) .
forthvar({n1 n2}) is used for error testing.},
{{WHILE}},
{
{ : GI3 BEGIN DUP 4 < WHILE DUP . 1+ REPEAT ; 0 GI3 .},
{0 1 2 3 4},
{S0 @ DSP!},{}
},
enddoc)
_HEADER({REPEAT},{REPEA},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      QCOMP, ONE, QPAIR   _C{ Matches BEGIN ?}})
        DC      LIT, BRAN, COMMA, BACKP
        _SECURITY_({DC      LIT, 4, QPAIR _C{ Matches WHILE ?}})
        DC      FORWARDP _C{ WHILE target. }
        DC      SEMIS
_C
worddoc( {CONTROL},{IF},{if},
{f --- (run-time) / --- addr n (compile)},
{ISO,FIG,I,C},
{Occurs in a colon-definition in form:
      forthexample({IF (tp) ...  THEN})
    or
      forthexample({IF (tp) ... ELSE (fp) ... THEN})
At run-time, forthcode({IF}) selects execution based on a
boolean flag. If forthvar({f}) is true (non-zero), execution
continues ahead thru the true part. If forthvar({f}) is false
(zero), execution skips till just after forthcode({ELSE}) to
execute the false part. After either part, execution resumes
after forthcode({THEN}).
forthcode({ELSE}) and its false part are optional; if missing,
false execution skips to just after forthcode({THEN}) .

At compile-time forthcode({IF}) compiles
forthcode({0BRANCH}) and reserves space for an offset at
forthvar({addr}) . forthvar({addr}) and forthvar({n}) are
used later for resolution of the offset and error testing.},
{{(FORWARD},{0BRANCH}},
{
{ : GI1 IF 123 THEN ; 234 1 GI1 . .},{123 234},
{  234 -1 GI1 . .},{123 234},
{  234 0 GI1 .},{234},
},
enddoc)
_HEADER({IF},{LIF},{DOCOL}, , B_IMMED)
        DC      LIT, ZBRAN, COMMA, PFORWARD
        _SECURITY_({DC      QCOMP, TWO     _C{ Magic number}})
        DC      SEMIS
_C
worddoc( {CONTROL},{ELSE},{else},{addr1 n1 --- addr2 n2 (compiling)},
{ISO,FIG,I,C},
{Occurs within a colon-definition in the form:
               forthexample({IF ... ELSE ... THEN})
At run-time, forthcode({ELSE}) executes after the true part
following forthcode({IF}) . forthcode({ELSE}) forces execution
to skip over the following false part and resumes execution
after the forthcode({THEN}) . It has no stack effect.

At compile-time forthcode({ELSE}) compiles
forthcode({BRANCH}) and reserves a places for a branch offset,
leaving its address forthvar({addr2}) and forthvar({n2}) for error
testing. forthcode({ELSE}) also resolves the pending forward
branch from forthcode({IF}) by calculating the offset from
forthvar({addr1}) to forthcode({HERE}) and storing at
forthvar({addr1}) .},
{{(FORWARD},{FORWARD)},{BRANCH}},
{
{: GI2 IF 123 ELSE 234 THEN ; 0 GI2 .},{234},
{1 GI2 .},{123}
},
enddoc)
_HEADER({ELSE},{LELSE},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      QCOMP, TWO, QPAIR})
        DC      LIT, BRAN, COMMA, PFORWARD
        DC      SWAP
        DC      FORWARDP
        _SECURITY_({DC      TWO     _C{ Magic number}})
        DC      SEMIS
_C
worddoc( {CONTROL},{WHILE},{while},
{f --- (run-time) / addr1 nl --- addr2 n1 addr1 n2 (compile-time)},
{ISO,FIG,I,C},
{Occurs in a colon-definition in the form:
         forthsamp({BEGIN ... WHILE (tp) ... REPEAT})
At run-time, forthcode({WHILE}) selects conditional execution
based on boolean flag forthvar({f}) . If forthvar({f}) is true
(non-zero), forthcode({WHILE}) continues execution of the true
part thru to forthcode({REPEAT}) , which then branches back to
forthcode({BEGIN}) . If forthvar({f}) is false (zero),
execution skips to just after forthcode({REPEAT}) , exiting the
structure.

At compile time, forthcode({WHILE}) compiles
forthcode({0BRANCH}) and tucks the
target address forthvar({addr2})
under the forthvar({addr1}) left there by
forthcode({BEGIN}) . The stack values will be resolved by
forthcode({REPEAT}) . forthvar({n1}) and forthvar({n2})
provide checks for compiler security.},
{{(FORWARD},{BEGIN}},
{
{ : GI3 BEGIN DUP 4 < WHILE DUP . 1+ REPEAT ; 0 GI3 .},
{0 1 2 3 4},
{6 GI3 .},{6}
},
enddoc)
_HEADER({WHILE},{LWHILE},{DOCOL}, , B_IMMED)
        _SECURITY_({DC      QCOMP, LDUP, ONE, QPAIR})
        DC      TOR    _C{  Save backward target. }
        _SECURITY_({DC      TOR})
        DC      LIT, ZBRAN, COMMA, PFORWARD
        _SECURITY_({DC      LIT, 4 _C{ Magic number}})
        _SECURITY_({DC      FROMR})
        DC      FROMR
        DC      SEMIS
_C
worddoc( {OUTPUT},{SPACES},{spaces},{n ---},{ISO,FIG},
{If forthvar({n}) is greater or equal to zero, display as much
spaces. },{{SPACE},{OUT}},
{
{41 EMIT 0 SPACES 41 EMIT},{AA},
{41 EMIT 3 SPACES 41 EMIT},{A   A}
},
enddoc)
_HEADER({SPACES},{SPACES},{DOCOL})
        DC      ZERO
        DC      MAX
        DC      ZERO
        _QDO(SPAX1)
SPAX2:  DC      SPACE
        _LOOP(SPAX2)    _C{LOOP}
SPAX1:
        DC      SEMIS
_C
worddoc( {FORMATTING},{<#},{less_number_sign},{},{ISO,FIG},
{Setup for pictured numeric output formatting using the words:
forthcode({<#}) forthcode({#}) forthcode({#S})
forthcode({SIGN}) forthcode({#>}) The conversion is done on a
double number producing text growing down from forthcode({PAD})
.},
{{DPL},{HLD},{HOLD},{FLD}},
{
 {!CSP 123.456 <# #> TYPE ?CSP}, {},
 {!CSP 1234.56 <# # # &. HOLD #S #> TYPE ?CSP}, {1234.56 }
},
enddoc)
_HEADER({<#},{BDIGS},{DOCOL})
        DC      PAD
        DC      HLD
        DC      STOR
        DC      SEMIS
_C
worddoc( {FORMATTING},{#>},{number_sign_greater},{d --- sc },{ISO,FIG},
{Terminates numeric output conversion by dropping forthvar({d}), leaving
the formatted string forthvar({sc}) .},
{{<#}},
{{( Via <#)},{}},
enddoc)
_HEADER({#>},{EDIGS},{DOCOL})
        DC      DROP
        DC      DROP
        DC      HLD
        DC      FETCH
        DC      PAD
        DC      OVER
        DC      LSUB
        DC      SEMIS
_C
worddoc( {FORMATTING},{SIGN},{sign},{n ---},{ISO,FIG},
{Add an ASCII minus-sign forthkey({-}) inside a forthcode({<#}) and forthcode({#>})
construct to the beginning of a converted numeric output
string in the text output buffer when forthvar({n}) is negative.
Must be used between forthcode({<#}) and
forthcode({#>}) .},
{{HOLD}},
{ {!CSP <# 1 0 -1 SIGN # -1 SIGN # # #> TYPE ?CSP}, {00-1-} },
{},
enddoc)
_HEADER({SIGN},{SIGN},{DOCOL})
        DC      ZLESS
        _0BRANCH(SIGN1) _C{IF}
        DC      LIT, AMS
        DC      HOLD    _C{THEN}
SIGN1:  DC      SEMIS
_C
worddoc( {FORMATTING},{#},{number_sign},{d1 --- d2},{ISO,FIG},
{Generate from a double number forthvar({d1}), the next ASCII
character which is placed in an output string. Result
forthvar({d2}) is the quotient after division by
forthcode({BASE}), and is maintained for further processing.
Used between forthcode({<#}) and forthcode({#>}).},
{{#S},{HLD}},
{
{!CSP 65.123 <# # # #> TYPE ?CSP},{23}
},
enddoc)
_HEADER({#},{DIG},{DOCOL})
        DC      BASE
        DC      FETCH
        DC      MSMOD
        DC      ROT
        DC      LIT,9
        DC      OVER
        DC      LESS
        _0BRANCH(DIG1)  _C{IF}
        DC      LIT,7
        DC      PLUS    _C{THEN}
DIG1:   DC      LIT,0x30
        DC      PLUS
        DC      HOLD
        DC      SEMIS
_C
worddoc( {FORMATTING},{#S},{number_sign_s},{d1 --- d2},{ISO,FIG},
{Generates ASCII text in the text output buffer, by the use of
forthcode({{{{{#}}}}}), until a zero double number
forthvar({d2}) results. Used between forthcode({<#}) and
forthcode({#>}).},
{},
{{!CSP 1.23 <# #S #> TYPE ?CSP},{123},
{!CSP 1.23456 <# #S #> TYPE ?CSP},{123456}
},
enddoc)
_HEADER({#S},{DIGS},{DOCOL})
DIGS1:  DC      DIG     _C{BEGIN}
        DC      OVER
        DC      OVER
        DC      LOR
        DC      ZEQU
        _0BRANCH(DIGS1) _C{UNTIL}
        DC      SEMIS
_C
worddocsafe( {OUTPUT},{(D.R)},{paren_d_dot_r},{d n ---sc},{ISO,FIG},
{Format a signed double number forthvar({d}) right aligned in a
field forthvar({n}) characters wide to the string forthvar({sc}).
Enlarge the field, if
needed. _VERBOSE_({{So a field length of 0 results effectively in free format.}})
},
{{OUT},{D.},{D.R}},
{{-12. 41 EMIT 5 (D.R) 41 EMIT TYPE 41 EMIT},{AA  -12A}},
enddoc)
_HEADER({(D.R)},{PDDOTR},{DOCOL})
        DC      TOR
        DC      SWAP
        DC      OVER
        DC      DABS
        DC      BDIGS
        DC      DIGS
        DC      ROT
        DC      SIGN
        DC      EDIGS
        DC      FROMR
        DC      OVER
        DC      LSUB, ZERO, MAX
        DC      ZERO
        _QDO(PDDOT1)
PDDOT2:  DC      LBL, HOLD  _C{WARNING: HOLD outside of #>.}
        _LOOP(PDDOT2)
PDDOT1:
        DC      EDIGS  _C{Drop string instead of number.}
        DC      SEMIS
_C
worddoc( {OUTPUT},{D.R},{d_dot_r},{d n ---},{ISO,FIG},
{Print a signed double number forthvar({d}) right aligned in a
field forthvar({n}) characters wide. Enlarge the field, if
needed.
_VERBOSE_({{So a field length of 0 results effectively in free format.}})
},
{{OUT},{D.},{(D.R)}},
{{-12. 41 EMIT 5 D.R 41 EMIT},{A  -12A}},
enddoc)
_HEADER({D.R},{DDOTR},{DOCOL})
        DC      PDDOTR
        DC      LTYPE
        DC      SEMIS
_C
worddocsafe( {OUTPUT},{.R},{dot_r},{n1 n2 ---},{},
{Print a signed number forthvar({n1}) right aligned in a
field forthvar({n2}) characters wide. Enlarge the field, if
needed.
_VERBOSE_({{So a field length of 0 results effectively in free format.}})
},
{{OUT},{.},{(D.R)}},
{{-12 41 EMIT 5 .R 41 EMIT},{A  -12A}},
enddoc)
_HEADER({.R},{DOTR},{DOCOL})
        DC      TOR
        DC      STOD
        DC      FROMR
        DC      DDOTR
        DC      SEMIS
_C
worddoc( {OUTPUT},{D.},{d_dot},{d ---},{ISO,FIG},
{Print the signed double number forthvar({d}),
observing the current forthcode({BASE}), followed by a blank.
},
{{OUT},{.},{D.R},{(D.R)}},
{{-12. D. 41 EMIT},{-12 A}},
enddoc)
_HEADER({D.},{DDOT},{DOCOL})
        DC      ZERO
        DC      DDOTR
        DC      SPACE
        DC      SEMIS
_C
worddocsafe( {OUTPUT},{.},{dot},{n ---},{ISO,FIG},
{Print the number forthvar({n1})
observing the current forthcode({BASE}), followed by a blank.
},
{{OUT},{U.},{.R},{D.R},{D.},{(D.R)}},
{{-12 41 EMIT . 41 EMIT},{A-12 A}},
enddoc)
_HEADER({.},{DOT},{DOCOL})
        DC      STOD
        DC      DDOT
        DC      SEMIS
_C
worddoc( {OUTPUT},{?},{question},{addr ---},{ISO,FIG},
{Print the value contained at the address forthvar({addr})
observing the current forthcode({BASE}), followed by a blank.
},
{{OUT},{.}},
{{-12 PAD ! 41 EMIT PAD ? 41 EMIT},{A-12 A}},
enddoc)
_HEADER({?},{QUES},{DOCOL})
        DC      FETCH
        DC      DOT
        DC      SEMIS
_C
worddocsafe( {OUTPUT},{U.},{u_dot},{u ---},{ISO},
{Print the unsigned number forthvar({u})
observing the current forthcode({BASE}), followed by a blank.
},
{{OUT},{.},{.R},{D.R},{D.},{(D.R)}},
_BITS64_({ {{12 41 EMIT U. 41 EMIT},{A12 A},
{-1 41 EMIT U. 41 EMIT},{AFFFFFFFFFFFFFFFF A}},})
_BITS32_({ {{12 41 EMIT U. 41 EMIT},{A12 A},
{-1 41 EMIT U. 41 EMIT},{AFFFFFFFF A}},})
_BITS16_({ {{12 41 EMIT U. 41 EMIT},{A12 A},
{-1 41 EMIT U. 41 EMIT},{AFFFF A}},})
enddoc)
_HEADER({U.},{UDOT},{DOCOL})
        DC      ZERO
        DC      DDOT
        DC      SEMIS
_C
worddoc( {DICTIONARY~},{FOR-WORDS},{for_words},{x1...xn xt wid --- x1...xn},{},
{For all words from a word list identified by
forthvar({wid})
execute forthvar({xt})
 with as data forthvar({x1..xn}) plus
the forthdefi({dea}) of those words.         forthvar({xt})
must have the stack diagram forthvar({x1..xn dea --- x1..xn}).
_VERBOSE_({{Note that you can use the forthdefi({dea}) of any word as a WID
and the remainder of the word list will be searched.}})
},
{{FOR-VOCS},{EXECUTE}},
{{( See MATCHING-WORDS)},{}},
enddoc)
_HEADER({FOR-WORDS},{FORW},{DOCOL})
        DC      SWAP
        DC      TOR
        DC      TOR
FORW1:  DC      FROMR
        DC      RR
        DC      OVER
        DC      TLFA
        DC      FETCH
        DC      TOR
        DC      EXEC
        DC      RR
        DC      ZEQU
        _0BRANCH(FORW1)
        DC      RDROP
        DC      RDROP
        DC      SEMIS
_C
worddoc( {DICTIONARY~},{FOR-VOCS},{for_vocs},{x1..xn xt --- x1...xn},{},
{For all vocabularies execute forthvar({xt})
 with as data the forthdefi({dea}) of those words. forthvar({xt})
must have the stack diagram forthvar({x1..xn dea --- x1..xn})
},
{{FOR-WORDS},{EXECUTE}},
{
{ NAMESPACE JOHN JOHN DEFINITIONS : ORAN ; ' ID. FOR-VOCS},
{JOHN ENVIRONMENT ONLY FORTH},
{FORTH DEFINITIONS},{}
},
enddoc)
_HEADER({FOR-VOCS},{FORV},{DOCOL})
        DC      TOR
        DC      VOCL
        DC      FETCH
        DC      TOR
FORV1:  DC      FROMR
        DC      RR
        DC      OVER
        DC      TVFA
        DC      FETCH
        DC      TOR
        DC      EXEC
        DC      RR
        DC      ZEQU
        _0BRANCH(FORV1)
        DC      RDROP
        DC      RDROP
        DC      SEMIS
_C
worddoc( {DICTIONARY},{WORDS},{words},{},{ISO},
{List the names of the definitions in the topmost word list of the
search order.
dnl A break as per forthcode({KEY?}) will terminate the listing.
},
{{CONTEXT}},
{
{NAMESPACE JOHN JOHN DEFINITIONS : GO ; : CH ; : GI ; },{},
{: Q 'GO >LFA ;},{},
{: GS1 Q @ 0 Q ! WORDS Q ! ; GS1},{GO CH GI Q GS1 },
{FORTH DEFINITIONS},{}
},
enddoc)
_HEADER({WORDS},{WORDS},{DOCOL})
        DC      CSLL
        DC      LOUT
        DC      STOR
        DC      ZERO            _C{ End sentinel. }
        DC      LIT, NOOP
        DC      CONTEXT
        DC      FETCH
        DC      FORW
WORDS1:
        DC      LDUP
        _0BRANCH(WORDS2)
        DC      IDDOT
        _BRANCH(WORDS1)
WORDS2:
        DC DROP
        DC      SEMIS
_C
_CLEANUP_BYE_({
worddoc( {OPERATINGSYSTEM},{BYE},{bye},{---},{ISO FIG},
{_PROTECTED_({Switch back to real mode.})
Return to the host environment MSDOS.
},{{COLD},{EXIT-CODE}},
{{." interactive"},{interactive}},
enddoc)
CODE_HEADER({BYE},{BYE})
_C{ EXIT TO PC-DOS, if run from PC-DOS, otherwise hang or whatever.}
        MOV     BX,[_VAR_FIELD(XCODE)]
        _SWITCH_({JMPHERE_FROM_FORTH})
RETDOSV: JMP 0:0        _C{ Filled in during boot}
        _BITS32_({SET_32_BIT_MODE})
        _BITS64_({SET_64_BIT_MODE})

})_C{}_END_({ _CLEANUP_BYE_})
worddoc( {OPERATINGSYSTEM},{EXIT-CODE},{exit_code},{addr ---},{},
{Return forthvar({addr}) the address of a variable with the
exit code. Its content is passed to the host environment while
going forthcode({BYE}) . It is custom to return zero if there
are no errors. _PC_({MSDOS allows only single byte return
codes.}) _HOSTED_X_({_OS_ allows only single byte return
codes.})
},{{BYE}},
{{." See BYE"},{See BYE}},
enddoc)
_HEADER({EXIT-CODE},{XCODE},{DOVAR}, )
        DC      0
_C
_MSDOS_BYE_({
worddoc( {OPERATINGSYSTEM},{BYE},{bye},{---},{ISO FIG},
{Return to the host environment MSDOS , OS/2, Windows.
},{{COLD},{EXIT-CODE}},
{{." interactive"},{interactive}},
enddoc)
CODE_HEADER({BYE},{BYE})
        MOV     AL,[_VAR_FIELD(XCODE)]
        MOV     AH,0x4C
        INT     0x21
_C{ EXIT TO PC-DOS}
})_C{}_END_({ _MSDOS_BYE_})
_DLL_({
worddoc( {OPERATINGSYSTEM},{BYE},{bye},{---},{ISO},
{Return to the host environment _OS_.
},{{COLD},{EXIT-CODE}},
_BITS32_({  {
{ 1 LOAD  "GET-ENV" WANTED },{},
{ "COMSPEC" GET-ENV SHELL $!},{},
{"wina.exe -f 23 EXIT-CODE ! BYE >null:" SYSTEM ( No error!)}, { }
}, })
_BITS64_({  {
{ 1 LOAD  "GET-ENV" WANTED },{},
{ "COMSPEC" GET-ENV SHELL $!},{},
{"wina64.exe -f 23 EXIT-CODE ! BYE >null:" SYSTEM ( No error!)}, { }
}, })
enddoc)
_HEADER({BYE},{BYE},{DOCOL})
_C{ Exit to _OS_, with status as stored. }
        DC      CALLOPEN
        DC      XCODE, FETCH, PAR1
        DC      LIT, _ExitProcess@4, ICALLCLOSE
        DC      SEMIS   _C{Unnecessary, but helpful for decompilation.}
})_C{}_END_({ _DLL_})
_HOSTED_X_({
worddoc( {OPERATINGSYSTEM},{BYE},{bye},{---},{ISO},
{Return to the host environment _OS_.
},{{COLD},{EXIT-CODE}},
_HOSTED_LINUX_({
_BITS32_({
{{"./lina32 -f 23 EXIT-CODE ! BYE ;echo $?" SYSTEM},
{23 EXIT-CODE ! BYE 23}},  })
_BITS64_({
{{"./lina64 -f 23 EXIT-CODE ! BYE ;echo $?" SYSTEM},
{23 EXIT-CODE ! BYE 23}},  })
})_C{}_END_({_HOSTED_LINUX_})
_HOSTED_OSX_({
{{"./xina -f 23 EXIT-CODE ! BYE ;echo $?" SYSTEM},
{23 EXIT-CODE ! BYE 23}},
})_C{}_END_({_HOSTED_OSX_})
enddoc)
_HEADER({BYE},{BYE},{DOCOL})
_C{ Exit to linux, with status as stored. }
        DC      XCODE, FETCH, X, X, LIT, exit, XOS
        DC      SEMIS   _C{Unnecessary, but helpful for decompilation.}
})_C{}_END_({ _HOSTED_X_})
_C
worddoc( {SCREEN},{LIST},{list},{n ---},{ISO,FIG},
{Display the ASCII text of forthdefi({screen}) forthvar({n}).
The number of the screen is always printed in decimal.
forthcode({SCR}) contains the screen number during and after this process.},
{{BLOCK}},
{{." interactive"},{interactive}},
enddoc)
_HEADER({LIST},{LLIST},{DOCOL})
        DC      BASE, FETCH, TOR
        DC      DECA
        DC      SCR,STOR

        _STRINGINLINE({SCR # })
        DC      LTYPE
        DC      SCR, FETCH, DOT
        DC      SCR, FETCH, BLOCK, BBUF

        DC      LIT, 16, ZERO
        _DO(LLIST9)
LLIST1: DC      LIT, ALF, SSLAS
        DC      CR, IDO, LIT, 2, DOTR
        DC      SPACE, LTYPE
        _LOOP(LLIST1)
LLIST9:
        DC      TDROP
        DC      FROMR, BASE, STOR
        DC      SEMIS
_C
worddoc( {SCREEN},{INDEX},{index},{from to ---},{},
{Print the first line of each screen over the inclusive
range
forthvar({from}) , forthvar({to}) . This is used to view the
comment lines of an area of text on disc screens.},
{{LIST}},
{{." interactive"},{interactive}},
enddoc)
_HEADER({INDEX},{INDEX},{DOCOL})
        DC      LIT,AFF
        DC      EMIT,CR
        DC      ONEP,SWAP
        _DO(INDE9)
INDE1:  DC      CR,IDO
        DC      LIT,3
        DC      DOTR,SPACE
        DC      ZERO,IDO
        DC      PLINE, LTYPE
        _LOOP(INDE1)
INDE9:
        DC      SEMIS
_C
worddocsafe( {STACKS},{.S},{dot_s},{from to ---},{},
{Print the stack, in the current base.
For stack underflow print nothing.
},
{{LIST}},
{{S0 @ DSP! 1 2 3 .S},{S[ 1 2 3 ]},
{ : test S0 @ DSP! DROP .S ; test},
{S[ ]DSP! DROP .S ; test ? ciforth ERROR # 1 : EMPTY STACK},
{S0 @ DSP!},{} },
enddoc)
_HEADER({.S},{DOTS},{DOCOL})
        DC      CR
        DC      LIT, 'S', EMIT
        DC      LIT, ASO, EMIT
        DC      SPACE
        DC      SPFET, SZERO, FETCH
DOC2:   DC      OVER, OVER,  LSUB, ZLESS
        _0BRANCH(DOC1)
        DC      ZERO, CELLP, LSUB, LDUP, FETCH, DOT
        _BRANCH(DOC2)
DOC1:    DC DROP, DROP
        DC      LIT, ASC, EMIT
        DC SEMIS
_C
worddoc( {ENVIRONMENTS},{ENVIRONMENT?},{environment_query},{sc --- i*x true/false},{ISO},
{If the string forthvar({sc}) is a known environment
attribute, leave into forthvar({i*x}) the information about
that attribute and a true flag, else leave a false flag. In
fact the flag indicates whether the words is present in the
forthcode({ENVIRONMENT}) namespace and forthvar({i*x}) is
what is left by the word if executed.
},
{{NAMESPACE}},
{{"CORE" ENVIRONMENT? . .},{_T_ 0}},
{{"APE" ENVIRONMENT? .},{0}},
enddoc)
_HEADER({ENVIRONMENT?},{ENVQ},{DOCOL})
        DC      LIT, ENV, TWID, PFIND
        DC      TOR, TDROP, FROMR
        DC      LDUP
        _0BRANCH(ENVQ1)
        DC      EXEC
        DC      LIT, -1
ENVQ1:
        DC      SEMIS
_C
_LOAD_({
worddoc( {SCREEN},{TRIAD},{triad},{scr ---},{},
{Display on the selected output device the three screens which
include that numbered forthvar({scr}) , beginning with a screen evenly divisible
by three. Output is suitable for source text records, and includes a
reference line at the bottom taken from line 0 of the first error screen.},
{{MESSAGE},{ERRSCR} },
{{." interactive"},{interactive}},
enddoc)
_HEADER({TRIAD},{TRIAD},{DOCOL})
        DC      LIT,AFF
        DC      EMIT
        DC      LIT,3
        DC      SLASH
        DC      LIT,3
        DC      STAR
        DC      LIT,3
        DC      OVER,PLUS
        DC      SWAP
        _DO(TRIA9)
TRIA1:  DC      CR,IDO
        DC      LLIST
        _LOOP(TRIA1)    _C{THEN}
TRIA9:
        DC      CR
        DC      ZERO, MESS
        DC      SEMIS
})_C{}_END_({_LOAD_})
_C
_C{ This word is not even fig!}
worddocsafe( {MISC},{.SIGNON},{dot_cpu},{---},{},
{Print a message identifying the version of this Forth.
_VERBOSE_({{ The name of the processor known from the environment
query }forthcode({CPU}){ is printed using the bizarre convention of a
base-36 number. This is a tribute to those FIG-pioneers.}}) },
{{ABORT},{COLD}},
{{." Interactive"},{Interactive}},
{{COLD}},
enddoc)
_HEADER({.SIGNON},{SIGNON},{DOCOL})
_C{ PRINT CPU TYPE (8088)}
        DC      CR
        DC      BASE,FETCH
        DC      LIT,36, BASE,STOR
        DC      LCPU, DDOT
        DC      BASE,STOR
_C
        DC      LENAME, LTYPE, SPACE
        DC      LVERSION, LTYPE, SPACE
        DC      CR
        DC      SEMIS
_C
_DIRECTMAPPED_({
_C
worddoc( {MEMORY},{LOW-DP},{low_dictionary_pointer},{---- addr},{},
{A user variable leaving the lowest address that is free in the lowest
1 Mbyte of physical memory. This variable can be swapped with DP to
compile into this area. This takes care to skip those areas
below 1M that are used, for GDT, real time stack and such.
},{{LOW-EM}}, {}, enddoc)
_HEADER({LOW-DP},{LOWDP},{DOUSE}, _CELLS(16))
_C
worddoc( {MEMORY},{LOW-EM},{low_end_memory},{---- addr},{},
{A user variable leaving the address just above the highest memory
usable in the lowest 1 Mbyte of physical memory. This area can be used
to compile buffers into that must be accessed from real mode.
},{{DP},{EM}}, {}, enddoc)
_HEADER({LOW-EM},{LOWEM},{DOUSE}, _CELLS(17))
_C
})_C{}_END_({ _DIRECTMAPPED_})
_C
_C{**** LAST DICTIONARY WORD ****}
worddoc( {MISC},{TASK},{task},{},{},
{A no-operation word which marks the boundary between
the Forth system and applications. },{{COLD}},
{{!CSP TASK ?CSP},{}},
enddoc)
_HEADER({TASK},{TASK},{DOCOL})
        DC      SEMIS
_C
_EQULAYOUT_({
TEXTEND  EQU     _AP_       _C{ Show end of dictionary.}
INITDP   EQU     M4_INITDP _C{Where we want new words.}
ACTUAL_EM EQU    EM  _C{ Different for relocatable code only.}
_LARGE_({
         ORG     M4_EM-8    _C{ Silly, NASM doesn't accept EM}
         DB 0,0,0,0,0,0,0,0
})_C{}_END_({ _LARGE_})
})_C{}_END_({ _EQULAYOUT_})

_COMMENTED({

The remaining memory ( up to 'EM' ) is
used for:

        1. EXTENSION DICTIONARY
        2. DATA STACK
        3. TERMINAL INPUT BUFFER
        4. RETURN STACK
        5. USER VARIABLE AREA
        6. BUFFERS FOR SCREENS


})

_LAYOUTBYSECTION_({
_C{       This is the proper way to do it.}
_C{       No memory addresses should be arrived at through equates.}
_C{       However now we must teach the linker to keep the}
_C{       two sections together.}

FORTHSIZE       EQU     _AP_ - _main
        _BSS_

INITDP:                 _C{  It may be that it is not consecutive with TASK.}
                        _C{  Because of bad linking, resulting in a unusable Forth.}
        BUFFERSIZE      EQU  (KBBUF+2*CW)*NBUF

_C{ For more task the TAS area is duplicated; the remainder is the same.}
        _RESB( EM - FORTHSIZE - TAS - BUFFERSIZE )
_C{ INITR1:                         Return stack for next task}
_C          _RESB( US )             _C{  For next task, if present. }
_C{ The following framework may be repeated for more tasks.}
_C{ It is floating, i.e. it may be shifted up and down, in order}
_C{ to have INITR0 at a STACKSIZE boundary. }
        _RESB( STACKSIZE - US )   _C{ Data stack, only limited if more tasks present.}
INITS0:                         _C{ Grows down.}
STRTIB: _RESB( TIBSIZE )    _C{ Terminal input buffer.}
        _RESB( STACKSIZE )      _C{ Return stack, grows down.}
INITR0:                         _C{ Grows down}
STRUSA: _RESB( US )             _C{ User area}
_THREADS_(
{        _RESB( STACKSIZE )            _C{ Possibly the framework is shifted up by this.}
})dnl _END_({_THREADS_})
BUF1:   _RESB( BUFFERSIZE )     _C{ FIRST DISK BUFFER}
ACTUAL_EM:  _C{ Differs from EM if code is relocated.}

})_C{}_END_({ _LAYOUTBYSECTION_})
_C

_BOOTED_({
        CSEG    ENDS
})_C{}_END_({ _BOOTED_})
        PAGE
_COMMENTED({

  MISC. NOTES AND SCATTERED THOUGHTS

- Remember that all the FORTH words in this version are
  upper case letters.  Use <CAPS LOCK> when in FORTH.

_HOSTED_MSDOS_({
- This source will assemble on all platforms where NASM is
  available.

  On MSDOS the command line is:
  nasm -fbin ci86.asm -o ci86.com
  (There may be exceptions for special configurations.)
  The result will run on MSDOS systems only, or stand alone
  an an IBM-compatible computer

- In a MODERN version <ctrl> P  will echo all output to the
  printer. This is not programmed here, but a feature of the MSDOS.
  The operating system may make available a command history too.

- Changing variable EM will allow you to create a larger
  dictionary space.  However I suggest you develop and
  DEBUG with EM set to 0x4000.  Setting it to a larger value
  will result in a larger FORTH.EXE file, and you may
  need to run EXE2BIN ( Chap 10, DOS 2.0 ) to get enough
  disk space.  Once you are satisfied with what you have,
  then by all means take that extra memory.

- <Ctrl-Break> will vector to WARM start ( Label WARM_ENTRY: )
})_C{}_END_({ _HOSTED_MSDOS_})

- Subscribe to FORTH Dimensions.  It is a valuable source
  of system and application ideas.  Talking with fellow
  FORTH programmers is sure to stir up some exciting ideas.
  Consider joining a FIG chapter.  See the back of FORTH
  Dimensions for more info.

})

_C{ Define the entry point, not valid for auto booting.}
        _ENDOFPROGRAM(_ORIG)
worddocchapter({COMPILING},{ },
{The wordset forthsamp({COMPILING}) contains words that compile
words and numbers.
They need special attention because these words in general execute during
compilation forthxref({IMMEDIATE}) .
Numbers are compiled forthdefi({in line}) , behind a word that fetches
them.},
{},{},{},{}, {}, enddoc)
worddocchapter({CONTROL},{ },
{The wordset forthsamp({CONTROL}) contains words that influence the control flow
of a program, i.e. the sequence in which commands are executed in compiled words.
With control words you can have actions performed repeatedly, or
depending on conditions.
},{},{},{},{}, {}, enddoc)
worddocchapter({DEFINING},{ },
{The wordset forthsamp({DEFINING}) contains words that add new entries
to the dictionary, or are related to those words.
A number of such forthdefi({defining word})'s
are predefined, but there is
also the possibility to make new defining words, using
forthcode({CREATE}) and forthcode({DOES>}) .
},
{},{},{},{}, {}, enddoc)
worddocchapter({DICTIONARY},{ },
{The wordset forthsamp({DICTIONARY}) contains words that at a
lower level than the wordset forthsamp({DEFINING}) concern the
memory area that is allocated to the dictionary. They may add
data to the dictionary at the expense of the free space, one
cell or one byte at a time, or allocate a buffer at once. The
dictionary space may also be shrunk, and the words that were
there are lost. The forthdefi({dictionary entry address}) or
forthdefi({dea}) represents a word. It is the lowest address of
a record with fields. Words to access those fields also belong
to this wordset.},
{},{},{},{}, {}, enddoc)
worddocchapter({DOUBLE},{ },
{The wordset forthsamp({DOUBLE}) contains words that manipulate forthdefi({double})'s.
_BITS32_({In this 32 Forth you would hardly need doubles if it weren't
for the NUMBER formatting wordset that uses them exclusively.})},
{},{},{},{}, {}, enddoc)
worddocchapter({ERRORS},{ },
{The wordset forthsamp({ERRORS}) contains words to handle errors
and exceptions.},
{},{},{},{}, {}, enddoc)
worddocchapter({FORMATTING},{ },
{The wordset forthsamp({FORMATTING}) generates formatted output for
numbers, i.e. printing the digits in a field with a certain width,
possibly with sign etc.
This is possible in any forthdefi({number base}). (Normally base 10 is used,
which means that digits are found as a remainder by dividing by 10).
Formatting in Forth is always based on forthdefi({double}) numbers.
Single numbers are handled by converting them to forthdefi({double}) first.
This requires some double precision operators to be present in the Forth core.
forthxref({DOUBLE}) wordset. forthxref({MULTIPLYING}) wordset.
},
{},{},{},{}, {}, enddoc)
worddocchapter({INITIALISATIONS},{ },
{The wordset forthsamp({INITIALISATIONS}) contains words to initialise,
reinitialise or configure Forth.},
{},{},{},{}, {}, enddoc)
worddocchapter({DENOTATIONS},{ },
{The wordset forthsamp({DENOTATIONS}) contains prefixes (mostly one letter
words) that introduce a forthdefi({denotation}), i.e. a generalisation of
forthcode({NUMBER}) . forthcode({PREFIX}) turns the latest definition into
a prefix, similar to forthcode({IMMEDIATE}).
If a word starting with the prefix is looked up in the dictionary,
the prefix is found and executed.
Prefix words parse input and leave a constant
(number, char or string) on the stack, or compile such constant,
depending on forthcode({STATE}).
For a kernel system it is guaranteed that they reside in the minimum search
order wordlist, associated with the namespace forthcode({ONLY}).
To make a distinction with the same words in other wordlists,
the names of denotations are prepended with ``Prefix_'' in the
documentation. Actual names consists of the one character following
``Prefix_''.
Apart from forthcode({Prefix_0}) , forthcode({ONLY}) contains
entries for all hex digits 1...9 and A...F.
Like forthcode({NUMBER}) always did, all denotations behave
identical in interpret and compile mode and they are not supposed to be
postponed.
The use of prefixes for other purposes than denotations require great care.
},
{},{},{},{}, {}, enddoc)
worddocchapter({ENVIRONMENTS},{ },
{The wordset forthsamp({ENVIRONMENTS}) contains all words of
the forthcode({ENVIRONMENT}) namespace and those words needed
to recognize them as Forth environment queries.
_VERBOSE_({{Note that these are not environment variables in
the sense that they are passed from an operating system to a
program.}}) },
{},{},{},{}, {}, enddoc)
worddocchapter({INPUT},{ },
{The wordset forthsamp({INPUT}) contains words to get input from the terminal
and such.
_FILES_({forthxref({FILES}) for disk I/O.})
forthxref({BLOCKS}) for access of blocks. },
{},{},{},{}, {}, enddoc)
worddocchapter({JUGGLING},{ },
{The wordset forthsamp({JUGGLING}) contains words that change order
of data on the forthdefi({data stack}) .
The necessity for this arise, because the data you want to feed to a Forth word
is not directly accessible, i.e. on top of the stack.
It is also possible that  you need the same data twice, because you have to feed
it to two different words.
Design your word such that you need them as little as possible,
because they are confusing.},
{},{},{},{}, {}, enddoc)
worddocchapter({LOGIC},{ },
{The wordset forthsamp({LOGIC}) contains logic operators and
comparison operators.
A comparison operator (such as forthcode({=}) ) delivers a
forthdefi({Forth flag}), -1 for true, 0 for false, representing a
condition (such as equality of two numbers).
_VERBOSE_({{The number -1 has all bits set to one.}})
The logical operators ( forthcode({AND}) etc.)
work on all _BITS_ bits, one by one.
In this way they are useful for mask operations, as well
as for combining conditions
represented as flag's.
But beware that forthcode({IF}) only cares whether
the top of the stack is non-zero, such that
forthcode({-}) can mean non-equal to forthcode({IF}).
Such conditions (often named just forthdefi({flag})'s)
cannot be directly combined using logical operators,
but forthsamp({0= 0=}) can help.},
{},{},{},{}, {}, enddoc)
worddocchapter({MEMORY},{ },
{The wordset forthsamp({MEMORY}) contains words to fetch and
store numbers from forthdefi({double})s, forthdefi({cell})s or bytes in memory.
There are also words to copy blocks of memory or fill them, and words that
fetch a forthdefi({cell}), operate on it and store it back.},
{},{},{},{}, {}, enddoc)
worddocchapter({MISC},{ },
{The wordset forthsamp({MISC}) contains words that defy categorisation.},
{},{},{},{}, {}, enddoc)
worddocchapter({MULTIPLYING},{ },
{The _LARGE_(original) 16 bits Forth's have problems with overflow (forthpxref({OPERATOR})).
Operators with intermediate results of double precision, mostly scaling operators,
solve this and are
present in the forthsamp({MULTIPLYING}) wordset. _LARGE_({In this _BITS_ bit Forth
you will have less need, but scaling remains tricky}).
Formatting is done with forthdefi({double})'s exclusively, and relies
on this wordset. Operators with mixed precision and unsigned operators
allow to build arbitrary precision operators from them in forthdefi({high level}) code.},
{},{},{},{}, {}, enddoc)
worddocchapter({OPERATOR},{ },
{The wordset forthsamp({OPERATOR}) contains the familiar operators for addition, multiplication etc.
The result of the operation is always
an integer number, so division can't be precise.
On ciforth all division operations are compatible with forthdefi({symmetric division}).

_VERBOSE_({The ISO standard require a Forth to choose between floored or symmetric division
for its standard operations.})
Divisions involving negative numbers have an interpretation problem.
In any case we want the combination of forthcode({/}) and
forthcode({MOD}) (remainder) to be such that you can get the
original forthsamp({n}) back from the two values left by
forthsamp({n m MOD}) and  forthsamp({n m /}) by performing forthsamp({m * +}) .
This is true for all Forth's.
On ciforth the forthcode({/}) is a forthdefi({symmetric division}), i.e.
forthsamp({-n m /}) give the same result as forthsamp({n m /}), but negated.
The foregoing rule now has the consequence that forthsamp({m MOD})
has forthsamp({2|m|-1}) possible outcomes instead of forthsamp({|m|}) .
This is very worrisome for mathematicians, who stick to the
rule that forthsamp({m MOD}) has forthsamp({|m|}) outcomes:
forthsamp({0 ... |m|-1}), or forthsamp({-|m|+1 ... 0 }) for
negative numbers. (forthdefi({floored division})). _BITS16_(
{Having a mere 30000 for the number range can easily
lead to overflow in intermediate results during
forthdefi({scaling}): a multiplication followed by a division.
_VERBOSE_({{For example }forthsamp({: ADD10% 110 * 100 / ;}){}}).
There are special operators to get around that.
forthxref({MULTIPLYING}).})},
 {},{},{},{}, {}, enddoc)
worddocchapter({OUTPUT},{ }, {The wordset forthsamp({OUTPUT})
contains words to output to the terminal and such.
_FILES_({forthxref({FILES}) for disk I/O.})
forthxref({BLOCKS}) for blocks.},
{},{},{},{}, {}, enddoc)
worddocchapter({PARSING},{ },
{The forthdefi({outer interpreter}) is responsible for parsing,
i.e. it gets a word from the forthdefi(
{current input source} ) and interprets or compiles it,
advancing the forthcode({PP}) pointer.
The wordset forthsamp({PARSING}) contains the words used by this
interpreter and other words that consume characters from the
input source. In this way the outer interpreter need not be
very smart, because its capabilities can be extended by new
words based on those building blocks.},
{},{},{},{})
worddocchapter({SCREEN},{ },
{Most of the forthdefin({blocks}) mass storage is used for forthdefi({screen})'s that
have 16 lines of 64 characters. They are used for source code
and documentation.
Each screen is one forthcode({BLOCK}) as required by ISO.
The forthsamp({SCREEN}) wordset contains facilities to view screens,
and forthdefi({load}) them, that is compiling them and thus extending
the base system.
A system is customized by loading source screens, possibly one of
these extension is a text editor for screens.},
{},{},{},{}, {}, enddoc)
worddocchapter({SECURITY},{ },
{The wordset forthsamp({SECURITY}) contains words that are used by control
words to abort with an error message if the control structure is not
correct. _VERBOSE_({{Some say that this is not Forth-like.}})
You only need to know them if you want to extend the
forthsamp({CONTROL}) wordset.
_NO_SECURITY_({{This version of ciforth contains no security, so the remainder
of the chapter is empty.
_VERBOSE_({{You may want to ask your implementor to supply a secure version.
}forthxref({Rationale & legalese}){.}})
}})
},
{},{},{},{}, {}, enddoc)
worddocchapter({STACKS},{ },
{The wordset forthsamp({STACKS}) contains words related to the
forthdefi({data stack}) and forthdefi({return stack}).
Words can be moved between both stacks.
Stacks can be reinitialised and the value used to initialise the
forthdefi({stack pointer})'s can be altered.},
{},{},{},{}, {}, enddoc)
worddocchapter({BLOCKS},{ },
{The block mechanism connects to the Forth system a single background
storage divided in numbered forthdefi({blocks}).
The wordset forthsamp({BLOCKS}) contains words to input and
output to this mass storage. In this ciforth blocks reside
_RWSECTRK_({{ on the disk, by sector and track, }}) _BOOTLBA_({
on the hard disk}) _HOSTED_({{in a file, by default
named }forthfile({forth.lab}){. }}). Most blocks are used for the
forthsamp({SCREEN}) facility, where each block contains source
code.
},
{},{},{},{}, {}, enddoc)
_FILES_({
worddocchapter({FILES},{ },
{The wordset forthsamp({FILES}) contains words to input and output
to files, or load words from files.
_HOSTED_({They also are underlying the forthsamp({BLOCKS}) facilities.})},
{},{},{},{}, {}, enddoc)
})_C{}_END_({_FILES_})
worddocchapter({STRING},{ },
{The wordset forthsamp({STRING}) contains words that manipulate
strings of characters.
In ciforth strings have been given their civil rights.
So they are entitled to a forthdefi({denotation}) (the word forthcode({"}) )
and have a proper fetch and store.
An (address length) pair is considered a forthdefi({string constant}).
It may be trimmed, but the data referring to via the address must not be changed.
It can be stored in a buffer, a forthdefi({string variable}), that contains
in its first cell the count. Formerly this was in the first byte, and these
are called forthdefi({old fashioned string})'s _VERBOSE_({{ (or less
flatteringly: brain-damaged)}}).
},
{},{},{},{}, {}, enddoc)
worddocchapter({SUPERFLUOUS},{ },
{The wordset forthsamp({ SUPERFLUOUS}) contains words that are superfluous,
because they are equivalent to small sequences of code.
_VERBOSE_({Traditionally one hoped to speed Forth up by coding these words
directly.})},
{},{},{},{}, {}, enddoc)
worddocchapter({OPERATINGSYSTEM},{ },
{The wordset forthsamp({OPERATINGSYSTEM}) contains words that call the underlying operating
system or functions available in the BIOS-rom.},
{},{},{},{}, {}, enddoc)
worddocchapter({LIBRARY},{ },
{The words of the library have nothing particular in common,
except that they are available in the Library Accessable by Block forthdefi({LAB}) and not the
ciforth kernel.
_SUPPRESSED({{
They are either words from the library that are sufficiently useful
to merit being described here, or legacy words that
were in the kernel in earlier versions.
}})
All of them can be loaded from the library by forthsamp({WANT})
forthvar({SOME_WORD}).
Most common ISO words are available.
The assembler is loaded by forthsamp({WANT ASSEMBLERi86}) .
Floating point is loaded by forthsamp({WANT -fp-}) .
Interactive controle structures are loaded by forthsamp({WANT -scripting-}) .
Multi-tasking is loaded by forthsamp({WANT THREAD-PET}) .
The memory wordset is loaded by forthsamp({WANT ALLOCATE}) .

Useful application words in the forthdefi({LAB}) are i.a. : forthcode({ALIAS}) forthcode({QSORT}) forthcode({MERGE-SORT}) .
Useful debugging words in the forthdefi({LAB}) are i.a. : forthcode({DO-DEBUG}) forthcode({LOCATE}) forthcode({SEE}) forthcode({REGRESS}) .
Non-iso words are supposedly usable from the description that goes with the code.

},
{},{},{},{},{}, enddoc)
worddocchapter({WORDLISTS},{ },
{The dictionary is subdivided in non-overlapping subsets: the
forthdefi({word list})'s (forthpxref({DICTIONARY})).
They are created by the defining word
forthcode({NAMESPACE}) and filled by defining words while that
forthdefi({namespace}) is forthcode({CURRENT}) . They regulate how words
are found; different vocabularies can have words with the same
names.

A word list in the ISO sense has a
forthdefi({word list identifier}) or forthdefi({WID}),
but no name which is inconvenient.
We use namespace words created by the defining
word forthcode({NAMESPACE}) . They are used to manipulate the
word list's that are associated with them. _VERBOSE_({{So
namespaces are nearly the wordlist 's of the ISO standard,
the primary difference is that they have a name.
In most Forth literature namespaces are referred to as vocabularies,
and a word forthcode({VOCABULARY}) is used to create them.
}}) },
{},{},{},{})
